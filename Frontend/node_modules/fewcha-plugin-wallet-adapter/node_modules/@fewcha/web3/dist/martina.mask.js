"use strict";
// Copyright 2022 Fewcha. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.MartianMask = exports.MartianMaskToken = exports.MartianMaskSDK = void 0;
const types_1 = require("./types");
class MartianMaskSDK {
    provider;
    constructor(provider) {
        this.provider = provider;
    }
    async getAccountResources(accountAddress, query) {
        const res = await this.provider.getAccountResources(accountAddress);
        return (0, types_1.createReponse)("getAccountResources", 200, res);
    }
    async getAccount(accountAddress) {
        const res = await this.provider.getAccount(accountAddress);
        return (0, types_1.createReponse)("getAccount", 200, res);
    }
    async getTransactions(query) {
        let res = null;
        if (query) {
            res = await this.provider.getTransactions(query);
        }
        else {
            res = await this.provider.getTransactions();
        }
        return (0, types_1.createReponse)("getTransactions", 200, res);
    }
    async getAccountTransactions(accountAddress, query) {
        const res = await this.provider.getAccountTransactions(accountAddress);
        return (0, types_1.createReponse)("getAccountTransactions", 200, res);
    }
    async getTransactionByHash(txnHash) {
        const res = await this.provider.getTransaction(txnHash);
        return (0, types_1.createReponse)("getTransactionByHash", 200, res);
    }
    async getChainId() {
        const res = await this.provider.getChainId();
        return (0, types_1.createReponse)("getChainId", 200, res);
    }
}
exports.MartianMaskSDK = MartianMaskSDK;
class MartianMaskToken {
    provider;
    constructor(provider) {
        this.provider = provider;
    }
    async createCollection(name, description, uri, maxAmount) {
        const txnHash = await this.provider.createCollection(name, description, uri);
        return (0, types_1.createReponse)("createCollection", 200, txnHash);
    }
    async createToken(collectionName, name, description, supply, uri, max, royalty_payee_address, royalty_points_denominator, royalty_points_numerator, property_keys, property_values, property_types) {
        const txnHash = await this.provider.createToken(collectionName, name, description, supply, uri, 1);
        return (0, types_1.createReponse)("createToken", 200, txnHash);
    }
}
exports.MartianMaskToken = MartianMaskToken;
class MartianMask {
    //todo: [generateRawTransaction,generateSignSubmitRawTransaction,BCS,generateSignSubmitWaitForTransaction]
    provider;
    user;
    sdk;
    token;
    constructor(provider) {
        this.provider = provider;
        this.sdk = new MartianMaskSDK(provider);
        this.token = new MartianMaskToken(provider);
    }
    setUser(user) {
        this.user = user;
    }
    async reConnect() {
        const response = await this.provider.connect();
        if (response) {
            const user = {
                address: response.address,
                publicKey: response.publicKey,
            };
            this.setUser(user);
        }
    }
    async connect() {
        const response = await this.provider.connect();
        if (response) {
            const user = {
                address: response.address,
                publicKey: response.publicKey,
            };
            this.setUser(user);
        }
        return (0, types_1.createReponse)("connect", 200, response);
    }
    async disconnect() {
        const response = await this.provider.disconnect();
        this.setUser(null);
        return (0, types_1.createReponse)("disconnect", 200, response);
    }
    async isConnected() {
        if (this.user.address && this.user.publicKey) {
            return (0, types_1.createReponse)("isConnected", 200, true);
        }
        return (0, types_1.createReponse)("isConnected", 200, false);
    }
    async account() {
        if (!this.user) {
            await this.reConnect();
        }
        return (0, types_1.createReponse)("account", 200, this.user);
    }
    async getNetwork() {
        const res = await this.provider.network();
        console.log("7s62::getNetwork:", res);
        return (0, types_1.createReponse)("getNetwork", 200, res);
    }
    async getNetworkURL() {
        const res = await this.provider.network();
        console.log("7s62::getNetworkURL:", res);
        return (0, types_1.createReponse)("getNetworkURL", 200, res);
    }
    async getBalance() {
        console.log("7s62::getBalance");
        const res = await this.provider.legacy.getAccountBalance();
        console.log("7s62::getBalance:", res);
        return (0, types_1.createReponse)("getAccountBalance", 200, res);
    }
    async generateTransaction(payload, options) {
        console.log("7s62::generateTransaction");
        if (!this.user) {
            await this.reConnect();
        }
        const res = await this.provider.generateTransaction(this.user.address, payload);
        return (0, types_1.createReponse)("generateTransaction", 200, res);
    }
    async signTransaction(txnRequest) {
        const res = await this.provider.signTransaction(txnRequest);
        return (0, types_1.createReponse)("signTransaction", 200, res);
    }
    async submitTransaction(signedTxnRequest) {
        const res = await this.provider.submitTransaction(signedTxnRequest);
        return (0, types_1.createReponse)("submitTransaction", 200, res);
    }
    async generateSignSubmitTransaction(payload, extraArgs) {
        console.log("7s62::generateSignSubmitTransaction");
        if (!this.user) {
            await this.reConnect();
        }
        const gen = await this.provider.generateTransaction(this.user.address, payload);
        const sign = await this.provider.signTransaction(gen);
        const sub = await this.provider.submitTransaction(sign);
        return (0, types_1.createReponse)("generateSignSubmitTransaction", 200, sub);
    }
    async signAndSubmitTransaction(txnRequest) {
        const res = await this.provider.signAndSubmitTransaction(txnRequest);
        return (0, types_1.createReponse)("signAndSubmit", 200, res);
    }
    async signMessage(message) {
        const res = await this.provider.signMessage(message);
        return (0, types_1.createReponse)("signMessage", 200, res);
    }
    async createCollection(name, description, uri, maxAmount) {
        const res = await this.provider.createCollection(name, description, uri, maxAmount);
        return (0, types_1.createReponse)("createCollection", 200, res);
    }
    async createToken(collectionName, name, description, supply, uri, max, royalty_payee_address, royalty_points_denominator, royalty_points_numerator, property_keys, property_values, property_types) {
        const res = await this.provider.createToken(collectionName, name, description, supply, uri, max, royalty_payee_address, royalty_points_denominator, royalty_points_numerator, property_keys, property_values, property_types);
        return (0, types_1.createReponse)("createToken", 200, res);
    }
    async getTransactionByHash(txnHash) {
        const res = await this.provider.getTransaction(txnHash);
        return (0, types_1.createReponse)("getTransactionByHash", 200, res);
    }
    async getLedgerInfo() {
        const res = await this.provider.getLedgerInfo();
        return (0, types_1.createReponse)("getLedgerInfo", 200, res);
    }
}
exports.MartianMask = MartianMask;
