import { BCS, MaybeHexString, Types as Gen } from "aptos";
import { PublicAccount, Response } from "./types";
declare type User = {
    address: string;
    publicKey: string;
};
export declare class MartianMaskSDK {
    provider: any;
    constructor(provider: any);
    getAccountResources(accountAddress: MaybeHexString, query?: {
        ledgerVersion?: BigInt | number;
    }): Promise<Response<Gen.MoveResource[]>>;
    getAccount(accountAddress: MaybeHexString): Promise<Response<Gen.AccountData>>;
    getTransactions(query?: {
        start?: BigInt | number;
        limit?: number;
    }): Promise<Response<Gen.Transaction[]>>;
    getAccountTransactions(accountAddress: MaybeHexString, query?: {
        start?: BigInt | number;
        limit?: number;
    }): Promise<Response<Gen.Transaction[]>>;
    getTransactionByHash(txnHash: string): Promise<Response<Gen.Transaction>>;
    getChainId(): Promise<Response<number>>;
}
export declare class MartianMaskToken {
    provider: any;
    constructor(provider: any);
    createCollection(name: string, description: string, uri: string, maxAmount?: BCS.AnyNumber): Promise<Response<string>>;
    createToken(collectionName: string, name: string, description: string, supply: number, uri: string, max?: BCS.AnyNumber, royalty_payee_address?: MaybeHexString, royalty_points_denominator?: number, royalty_points_numerator?: number, property_keys?: Array<string>, property_values?: Array<string>, property_types?: Array<string>): Promise<Response<string>>;
}
export declare class MartianMask {
    provider: any;
    user: User;
    sdk: any;
    token: any;
    constructor(provider: any);
    setUser(user: User): void;
    reConnect(): Promise<void>;
    connect(): Promise<Response<PublicAccount>>;
    disconnect(): Promise<Response<boolean>>;
    isConnected(): Promise<Response<boolean>>;
    account(): Promise<Response<PublicAccount>>;
    getNetwork(): Promise<Response<string>>;
    getNetworkURL(): Promise<Response<string>>;
    getBalance(): Promise<Response<string>>;
    generateTransaction(payload: Gen.EntryFunctionPayload, options?: Partial<Gen.SubmitTransactionRequest>): Promise<Response<Uint8Array>>;
    signTransaction(txnRequest: Gen.SubmitTransactionRequest): Promise<Response<Gen.SubmitTransactionRequest>>;
    submitTransaction(signedTxnRequest: Gen.SubmitTransactionRequest): Promise<Response<Gen.HexEncodedBytes>>;
    generateSignSubmitTransaction(payload: Gen.EntryFunctionPayload, extraArgs?: {
        maxGasAmount?: BCS.Uint64;
        gasUnitPrice?: BCS.Uint64;
        expireTimestamp?: BCS.Uint64;
    }): Promise<Response<Gen.HexEncodedBytes>>;
    signAndSubmitTransaction(txnRequest: Gen.SubmitTransactionRequest): Promise<Response<Gen.HexEncodedBytes>>;
    signMessage(message: string): Promise<Response<string>>;
    createCollection(name: string, description: string, uri: string, maxAmount: BCS.AnyNumber): Promise<Response<string>>;
    createToken(collectionName: string, name: string, description: string, supply: number, uri: string, max: BCS.AnyNumber, royalty_payee_address: MaybeHexString, royalty_points_denominator: number, royalty_points_numerator: number, property_keys: Array<string>, property_values: Array<string>, property_types: Array<string>): Promise<Response<Gen.HexEncodedBytes>>;
    getTransactionByHash(txnHash: string): Promise<Response<Gen.Transaction>>;
    getLedgerInfo(): Promise<Response<Gen.IndexResponse>>;
}
export {};
//# sourceMappingURL=martina.mask.d.ts.map