import { Provider } from './provider';
import { JsonRpcClient } from '../rpc/client';
import { ExecuteTransactionRequestType, GatewayTxSeqNumber, GetObjectDataResponse, GetTxnDigestsResponse, ObjectId, ObjectOwner, Ordering, PaginatedTransactionDigests, SubscriptionId, SuiAddress, SuiEventEnvelope, SuiEventFilter, SuiEvents, SuiExecuteTransactionResponse, SuiMoveFunctionArgTypes, SuiMoveNormalizedFunction, SuiMoveNormalizedModule, SuiMoveNormalizedModules, SuiMoveNormalizedStruct, SuiObjectInfo, SuiObjectRef, SuiTransactionResponse, TransactionDigest, TransactionQuery } from '../types';
import { SignatureScheme } from '../cryptography/publickey';
import { WebsocketClient, WebsocketClientOptions } from '../rpc/websocket-client';
export declare const LATEST_RPC_API_VERSION = "latest";
export declare class JsonRpcProvider extends Provider {
    endpoint: string;
    skipDataValidation: boolean;
    private rpcAPIVersion;
    socketOptions: WebsocketClientOptions;
    protected client: JsonRpcClient;
    protected wsClient: WebsocketClient;
    /**
     * Establish a connection to a Sui RPC endpoint
     *
     * @param endpoint URL to the Sui RPC endpoint
     * @param skipDataValidation default to `true`. If set to `false`, the rpc
     * client will throw an error if the responses from the RPC server do not
     * conform to the schema defined in the TypeScript SDK. If set to `true`, the
     * rpc client will log the mismatch as a warning message instead of throwing an
     * error. The mismatches often happen when the SDK is in a different version than
     * the RPC server. Skipping the validation can maximize
     * the version compatibility of the SDK, as not all the schema
     * changes in the RPC response will affect the caller, but the caller needs to
     * understand that the data may not match the TypeSrcript definitions.
     * @param rpcAPIVersion controls which type of RPC API version to use.
     */
    constructor(endpoint: string, skipDataValidation?: boolean, rpcAPIVersion?: string, socketOptions?: WebsocketClientOptions);
    getMoveFunctionArgTypes(packageId: string, moduleName: string, functionName: string): Promise<SuiMoveFunctionArgTypes>;
    getNormalizedMoveModulesByPackage(packageId: string): Promise<SuiMoveNormalizedModules>;
    getNormalizedMoveModule(packageId: string, moduleName: string): Promise<SuiMoveNormalizedModule>;
    getNormalizedMoveFunction(packageId: string, moduleName: string, functionName: string): Promise<SuiMoveNormalizedFunction>;
    getNormalizedMoveStruct(packageId: string, moduleName: string, structName: string): Promise<SuiMoveNormalizedStruct>;
    getObjectsOwnedByAddress(address: string): Promise<SuiObjectInfo[]>;
    getGasObjectsOwnedByAddress(address: string): Promise<SuiObjectInfo[]>;
    getCoinBalancesOwnedByAddress(address: string, typeArg?: string): Promise<GetObjectDataResponse[]>;
    selectCoinsWithBalanceGreaterThanOrEqual(address: string, amount: bigint, typeArg?: string, exclude?: ObjectId[]): Promise<GetObjectDataResponse[]>;
    selectCoinSetWithCombinedBalanceGreaterThanOrEqual(address: string, amount: bigint, typeArg?: string, exclude?: ObjectId[]): Promise<GetObjectDataResponse[]>;
    getObjectsOwnedByObject(objectId: string): Promise<SuiObjectInfo[]>;
    getObject(objectId: string): Promise<GetObjectDataResponse>;
    getObjectRef(objectId: string): Promise<SuiObjectRef | undefined>;
    getObjectBatch(objectIds: string[]): Promise<GetObjectDataResponse[]>;
    getTransactions(query: TransactionQuery, cursor: TransactionDigest | null, limit: number | null, order: Ordering): Promise<PaginatedTransactionDigests>;
    getTransactionsForObject(objectID: string): Promise<GetTxnDigestsResponse>;
    getTransactionsForAddress(addressID: string): Promise<GetTxnDigestsResponse>;
    getTransactionWithEffects(digest: TransactionDigest): Promise<SuiTransactionResponse>;
    getTransactionWithEffectsBatch(digests: TransactionDigest[]): Promise<SuiTransactionResponse[]>;
    executeTransaction(txnBytes: string, signatureScheme: SignatureScheme, signature: string, pubkey: string): Promise<SuiTransactionResponse>;
    executeTransactionWithRequestType(txnBytes: string, signatureScheme: SignatureScheme, signature: string, pubkey: string, requestType?: ExecuteTransactionRequestType): Promise<SuiExecuteTransactionResponse>;
    getTotalTransactionNumber(): Promise<number>;
    getTransactionDigestsInRange(start: GatewayTxSeqNumber, end: GatewayTxSeqNumber): Promise<GetTxnDigestsResponse>;
    getRecentTransactions(count: number): Promise<GetTxnDigestsResponse>;
    syncAccountState(address: string): Promise<any>;
    getEventsByTransaction(digest: TransactionDigest, count?: number): Promise<SuiEvents>;
    getEventsByModule(package_: string, module: string, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByMoveEventStructName(moveEventStructName: string, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsBySender(sender: SuiAddress, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByRecipient(recipient: ObjectOwner, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByObject(object: ObjectId, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByTimeRange(count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    subscribeEvent(filter: SuiEventFilter, onMessage: (event: SuiEventEnvelope) => void): Promise<SubscriptionId>;
    unsubscribeEvent(id: SubscriptionId): Promise<boolean>;
}
