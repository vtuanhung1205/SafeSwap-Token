import * as _identity_connect_wallet_api from '@identity-connect/wallet-api';
import { SignMessageRequestArgs, SignTransactionWithPayloadRequestArgs, SignTransactionWithPayloadResponseArgs, SignTransactionWithRawTxnRequestArgs, SignTransactionWithRawTxnResponseArgs, SignTransactionRequestArgs, SignTransactionResponseArgs, SignAndSubmitTransactionRequestArgs, SignAndSubmitTransactionResponseArgs } from '@identity-connect/wallet-api';
import { NetworkName, SigningRequestTypes, SigningRequestStatus } from '@identity-connect/api';
import { CreateAxiosDefaults } from 'axios';
import { WalletRequest, GetConnectedAccountsResponseArgs, ConnectResponseArgs, SignMessageRequestArgs as SignMessageRequestArgs$1, SignMessageResponseArgs, SignTransactionRequestArgs as SignTransactionRequestArgs$1, SignTransactionResponseArgs as SignTransactionResponseArgs$1, SignAndSubmitTransactionRequestArgs as SignAndSubmitTransactionRequestArgs$1, SignAndSubmitTransactionResponseArgs as SignAndSubmitTransactionResponseArgs$1 } from '@identity-connect/keyless-wallet-api';

interface DappPairingData {
    accountAddress: string;
    accountAlias?: string;
    accountEd25519PublicKeyB64: string;
    accountTransportEd25519PublicKeyB64: string;
    currSequenceNumber: number;
    dappEd25519PublicKeyB64: string;
    dappEd25519SecretKeyB64: string;
    dappWalletId?: string;
    pairingId: string;
}
type DappPairingDataMap = {
    [address: string]: DappPairingData;
};
interface DappStateAccessors {
    get: (address: string) => Promise<DappPairingData | undefined>;
    getAll: () => Promise<DappPairingDataMap>;
    update: (address: string, pairing?: DappPairingData) => Promise<void>;
}
declare const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
/**
 * Default implementation of DappStateAccessors that uses the Window localStorage API.
 * This should work for most dapps.
 */
declare const windowStateAccessors: DappStateAccessors;

interface CancelToken {
    cancelled: boolean;
}

interface SignRequestOptions {
    cancelToken?: CancelToken;
    networkName?: NetworkName;
}
type OnDisconnectListener = (address: string) => void;
type OnDisconnectListenerCleanup = () => void;
interface ICDappClientConfig {
    accessors?: DappStateAccessors;
    axiosConfig?: CreateAxiosDefaults;
    defaultNetworkName?: NetworkName;
    frontendBaseURL?: string;
}
declare class ICDappClient {
    private readonly dappId;
    private readonly accessors;
    private readonly defaultNetworkName;
    private readonly axiosInstance;
    private readonly frontendBaseURL;
    private readonly initPromise?;
    constructor(dappId: string, { accessors, axiosConfig, defaultNetworkName, frontendBaseURL, }?: ICDappClientConfig);
    private getPairing;
    private syncFirstPairing;
    private createPairingRequest;
    private createSigningRequest;
    private getSigningRequest;
    private deletePairing;
    cancelSigningRequest(pairing: DappPairingData, id: string): Promise<{
        apiVersion: string;
        createdAt: string;
        id: string;
        networkName: string | null;
        pairing: {
            registeredDapp: {
                dappSpecificWalletAllowed: boolean;
                description: string | null;
                externalWalletPairingsAllowed: boolean;
                feePayerAllowed: boolean;
                hostname: string;
                iconUrl: string | null;
                id: string;
                name: string;
            };
        };
        pairingId: string;
        requestEnvelope: {
            encryptedPrivateMessage: {
                nonceB64: string;
                securedB64: string;
            };
            messageSignature: string;
            serializedPublicMessage: string;
        };
        requestType: SigningRequestTypes;
        responseEnvelope?: {
            encryptedPrivateMessage: {
                nonceB64: string;
                securedB64: string;
            };
            messageSignature: string;
            serializedPublicMessage: string;
        } | undefined;
        status: SigningRequestStatus;
    }>;
    private signRequest;
    /**
     * Requests a connection to an account (internally known as pairing).
     * @returns either the address of the connected account, or undefined if the
     * connection was cancelled.
     */
    connect(): Promise<string | undefined>;
    disconnect(address: string): Promise<void>;
    signMessage(address: string, args: SignMessageRequestArgs, options?: SignRequestOptions): Promise<_identity_connect_wallet_api.FullMessageParams & _identity_connect_wallet_api.FullMessageResult & {
        signature: string;
    }>;
    signTransaction(address: string, args: SignTransactionWithPayloadRequestArgs, options?: SignRequestOptions): Promise<SignTransactionWithPayloadResponseArgs>;
    signTransaction(address: string, args: SignTransactionWithRawTxnRequestArgs, options?: SignRequestOptions): Promise<SignTransactionWithRawTxnResponseArgs>;
    signTransaction(address: string, args: SignTransactionRequestArgs, options?: SignRequestOptions): Promise<SignTransactionResponseArgs>;
    signAndSubmitTransaction(address: string, args: SignAndSubmitTransactionRequestArgs, options?: SignRequestOptions): Promise<SignAndSubmitTransactionResponseArgs>;
    getConnectedAccounts(): Promise<{
        accountAddress: string;
        accountAlias: string | undefined;
        accountEd25519PublicKeyB64: string;
        dappWalletId: string | undefined;
    }[]>;
    offboard(address: string): Promise<boolean>;
    private readonly onDisconnectListeners;
    onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup;
}

interface PromptApproval<TResponseArgs> {
    args: TResponseArgs;
    status: 'approved';
}
interface PromptDismissal {
    status: 'dismissed';
}
type PromptResponse<TResponseArgs> = PromptApproval<TResponseArgs> | PromptDismissal;

type OmitUnion<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
interface ACKeylessClientConfig {
    dappImageURI?: string;
    dappName?: string;
    defaultNetworkName?: NetworkName;
    frontendBaseURL?: string;
}
declare class ACKeylessClient {
    private readonly defaultNetworkName;
    private readonly frontendBaseURL;
    private readonly dappInfo;
    constructor({ dappImageURI, dappName, defaultNetworkName, frontendBaseURL, }?: ACKeylessClientConfig);
    sendBackgroundRequest<T>(request: OmitUnion<WalletRequest, 'dappInfo'>, deserializeFn?: (value: string) => T): Promise<T>;
    private sendPromptRequest;
    isConnected(): Promise<boolean>;
    getConnectedAccounts(): Promise<GetConnectedAccountsResponseArgs>;
    disconnect(): Promise<void>;
    connect(): Promise<PromptResponse<ConnectResponseArgs>>;
    signMessage(args: SignMessageRequestArgs$1): Promise<PromptResponse<SignMessageResponseArgs>>;
    signTransaction(args: SignTransactionRequestArgs$1): Promise<PromptResponse<SignTransactionResponseArgs$1>>;
    signAndSubmitTransaction(args: SignAndSubmitTransactionRequestArgs$1): Promise<PromptResponse<SignAndSubmitTransactionResponseArgs$1>>;
}

export { ACKeylessClient, ACKeylessClientConfig, CancelToken, DAPP_PAIRINGS_WINDOW_STORAGE_KEY, DappPairingData, DappPairingDataMap, DappStateAccessors, ICDappClient, ICDappClientConfig, OnDisconnectListener, OnDisconnectListenerCleanup, SignRequestOptions, windowStateAccessors };
