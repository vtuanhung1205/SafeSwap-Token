{"version":3,"sources":["../src/index.ts","../src/JsonRPCServer.ts","../src/coder.ts","../src/utils.ts","../src/WalletAPI.ts","../src/version.ts","../src/MSafeServer.ts","../src/HandshakeMessage.ts","../src/connector.ts","../src/JsonRPCClient.ts","../src/MSafeWallet.ts"],"sourcesContent":["export * from './MSafeServer';\nexport * from './MSafeWallet';\nexport * from './WalletAPI';\nexport * from './JsonRPCServer';\nexport * from './JsonRPCClient';\nexport * from './connector';\nexport * from './coder';\nexport * from \"./utils\";","import { Connector } from \"./connector\";\nimport { JsonRpcParamsSchemaByPositional, JsonRpcPayloadRequest, parse, format, JsonRpcError } from 'json-rpc-protocol'\nimport { decodeFromStr, encodeToStr } from \"./coder\";\n\ntype RPCMethod = (...params: any[]) => Promise<any>;\n\nexport class JsonRPCServer {\n\n    constructor(public readonly connector: Connector, readonly methods: { [method: string]: RPCMethod }) {\n        this.connector.on('message', data => this.onRequest(data!));\n        this.connector.on('close', () => this.onClose());\n    }\n\n    private onRequest(data: string) {\n        const req = parse(data) as JsonRpcPayloadRequest;\n        if (req.type !== 'request') return;\n        const method = this.methods[req.method];\n        if (method === undefined) {\n            const resp = format.error(req.id, new JsonRpcError(\"method not exist\"));\n            this.connector.send(resp);\n            return;\n        }\n        method(...(req.params as JsonRpcParamsSchemaByPositional).map(param => decodeFromStr(param))).then(response => {\n            const resp = format.response(req.id, encodeToStr(response));\n            this.connector.send(resp);\n        }).catch(err => {\n            const resp = format.error(req.id, new JsonRpcError(String(err)));\n            this.connector.send(resp);\n        });\n    }\n\n    notify(type: string, data: any[]) {\n        const notification = format.notification(type, data.map(encodeToStr));\n        this.connector.send(notification);\n    }\n\n    get version() {\n        return this.connector.version;\n    }\n\n    private onClose() {\n\n    }\n}","import { Buffer } from \"buffer\";\nenum Type {\n    Boolean,\n    Number,\n    BigInt,\n    String,\n    Uint8Array,\n    Object,\n    Array,\n    Undefined,\n    Null,\n}\n\nfunction concat(list: Uint8Array[]): Uint8Array {\n    const total = list.reduce((size, a) => size + a.length, 0);\n    const arr = new Uint8Array(total);\n    let offset = 0;\n    list.forEach((a) => {\n        arr.set(a, offset);\n        offset += a.length;\n    });\n    return arr;\n}\n\nclass Decoder {\n    constructor(readonly data: Uint8Array, private byteOffset = data.byteOffset) { }\n\n    read(byteLength: number): Uint8Array {\n        const result = new Uint8Array(this.data.buffer, this.byteOffset, byteLength);\n        this.byteOffset += byteLength;\n        return result;\n    }\n\n    decodeBigInt(): bigint {\n        return BigInt(this.decodeString());\n    }\n\n    decodeNumber(): number {\n        return Number(this.decodeString());\n    }\n\n    decodeUint8Array(): Uint8Array {\n        const length = new Uint32Array(this.read(4).slice(0).buffer)[0];\n        return this.read(length);\n    }\n\n    decodeBoolean(): boolean {\n        return Boolean(this.read(1)[0]);\n    }\n\n    decodeString(): string {\n        const de = this.decodeUint8Array();\n        return Buffer.from(de).toString();\n    }\n\n    decodeArray(): any[] {\n        const length = this.decode<number>(); // decodeNumber\n        return Array(length).fill(0).map(() => this.decode());\n    }\n\n    decodeObject(): { [key: string]: any } {\n        const length = this.decode<number>(); // decodeNumber\n        const entries = Array(length).fill(0).map(() => [this.decode<string>(), this.decode()]);\n        return Object.fromEntries(entries);\n    }\n\n    decode<T>(): T {\n        const type = this.read(1)[0] as Type;\n        switch (type) {\n            case Type.BigInt:\n                return this.decodeBigInt() as any;\n            case Type.Number:\n                return this.decodeNumber() as any;\n            case Type.Boolean:\n                return this.decodeBoolean() as any;\n            case Type.String:\n                return this.decodeString() as any;\n            case Type.Uint8Array:\n                return this.decodeUint8Array() as any;\n            case Type.Array:\n                return this.decodeArray() as any;\n            case Type.Object:\n                return this.decodeObject() as any;\n            case Type.Undefined:\n                return undefined as any;\n            case Type.Null:\n                return null as any;\n        }\n        throw `unkonw type: ${type}`;\n    }\n}\n\nfunction encodeUint8Array(data: Uint8Array): Uint8Array {\n    const en = new Uint8Array(data.length + 5);\n    en[0] = Type.Uint8Array;\n    Buffer.from(en.buffer, 1, 4).writeUInt32LE(data.length);\n    en.set(data, 5);\n    return en;\n}\n\n\nfunction encodeUndefined(): Uint8Array {\n    return Uint8Array.from([Type.Undefined])\n}\n\nfunction encodeNull(): Uint8Array {\n    return Uint8Array.from([Type.Null])\n}\n\nfunction encodeBigInt(data: bigint): Uint8Array {\n    const en = encodeString(data.toString());\n    en[0] = Type.BigInt;\n    return en;\n}\n\nfunction encodeNumber(data: number): Uint8Array {\n    const en = encodeString(data.toString());\n    en[0] = Type.Number;\n    return en;\n}\n\nfunction encodeBoolean(data: boolean): Uint8Array {\n    return new Uint8Array([Type.Boolean, Number(data)]);\n}\n\nfunction encodeString(data: string): Uint8Array {\n    const buf = new ArrayBuffer(data.length);\n    Buffer.from(buf).write(data);\n    const en = encodeUint8Array(new Uint8Array(buf));\n    en[0] = Type.String;\n    return en;\n}\n\nfunction encodeObject(data: { [key: string]: any }): Uint8Array {\n    const entries = Object.entries(data);\n    const ens = entries.map(([key, value]) => {\n        const keyBuf = encode<string>(key);\n        const valueBuf = encode(value);\n        return concat([keyBuf, valueBuf]);\n    });\n    return concat([Uint8Array.from([Type.Object]), encode<number>(entries.length), ...ens]);\n}\n\n\nfunction encodeArray(data: any[]): Uint8Array {\n    const ens = data.map(elem => encode(elem));\n    return concat([Uint8Array.from([Type.Array]), encode<number>(ens.length), ...ens]);\n}\n\n\nexport function encode<T>(data: T): Uint8Array {\n    if (data instanceof Uint8Array) {\n        return encodeUint8Array(data);\n    }\n    if (data instanceof Array) {\n        return encodeArray(data);\n    }\n    if (data instanceof Object) {\n        return encodeObject(data);\n    }\n    if (data === null) {\n        return encodeNull();\n    }\n    switch (typeof data) {\n        case 'string':\n            return encodeString(data);\n        case 'number':\n            return encodeNumber(data);\n        case 'bigint':\n            return encodeBigInt(data);\n        case 'boolean':\n            return encodeBoolean(data);\n        case 'undefined':\n            return encodeUndefined();\n    }\n    throw `unsuport type: ${data}`;\n}\n\nexport function decode<T>(data: Uint8Array): T {\n    const decoder = new Decoder(data);\n    return decoder.decode();\n}\n\nexport function encodeToStr<T>(data: T): string {\n    return Buffer.from(encode(data).buffer).toString('hex');\n}\n\nexport function decodeFromStr<T>(data: string): T {\n    const buffer = new ArrayBuffer(data.length / 2);\n    Buffer.from(buffer).write(data, 'hex');\n    return decode(new Uint8Array(buffer));\n}\n\n","import {Account, LegacyAccount} from \"./WalletAPI\";\n\nexport function toLegacyAccount(account: Account): LegacyAccount {\n  return {\n    address: account.address,\n    publicKey: convertPKsToMultiSigPK(account.publicKey, account.minKeysRequired),\n  };\n}\n\nfunction convertPKsToMultiSigPK(pks: string[], threshold: number) {\n  let msPk = pks.map(pk => pk.startsWith('0x') ? pk.substring(2) : pk).join('');\n  msPk += threshold.toString(16).padStart(2, '0');\n  return '0x' + msPk;\n}","import { toLegacyAccount } from \"./utils\";\n\nexport interface Account {\n    publicKey: string[];\n    address: string;\n    authKey: string;\n    minKeysRequired: number;\n}\n\nexport interface LegacyAccount {\n    address: string,\n    publicKey: string,\n}\n\nexport type Option = Partial<{\n    max_gas_amount: string | bigint,\n    gas_unit_price: string | bigint,\n    expiration_timestamp_secs: string | bigint,\n    sequence_number: string | bigint,\n    sender: string,\n}>;\n\ntype Array<T> = T[];\ntype Base = string | number | BigInt | Uint8Array | boolean;\ntype Arg<T> = T | Array<Base>;\ntype Args = Array<Arg<Base>>;\n\nexport type Payload = {\n    function: string,\n    type_arguments: string[],\n    arguments: Args,\n} | Uint8Array;\n\nexport interface WalletAPI {\n    connect(): Promise<Account>,\n    disconnect(): Promise<void>,\n    isConnected(): Promise<boolean>,\n    network(): Promise<string>,\n    account(): Promise<Account>,\n    chainId(): Promise<Number>,\n    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>,\n    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>,\n    signMessage(message: string | Uint8Array): Promise<Uint8Array>,\n}\n\nexport enum WalletEvent {\n    ChangeAccount = 'ChangeAccountEvent',\n    ChangeNetwork = 'ChangeNetworkEvent',\n}\n\nexport enum WalletRPC {\n    connect = 'connect',\n    disconnect = 'disconnect',\n    isConnected = 'isConnected',\n    network = 'network',\n    account = 'account',\n    chainId = 'chainId',\n    signAndSubmit = 'signAndSubmit',\n    signTransaction = 'signTransaction',\n    signMessage = 'signMessage',\n}\n\n// LegacyWalletAPI is the adapted version of walletAPI.\n// It allows backward compatibility with legacy clients with account format `LegacyAccount`\ninterface LegacyWalletAPI {\n    connect(): Promise<LegacyAccount>,\n    disconnect(): Promise<void>,\n    isConnected(): Promise<boolean>,\n    network(): Promise<string>,\n    account(): Promise<LegacyAccount>,\n    chainId(): Promise<Number>,\n    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>,\n    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>,\n    signMessage(message: string | Uint8Array): Promise<Uint8Array>,\n}\n\nexport function adaptLegacyAccount(methods: WalletAPI): LegacyWalletAPI {\n    // Adapt legacy account\n    return {\n        connect(): Promise<LegacyAccount> {\n            return methods.connect().then(account => toLegacyAccount(account));\n        },\n        disconnect(): Promise<void> {\n            return methods.disconnect();\n        },\n        isConnected(): Promise<boolean> {\n            return methods.isConnected();\n        },\n        network(): Promise<string> {\n            return methods.network();\n        },\n        account(): Promise<LegacyAccount> {\n            return methods.account().then(account => toLegacyAccount(account));\n        },\n        chainId(): Promise<Number> {\n            return methods.chainId();\n        },\n        signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array> {\n            return methods.signAndSubmit(payload, option);\n        },\n        signTransaction(payload: Payload, option?: Option): Promise<Uint8Array> {\n            return methods.signTransaction(payload, option);\n        },\n        signMessage(message: string | Uint8Array): Promise<Uint8Array> {\n            return methods.signMessage(message);\n        }\n    };\n}","\n/// Versions that introduces new features.\nexport enum Versions {\n    ALLOWLIST = '2.0.5', // version that enable allowlist\n    SESSION_ID = '2.1.4', // version that enable session id\n};\n\n/// Compare two version strings.\nexport function cmp(a: string, b: string): number {\n    const parse = (version: string) => version.split('.').map(Number);\n    const [majorA, minorA, batchA] = parse(a);\n    const [majorB, minorB, batchB] = parse(b);\n    if (majorA > majorB) return 1;\n    if (majorA < majorB) return -1;\n    if (minorA > minorB) return 1;\n    if (minorA < minorB) return -1;\n    if (batchA > batchB) return 1;\n    if (batchA < batchB) return -1;\n    return 0;\n}\n\nexport function isSessionIDVersion(version: string | undefined): boolean {\n    return version !== undefined && cmp(version, Versions.SESSION_ID) >= 0;\n}\n\n/// Check if the version is enable allowlist.\nexport function isAllowList(version: string | undefined): boolean {\n    return version !== undefined && cmp(version, Versions.ALLOWLIST) >= 0;\n}\n\nexport function isMultiSigFormatVersion(version: string | undefined): boolean {\n    return version !== undefined;\n}\n\n/// Check if the version is enable versioned handshake message.\nexport function isVersionedHandshakeVersion(version: string | undefined): boolean {\n    return version !== undefined;\n}","import {Connector} from \"./connector\";\nimport {JsonRPCServer} from \"./JsonRPCServer\";\nimport {Account, adaptLegacyAccount, WalletAPI, WalletEvent} from \"./WalletAPI\";\nimport {isMultiSigFormatVersion} from \"./version\";\nimport {toLegacyAccount} from \"./utils\";\n\nexport class MSafeServer {\n\n  public server: JsonRPCServer;\n\n  constructor(connector: Connector, methods: WalletAPI) {\n    if (isMultiSigFormatVersion(connector.version.peer)) {\n      this.server = new JsonRPCServer(connector, methods as any);\n    } else {\n      // backward compatibility\n      const legacyWalletAPI = adaptLegacyAccount(methods);\n      this.server = new JsonRPCServer(connector, legacyWalletAPI as any);\n    }\n  }\n\n  changeNetwork(network: string) {\n        this.server.notify(WalletEvent.ChangeNetwork, [network]);\n  }\n\n  changeAccount(account: Account) {\n    const peerVersion = this.version.peer;\n    if (isMultiSigFormatVersion(peerVersion)) {\n      this.server.notify(WalletEvent.ChangeAccount, [account]);\n    } else {\n      const legacyAccount = toLegacyAccount(account);\n      this.server.notify(WalletEvent.ChangeAccount, [legacyAccount]);\n    }\n  }\n\n  get version() {\n    return this.server.version;\n  }\n}\n\n\n","import { isSessionIDVersion, isVersionedHandshakeVersion } from \"./version\";\n\nexport class HandshakeMessage {\n    static HANDSHAKE_REQ = 'HANDSHAKE_REQ';\n    static HANDSHAKE_ACK = 'HANDSHAKE_ACK';\n    static HANDSHAKE_PORT_ACK = 'HANDSHAKE_PORT_REQ';\n    handshakeType: string;\n    version: string | undefined;\n    sessionID: number | undefined;\n    constructor(handshakeType: string, version?: string, sessionID?: number) {\n        this.handshakeType = handshakeType;\n        if (version !== undefined) this.version = version;\n        if (sessionID !== undefined) this.sessionID = sessionID;\n    }\n\n    // When responding to a lower-version client, a lower-version message is required.\n    toString(messageVersion:string | undefined): string {\n        if (isSessionIDVersion(messageVersion)) {\n            if (this.sessionID === undefined) throw Error('sessionID is undefined');\n            return `${this.handshakeType}:${this.version}:${this.sessionID}`;\n        }\n        if (isVersionedHandshakeVersion(messageVersion)) return `${this.handshakeType}:${this.version}`;\n        return this.handshakeType;\n    }\n\n    isHandshakeMessage(handshakeType: string): boolean {\n        if(this.handshakeType !== handshakeType) return false;\n        if (isSessionIDVersion(this.version) && this.sessionID === undefined) return false;\n        return true;\n    }\n\n    static fromString(message: string): HandshakeMessage {\n        const [handshakeType, version, sessionID] = message.split(':');\n        return new HandshakeMessage(handshakeType, version, Number(sessionID));\n    }\n\n}\n","import { version } from '../package.json';\nimport { HandshakeMessage } from './HandshakeMessage';\nimport { isAllowList, isSessionIDVersion } from './version';\n\nexport class Connector {\n    static version = version;\n    static sessionID = 0;\n    connected = true;\n    onClose?: () => void;\n    onMessage?: (data: any) => void;\n    constructor(public readonly port: MessagePort, public readonly peerVersion: string | undefined, public readonly sessionID: number | undefined) {\n        this.port.onmessage = (ev) => {\n            this.onMessage && this.onMessage(ev.data);\n        };\n        this.port.onmessageerror = () => {\n            this.close();\n        };\n    }\n\n    send(data: any) {\n        this.port.postMessage(data);\n    }\n\n    on(type: 'close' | 'message', handle: (data?: string) => void) {\n        switch (type) {\n            case 'close':\n                this.onClose = handle;\n                break;\n            case 'message':\n                this.onMessage = handle;\n                break;\n            default:\n                throw Error(\"invlaid type\");\n        }\n    }\n\n    get version() {\n        return {\n            self: Connector.version,\n            peer: this.peerVersion,\n        }\n    }\n\n    close() {\n        if (this.connected) {\n            this.port.close();\n            this.connected = false;\n            this.onClose && this.onClose();\n        }\n    }\n\n    static newSessionID() {\n        return Connector.sessionID++;\n    }\n\n    // client connect to server\n    static async connect(targetWindow: any, origins: string[]): Promise<Connector> {\n        return new Promise((resolve, rejected) => {\n            const sessionID = Connector.newSessionID();\n            let cleaner = () => { };\n            let timer = setTimeout(() => {\n                cleaner();\n                rejected(`connect timeout: ${sessionID}`);\n            }, 1000);\n            const handle = (ev: MessageEvent) => {\n                const port = ev.ports[0];\n                if (!origins.includes(ev.origin)) return;\n                if (typeof ev.data !== 'string') return;\n                const handshakeMessage = HandshakeMessage.fromString(ev.data);\n                if (!handshakeMessage.isHandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK)) return;\n                if (handshakeMessage.sessionID !== sessionID) return;\n                cleaner();\n                resolve(new Connector(port, handshakeMessage.version, sessionID));\n            };\n            cleaner = () => {\n                clearTimeout(timer);\n                window.removeEventListener('message', handle);\n            };\n            window.addEventListener('message', handle);\n            const handshakeMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_REQ, Connector.version, sessionID);\n            targetWindow.postMessage(handshakeMessage.toString(handshakeMessage.version), '*');\n        });\n    }\n    // server listening connection request\n    static accepts(origin: string, handler: (connector: Connector) => void): () => void {\n        origin = new URL(origin).origin;\n        const handle = (ev: MessageEvent) => {\n            if (ev.origin !== origin) return;\n            if (typeof ev.data !== 'string') return;\n            const handshakeMessage = HandshakeMessage.fromString(ev.data);\n            if (!handshakeMessage.isHandshakeMessage(HandshakeMessage.HANDSHAKE_REQ)) return;\n\n            const peerVersion = handshakeMessage.version;\n            const thisVersion = Connector.version;\n            if (isSessionIDVersion(peerVersion)) {\n                const channelPair = new MessageChannel();\n                const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK, thisVersion, handshakeMessage.sessionID);\n                (ev.source as Window).postMessage(replyMessage.toString(peerVersion), ev.origin, [channelPair.port2]);\n                handler(new Connector(channelPair.port1, peerVersion, handshakeMessage.sessionID));\n            } else if (isAllowList(peerVersion)) {\n                const channelPair = new MessageChannel();\n                const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK, thisVersion);\n                (ev.source as Window).postMessage(replyMessage.toString(peerVersion), ev.origin, [channelPair.port2]);\n                handler(new Connector(channelPair.port1, peerVersion, undefined));\n            } else {\n                const port = ev.ports[0];\n                const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_ACK, thisVersion);\n                port.postMessage(replyMessage.toString(peerVersion));\n                handler(new Connector(ev.ports[0], peerVersion, undefined));\n            }\n        };\n        window.addEventListener('message', handle);\n        return () => window.removeEventListener('message', handle);\n    }\n\n    static async accept(origin: string): Promise<Connector> {\n        return new Promise((resolve) => {\n            const cleaner = this.accepts(origin, (connector) => {\n                resolve(connector);\n                cleaner();\n            });\n        });\n    }\n}","import { Connector } from \"./connector\";\nimport { JsonRpcParamsSchemaByPositional, parse, format, JsonRpcPayloadResponse, JsonRpcPayloadNotification, JsonRpcPayloadError } from 'json-rpc-protocol'\nimport { encodeToStr, decodeFromStr } from \"./coder\";\n\ntype executorFunc = (data: any) => void;\ntype executor = { resolve: executorFunc, reject: executorFunc };\ntype notifier = (...params: any[]) => void;\n\nexport class JsonRPCClient {\n    id: number = 0;\n    executors: { [id: number]: executor } = {};\n    constructor(public readonly connector: Connector, readonly notifiers: { [type: string]: notifier }) {\n        this.connector.on('message', data => this.onMessage(data!));\n        this.connector.on('close', () => this.onClose());\n    }\n    private onMessage(data: string) {\n        const mesg = parse(data) as JsonRpcPayloadResponse | JsonRpcPayloadNotification | JsonRpcPayloadError;\n        switch (mesg.type) {\n            case 'notification':\n                return this.onNotify(mesg.method, (mesg.params as JsonRpcParamsSchemaByPositional).map(decodeFromStr));\n            case 'response':\n                const { resolve } = this.executors[Number(mesg.id)];\n                delete this.executors[Number(mesg.id)];\n                return resolve(decodeFromStr(mesg.result));\n            case 'error':\n                const { reject } = this.executors[Number(mesg.id)];\n                delete this.executors[Number(mesg.id)];\n                return reject(mesg.error.message);\n        }\n\n    }\n    async request(method: string, params: any[] = []): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const reqId = this.id++;\n            this.executors[reqId] = { resolve, reject };\n            const req = format.request(reqId, method, params.map(encodeToStr));\n            this.connector.send(req);\n        });\n    }\n    get version() {\n        return this.connector.version;\n    }\n    private onNotify(type: string, data: any[]) {\n        this.notifiers[type](...data);\n    }\n    private onClose() {\n\n    }\n}","import { Connector } from \"./connector\";\nimport { JsonRPCClient } from \"./JsonRPCClient\";\nimport { Account, WalletAPI, Option, Payload, WalletEvent, WalletRPC } from \"./WalletAPI\";\ntype onEventFunc = (data: any) => void\n\n/// MSafe website urls, it acts as the default allowlist.\nconst MSafeOrigins = {\n    mainnet: 'https://app.m-safe.io',\n    testnet: 'https://testnet.m-safe.io',\n    partner: 'https://partner.m-safe.io',\n};\n/// Default list of MSafe endpoint URLs.\nconst DefaultMSafeEndpoints = Object.values(MSafeOrigins);\n\n/// NetworkType or MSafe website url as string.\ntype MSafeNetwork = NetworkType | string;\n/// MSafeNetwork or array of MSafeNetwork.\ntype MSafeNetworks = MSafeNetwork | MSafeNetwork[];\n/// Network type of MSafe websites.\n/// It can be 'Mainnet', 'Testnet' or 'Partner'.\ntype NetworkType = keyof typeof MSafeOrigins;\n\nexport class MSafeWallet implements WalletAPI {\n\n    public client: JsonRPCClient;\n\n    events: { [key: string]: onEventFunc } = {};\n\n    constructor(connector: Connector) {\n        const onEvent = (type: string, ...params: any[]) => {\n            const cbk = this.events[type];\n            cbk && cbk(params[0]);\n        };\n        const entries = [\n            WalletEvent.ChangeAccount,\n            WalletEvent.ChangeNetwork\n        ].map(event => [event, (...params: any[]) => onEvent(event, ...params)]);\n        const notifiers = Object.fromEntries(entries);\n        this.client = new JsonRPCClient(connector, notifiers);\n    }\n\n    async connect(): Promise<Account> {\n        return this.client.request(WalletRPC.connect);\n    }\n\n    async isConnected(): Promise<boolean> {\n        return this.client.request(WalletRPC.isConnected);\n    }\n\n    async disconnect() {\n        return this.client.request(WalletRPC.disconnect);\n    }\n\n    onChangeAccount(cbk: (account: Account) => void) {\n        this.events[WalletEvent.ChangeAccount] = cbk;\n    }\n\n    onChangeNetwork(cbk: (network: string) => void) {\n        this.events[WalletEvent.ChangeNetwork] = cbk;\n    }\n\n    async network(): Promise<string> {\n        return this.client.request(WalletRPC.network);\n    }\n\n    async account(): Promise<Account> {\n        return this.client.request(WalletRPC.account);\n    }\n\n    async chainId(): Promise<Number> {\n        return this.client.request(WalletRPC.chainId);\n    }\n\n    async signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array> {\n        return this.client.request(WalletRPC.signAndSubmit, [payload, option]);\n    }\n\n    async signTransaction(payload: Payload, option?: Option): Promise<Uint8Array> {\n        return this.client.request(WalletRPC.signTransaction, [payload, option]);\n    }\n\n    async signMessage(message: string | Uint8Array): Promise<Uint8Array> {\n        return this.client.request(WalletRPC.signMessage, [message]);\n    }\n\n    get version() {\n        return this.client.version;\n    }\n\n    /**\n     * @description check if current page is running under MSafe wallet\n     */\n    static inMSafeWallet(): boolean {\n        return typeof window !== 'undefined' &&\n            typeof document !== 'undefined' &&\n            typeof parent !== 'undefined' &&\n            typeof parent.window !== 'undefined' &&\n            parent.window !== window\n    }\n    /**\n     * @deprecated use inMSafeWallet instead \n     */\n    static inMsafeWallet(): boolean {\n        return MSafeWallet.inMSafeWallet();\n    }\n\n    /** \n     * @description Get msafe dapp url, which can be used to open dapp under msafe wallet.\n     * @param msafe network type or msafe website url\n     * @param dappUrl dapp url\n     */\n    static getAppUrl(msafe: MSafeNetwork = 'mainnet', dappUrl = `${window.location.href}`): string {\n        const msafeOrigin = MSafeWallet.getOrigin(msafe);\n        return `${msafeOrigin}/aptos/v2/store/0?url=${encodeURIComponent(dappUrl)}`;\n    }\n\n    /**\n     * @description Get msafe origin by network type or url\n     * @param msafeNetwork type or msafe website url\n     * @returns msafe origin\n     */\n    static getOrigin(msafeNetwork: MSafeNetwork = 'mainnet'): string {\n        const endpoint = MSafeOrigins[msafeNetwork.toLowerCase() as NetworkType] || msafeNetwork;\n        return new URL(endpoint).origin;\n    }\n\n    /**\n     * @description Open msafe wallet and establish communication with the msafe website.\n     *              The allowlist is used to check if the msafe website is trusted.\n     * @param allowlist allowlist of msafe website url, omit means accpets all msafe websites. you can pass a single url or an array of urls.\n     * @returns MSafeWallet instance\n     * @example\n     *  // 1. Initialize MSafeWallet with default allowlist:\n     *      const wallet = await MSafeWallet.new();\n     *  // 2. Initialize MSafeWallet with a single MSafe url:\n     *      const wallet = await MSafeWallet.new('https://app.m-safe.io');\n     *  // 3. Initialize MSafeWallet with an array of MSafe urls:\n     *      const wallet = await MSafeWallet.new(['https://app.m-safe.io', 'https://testnet.m-safe.io', 'https://partner.m-safe.io']);\n     *  // 4. Initialize MSafeWallet with a single network type:\n     *      const wallet = await MSafeWallet.new('Mainnet');\n     *  // 5. Initialize MSafeWallet with an array of network types:\n     *      const wallet = await MSafeWallet.new(['Mainnet', 'Testnet', 'Partner']);\n     */\n    static async new(allowlist: MSafeNetworks = DefaultMSafeEndpoints): Promise<MSafeWallet> {\n        const msafeOrigin = allowlist instanceof Array ? allowlist.map(m=>MSafeWallet.getOrigin(m)) : [MSafeWallet.getOrigin(allowlist)];\n        const connector = await Connector.connect(window.parent, msafeOrigin);\n        return new MSafeWallet(connector);\n    }\n}\n\n/**\n * @deprecated use MSafeWallet instead, it will be removed in the future.\n */\nexport class MsafeWallet extends MSafeWallet{}\n"],"mappings":"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","names":["WalletEvent","WalletRPC","parse","version","version","handshakeMessage","import_json_rpc_protocol"]}