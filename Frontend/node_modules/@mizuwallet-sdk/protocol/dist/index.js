var W = Object.defineProperty;
var I = (e, n, t) => n in e ? W(e, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[n] = t;
var p = (e, n, t) => I(e, typeof n != "symbol" ? n + "" : n, t);
import v from "tweetnacl-util";
import w from "tweetnacl";
async function A(e, n) {
  const t = e.getReader();
  let o;
  for (; !(o = await t.read()).done; )
    n(o.value);
}
function F(e) {
  let n, t, o, r = !1;
  return function(i) {
    n === void 0 ? (n = i, t = 0, o = -1) : n = q(n, i);
    const a = n.length;
    let c = 0;
    for (; t < a; ) {
      r && (n[t] === 10 && (c = ++t), r = !1);
      let l = -1;
      for (; t < a && l === -1; ++t)
        switch (n[t]) {
          case 58:
            o === -1 && (o = t - c);
            break;
          case 13:
            r = !0;
          case 10:
            l = t;
            break;
        }
      if (l === -1)
        break;
      e(n.subarray(c, l), o), c = t, o = -1;
    }
    c === a ? n = void 0 : c !== 0 && (n = n.subarray(c), t -= c);
  };
}
function B(e, n, t) {
  let o = j();
  const r = new TextDecoder();
  return function(i, a) {
    if (i.length === 0)
      t == null || t(o), o = j();
    else if (a > 0) {
      const c = r.decode(i.subarray(0, a)), l = a + (i[a + 1] === 32 ? 2 : 1), d = r.decode(i.subarray(l));
      switch (c) {
        case "data":
          o.data = o.data ? o.data + `
` + d : d;
          break;
        case "event":
          o.event = d;
          break;
        case "id":
          e(o.id = d);
          break;
        case "retry":
          const u = parseInt(d, 10);
          isNaN(u) || n(o.retry = u);
          break;
      }
    }
  };
}
function q(e, n) {
  const t = new Uint8Array(e.length + n.length);
  return t.set(e), t.set(n, e.length), t;
}
function j() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var Z = function(e, n) {
  var t = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && n.indexOf(o) < 0 && (t[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      n.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (t[o[r]] = e[o[r]]);
  return t;
};
const P = "text/event-stream", z = 1e3, D = "last-event-id";
function U(e, n) {
  var { signal: t, headers: o, onopen: r, onmessage: s, onclose: i, onerror: a, openWhenHidden: c, fetch: l } = n, d = Z(n, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((u, f) => {
    const b = Object.assign({}, o);
    b.accept || (b.accept = P);
    let m;
    function x() {
      m.abort(), document.hidden || T();
    }
    c || document.addEventListener("visibilitychange", x);
    let H = z, $ = 0;
    function k() {
      document.removeEventListener("visibilitychange", x), window.clearTimeout($), m.abort();
    }
    t == null || t.addEventListener("abort", () => {
      k(), u();
    });
    const J = l ?? window.fetch, N = r ?? V;
    async function T() {
      var L;
      m = new AbortController();
      try {
        const C = await J(e, Object.assign(Object.assign({}, d), { headers: b, signal: m.signal }));
        await N(C), await A(C.body, F(B((y) => {
          y ? b[D] = y : delete b[D];
        }, (y) => {
          H = y;
        }, s))), i == null || i(), k(), u();
      } catch (C) {
        if (!m.signal.aborted)
          try {
            const y = (L = a == null ? void 0 : a(C)) !== null && L !== void 0 ? L : H;
            window.clearTimeout($), $ = window.setTimeout(T, y);
          } catch (y) {
            k(), f(y);
          }
      }
    }
    T();
  });
}
function V(e) {
  const n = e.headers.get("content-type");
  if (!(n != null && n.startsWith(P)))
    throw new Error(`Expected content-type to be ${P}, Actual: ${n}`);
}
function Q(e, n) {
  const t = v.encodeBase64(e);
  return n ? encodeURIComponent(t) : t;
}
function X(e, n) {
  return n && (e = decodeURIComponent(e)), v.decodeBase64(e);
}
function Y(e, n = !1) {
  let t;
  return e instanceof Uint8Array ? t = e : (typeof e != "string" && (e = JSON.stringify(e)), t = v.decodeUTF8(e)), Q(t, n);
}
function M(e, n = !1) {
  const t = X(e, n);
  return {
    toString() {
      return v.encodeUTF8(t);
    },
    toObject() {
      try {
        return JSON.parse(v.encodeUTF8(t));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return t;
    }
  };
}
const re = {
  encode: Y,
  decode: M
};
function E(e, n) {
  const t = new Uint8Array(e.length + n.length);
  return t.set(e), t.set(n, e.length), t;
}
function G(e, n) {
  if (n >= e.length)
    throw new Error("Index is out of buffer");
  const t = e.slice(0, n), o = e.slice(n);
  return [t, o];
}
function h(e) {
  let n = "";
  return e.forEach((t) => {
    n += ("0" + (t & 255).toString(16)).slice(-2);
  }), n;
}
function g(e) {
  if (e.length % 2 !== 0)
    throw new Error(`Cannot convert ${e} to bytesArray`);
  const n = new Uint8Array(e.length / 2);
  for (let t = 0; t < e.length; t += 2)
    n[t / 2] = parseInt(e.slice(t, t + 2), 16);
  return n;
}
function se() {
  var e;
  return !!((e = process == null ? void 0 : process.versions) != null && e.node);
}
class O {
  constructor(n) {
    p(this, "nonceLength", 24);
    p(this, "keyPair");
    p(this, "sessionId");
    this.keyPair = n ? this.createKeypairFromString(n) : this.createKeypair(), this.sessionId = h(this.keyPair.publicKey);
  }
  createKeypair() {
    return w.box.keyPair();
  }
  createKeypairFromString(n) {
    return {
      publicKey: g(n.publicKey),
      secretKey: g(n.secretKey)
    };
  }
  createNonce() {
    return w.randomBytes(this.nonceLength);
  }
  encrypt(n, t) {
    const o = new TextEncoder().encode(n), r = this.createNonce(), s = w.box(o, r, t, this.keyPair.secretKey);
    return E(r, s);
  }
  decrypt(n, t) {
    const [o, r] = G(n, this.nonceLength), s = w.box.open(
      r,
      o,
      t,
      this.keyPair.secretKey
    );
    if (!s)
      throw new Error(
        `Decryption error: 
 message: ${n.toString()} 
 sender pubkey: ${t.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`
      );
    return new TextDecoder().decode(s);
  }
  stringifyKeypair() {
    return {
      publicKey: h(this.keyPair.publicKey),
      secretKey: h(this.keyPair.secretKey)
    };
  }
  static async generateKeyPairByString(n) {
    const o = new TextEncoder().encode(n), r = await crypto.subtle.digest("SHA-256", o), s = new Uint8Array(r), i = w.box.keyPair.fromSecretKey(s.slice(0, 32));
    return {
      publicKey: h(i.publicKey),
      secretKey: h(i.secretKey)
    };
  }
  static isSameKeypair(n, t) {
    return !n || !t ? !1 : n.publicKey === t.publicKey && n.secretKey === t.secretKey;
  }
}
const R = "https://bridge.mz.xyz", K = {
  CONNECT: "[MizuWallet SSE Connect]"
};
var S = /* @__PURE__ */ ((e) => (e[e.SUCCESS = 0] = "SUCCESS", e[e.ERROR = 1] = "ERROR", e))(S || {}), _ = /* @__PURE__ */ ((e) => (e[e.MIZU = 0] = "MIZU", e[e.MIZU_PC = 1] = "MIZU_PC", e[e.THIRD_PARTY = 2] = "THIRD_PARTY", e))(_ || {}), ee = /* @__PURE__ */ ((e) => (e[e.START = 0] = "START", e[e.DATA = 1] = "DATA", e[e.FULFILLED = 2] = "FULFILLED", e[e.REJECT = 3] = "REJECT", e[e.CANCEL = 4] = "CANCEL", e[e.CLOSE = 5] = "CLOSE", e))(ee || {});
const ce = async (e) => {
  const n = new URLSearchParams(), t = new O(e.keypair), o = new AbortController();
  n.append("client_id", t.sessionId.toString()), n.append("to", e.to.toString()), n.append("ttl", e.ttl.toString());
  const r = JSON.stringify(e.content), s = g(e.to.toString()), i = t.encrypt(r, s), a = h(i);
  return await U(`${R}/bridge/message?${n.toString()}`, {
    method: "POST",
    openWhenHidden: !1,
    headers: {
      Accept: "text/event-stream"
    },
    onopen(c) {
      var l, d, u, f;
      return c.ok && c.status === 200 ? ((l = console.group) == null || l.call(console, "[SessionPost]"), console.log(`The connection from ${t.sessionId} to ${e.to}`), (d = console.groupEnd) == null || d.call(console), Promise.resolve()) : ((u = console.group) == null || u.call(console, "[SessionPost]"), console.log(`The connection from ${t.sessionId} to ${e.to}`), console.log("Client side error ", c), (f = console.groupEnd) == null || f.call(console), Promise.reject());
    },
    onmessage() {
    },
    onclose() {
      var c, l;
      (c = console.group) == null || c.call(console, "[SessionPost]"), console.log(`The connection from ${t.sessionId} to ${e.to} is closed by the server`), (l = console.groupEnd) == null || l.call(console), console.log("abort"), o == null || o.abort();
    },
    onerror(c) {
      var l, d;
      (l = console.group) == null || l.call(console, "[SessionPost]"), console.log(`The connection from ${t.sessionId} to ${e.to}`), console.log("There was an error from server", c.message || c), (d = console.groupEnd) == null || d.call(console), o == null || o.abort();
    },
    body: a,
    signal: o.signal
  }), {
    ctrl: o
  };
}, ie = async (e) => {
  const n = new URLSearchParams();
  return n.append("client_id", e.keypair.publicKey.toString()), new Promise(async (t, o) => {
    await U(`${R}/bridge/events?${n.toString()}`, {
      openWhenHidden: !1,
      onopen(r) {
        return r.status === 200 ? (console.info(`${K.CONNECT} Opened`), Promise.resolve()) : (console.error(`${K.CONNECT} Failed to open`), Promise.reject());
      },
      onmessage(r) {
        try {
          if (r.data && r.data.startsWith("{")) {
            const s = JSON.parse(r.data);
            if (s.message) {
              const i = new O({
                ...e.keypair
              }), a = s.message, c = g(a), l = i.decrypt(
                c,
                g(s.from.toString())
              ), d = JSON.parse(l);
              t(d);
            }
          }
        } catch (s) {
          console.error(s), o(s);
        }
      }
    });
  });
}, ae = async (e) => {
  const n = new URLSearchParams(), t = e.keypair.publicKey.toString();
  n.append("client_id", t);
  const o = new AbortController();
  return U(`${R}/bridge/events?${n.toString()}`, {
    openWhenHidden: !1,
    onopen(r) {
      return r.status === 200 ? (console.info(`${K.CONNECT} Opened`), Promise.resolve()) : (console.error(`${K.CONNECT} Failed to open`), Promise.reject());
    },
    onmessage(r) {
      var s, i;
      try {
        if (r.data && r.data.startsWith("{")) {
          const a = JSON.parse(r.data);
          if (a.message) {
            const c = new O({
              ...e.keypair
            }), l = a.message, d = g(l), u = c.decrypt(
              d,
              g(a.from.toString())
            ), f = JSON.parse(u);
            (e.nonce && f.nonce == e.nonce || !e.nonce) && ((s = e.callback) == null || s.call(e, {
              status: 0,
              message: f
            }));
          }
        }
      } catch (a) {
        console.error(a), (i = e.callback) == null || i.call(e, {
          status: 1,
          error: a
        });
      }
    },
    onclose() {
      var r, s;
      (r = console.group) == null || r.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${t}`), console.log("Close abort"), (s = console.groupEnd) == null || s.call(console), o == null || o.abort();
    },
    onerror(r) {
      var s, i;
      (s = console.group) == null || s.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${t}`), console.log("There was an error from server", r.message || r), console.log("Error abort"), (i = console.groupEnd) == null || i.call(console), o == null || o.abort();
    },
    signal: o.signal
  }), {
    ctrl: o
  };
};
class le {
  constructor(n) {
    p(this, "from", "");
    p(this, "nonce", "");
    p(this, "body");
    p(this, "type", "");
    Object.assign(this, n), this.body = n.body;
  }
}
export {
  re as Base64,
  S as CALLBACK_MESSAGE_STATUS,
  _ as SESSION_MESSAGE_FROM,
  ee as SESSION_MESSAGE_TYPE,
  O as SessionCrypto,
  ie as SessionListener,
  ae as SessionListenerLong,
  le as SessionMessage,
  ce as SessionPost,
  E as concatUint8Arrays,
  g as hexToByteArray,
  se as isNode,
  G as splitToUint8Arrays,
  h as toHexString
};
