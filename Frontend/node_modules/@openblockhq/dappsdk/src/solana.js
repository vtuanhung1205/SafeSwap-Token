import base58 from 'bs58';
import {
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
} from '@wallet-standard/features';
import {
  SolanaSignAndSendTransaction,
  SolanaSignMessage,
  SolanaSignTransaction,
} from '@solana/wallet-standard-features';
import { VersionedTransaction, PublicKey } from '@solana/web3.js';
import { hex2UInt8, uint82Hex, base642UInt8 } from './helper/utils';

const SOLANA_MAINNET_CHAIN = 'solana:mainnet';
const SOLANA_DEVNET_CHAIN = 'solana:devnet';
const SOLANA_TESTNET_CHAIN = 'solana:testnet';
const SOLANA_LOCALNET_CHAIN = 'solana:localnet';

const SOLANA_CHAINS = [
  SOLANA_MAINNET_CHAIN,
  SOLANA_DEVNET_CHAIN,
  SOLANA_TESTNET_CHAIN,
  SOLANA_LOCALNET_CHAIN,
];

const bytesEqual = (a, b) => {
  if (a === b) return true;

  const length = a.length;
  if (length !== b.length) return false;

  for (let i = 0; i < length; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};

const isSolanaChain = (chain) => {
  return SOLANA_CHAINS.includes(chain);
};

class WalletAccount {
  constructor({ address, publicKey, label, icon }) {
    this._address = address;
    this._publicKey = publicKey;
    this._chains = SOLANA_CHAINS;
    this._features = [
      SolanaSignAndSendTransaction,
      SolanaSignTransaction,
      SolanaSignMessage,
    ];
    this._label = label;
    this._icon = icon;
  }

  get address() {
    return this._address;
  }

  get publicKey() {
    return this._publicKey;
  }

  get chains() {
    return this._chains;
  }

  get features() {
    return this._features;
  }

  get label() {
    return this._label;
  }

  get icon() {
    return this._icon;
  }
}

class SolanaInpageProvider {
  constructor(walletRef) {
    this.walletRef = walletRef;
    this.walletProvider = 'solana';

    this.callBackList = {};
    this.eventListener = {};

    this._listeners = {};
    this._account = null;

    this._connect = this._connect.bind(this);
    this._disconnect = this._disconnect.bind(this);
    this._connected = this._connected.bind(this);
    this._disconnected = this._disconnected.bind(this);
    this._reconnected = this._reconnected.bind(this);
    this._on = this._on.bind(this);
    this._off = this._off.bind(this);
    this._signAndSendTransaction = this._signAndSendTransaction.bind(this);
    this._signTransaction = this._signTransaction.bind(this);
    this._signMessage = this._signMessage.bind(this);

    this.isPhantom = true;
    this.publicKey = null;
    this.on = this._on;
    this.off = this._off;
    this.connect = this.connect.bind(this);
    this.disconnect = this.disconnect.bind(this);
    this.signAndSendTransaction = this.signAndSendTransaction.bind(this);
    this.signTransaction = this.signTransaction.bind(this);
    this.signAllTransactions = this.signAllTransactions.bind(this);
    this.signMessage = this.signMessage.bind(this);
  }

  get features() {
    return {
      [StandardConnect]: {
        version: '1.0.0',
        connect: this._connect,
      },
      [StandardDisconnect]: {
        version: '1.0.0',
        disconnect: this._disconnect,
      },
      [StandardEvents]: {
        version: '1.0.0',
        on: this._on,
      },
      [SolanaSignAndSendTransaction]: {
        version: '1.0.0',
        supportedTransactionVersions: ['legacy', 0],
        signAndSendTransaction: this._signAndSendTransaction,
      },
      [SolanaSignTransaction]: {
        version: '1.0.0',
        supportedTransactionVersions: ['legacy', 0],
        signTransaction: this._signTransaction,
      },
      [SolanaSignMessage]: {
        version: '1.0.0',
        signMessage: this._signMessage,
      },
    };
  }

  get accounts() {
    return this._account ? [this._account] : [];
  }

  _on(event, listener) {
    console.log('solanaProvider::_on, event:', event, ', listener:', listener);
    this._listeners[event]?.push(listener) ||
      (this._listeners[event] = [listener]);
    return () => this._off(event, listener);
  }

  _emit(event, ...args) {
    console.log('solanaProvider::_emit, event:', event, ', args:', args);
    this._listeners[event]?.forEach((listener) => listener(...args));
  }

  _off(event, listener) {
    console.log('solanaProvider::_off, event:', event, ', listener:', listener);
    this._listeners[event] = this._listeners[event]?.filter(
      (l) => l !== listener,
    );
  }

  async _connected() {
    console.log('solanaProvider::_connected');
    const accounts = await this._hookRequest('solana_accounts');
    if (accounts?.address) {
      const { address, publicKey } = accounts;
      const bytesPublicKey = hex2UInt8(publicKey);
      const account = this._account;
      if (
        !account ||
        account.address !== address ||
        !bytesEqual(bytesPublicKey, account.publicKey)
      ) {
        this.publicKey = new PublicKey(bytesPublicKey);
        this._account = new WalletAccount({
          address,
          publicKey: bytesPublicKey,
        });
        this._emit('change', { accounts: this.accounts });
        this._emit('connect', this.publicKey);
      }
    }
  }

  _disconnected() {
    console.log('solanaProvider::_disconnected');
    if (this._account) {
      this._account = null;
      this.publicKey = null;
      this._emit('change', { accounts: this.accounts });
      this._emit('disconnect');
    }
  }

  _reconnected() {
    console.log('solanaProvider::_reconnected');
    if (this._hookRequest('solana_accounts')) {
      this._connected();
    } else {
      this._disconnected();
    }
  }

  async _connect() {
    console.log('solanaProvider::_connect');
    await this._connected();
    if (!this._account) {
      await this._hookRequest('solana_requestAccounts');
      await this._connected();
    }

    return { accounts: this.accounts };
  }

  async _disconnect() {
    console.log('solanaProvider::_disconnect');
    this._disconnected();
  }

  async _signAndSendTransaction(...inputs) {
    console.log('solanaProvider::_signAndSendTransaction, inputs:', inputs);
    if (!this._account) {
      throw new Error('not connected');
    }

    const result = await this._hookRequest({
      method: 'solana_signAndSendTransaction',
      params: {
        transactions: inputs.map(({ transaction }) =>
          uint82Hex(transaction.serialize({ verifySignatures: false })),
        ),
      },
    });

    if (typeof result !== 'object' || !Array.isArray(result)) {
      throw new Error(
        `faild to signAndSendTransaction, error: ${JSON.stringify(result)}`,
      );
    }

    return result.map((i) => ({ signature: base58.decode(i) }));
  }

  async _signTransaction(...inputs) {
    if (!this._account) {
      throw new Error('not connected');
    }
    for (const input of inputs) {
      if (input.account !== this._account) {
        throw new Error('invalid account');
      }
      if (input.chain) {
        if (!isSolanaChain(input.chain)) {
          throw new Error('invalid chain');
        }
      }
    }

    return (
      await this.signAllTransactions(
        inputs.map((i) => VersionedTransaction.deserialize(i.transaction)),
      )
    ).map((signed) => {
      return {
        signedTransaction: signed.serialize(),
      };
    });
  }

  async _signMessage(...inputs) {
    console.log('solanaProvider::_signMessage, messages:', inputs);
    if (!this._account) {
      throw new Error('not connected');
    }
    for (const input of inputs) {
      if (input.account !== this._account) {
        throw new Error('invalid account');
      }
    }

    const outputs = [];
    for (const input of inputs) {
      const { signature } = await this.signMessage(input.message);
      outputs.push({ signedMessage: input.message, signature });
    }

    return outputs;
  }

  async connect() {
    console.log('solanaProvider::connect');
    await this._connect();
    return { publicKey: this.publicKey };
  }

  async disconnect() {
    console.log('solanaProvider::disconnect');
    this._disconnect();
  }

  async signAndSendTransaction(transaction) {
    console.log(
      'solanaProvider::signAndSendTransaction, transaction:',
      transaction,
    );
    const result = await this._signAndSendTransaction({ transaction });

    return {
      signature: base58.encode(result[0].signature),
    };
  }

  async signTransaction(transaction) {
    console.log('solanaProvider::signTransaction, transaction:', transaction);
    const result = await this.signAllTransactions([transaction]);
    return result[0];
  }

  async signAllTransactions(transactions) {
    console.log(
      'solanaProvider::signAllTransactions, transactions:',
      transactions,
    );
    const serialized = transactions.map((i) =>
      i.serialize({ verifySignatures: false }),
    );
    const signedArray = await this._hookRequest({
      method: 'solana_signTransaction',
      params: {
        transactions: serialized.map((t) => uint82Hex(t)),
      },
    });

    if (typeof signedArray !== 'object' || !Array.isArray(signedArray)) {
      throw new Error(
        `faild to signAndSendTransaction, error: ${JSON.stringify(
          signedArray,
        )}`,
      );
    }

    const outputs = [];
    for (let i = 0; i < serialized.length; i++) {
      const signed = VersionedTransaction.deserialize(base58.decode(signedArray[i]));
      const original = VersionedTransaction.deserialize(serialized[i]);
      for (let j = 0; j < signed.signatures.length; j++) {
        if (Array.from(signed.signatures[j]).every((x) => x === 0)) {
          signed.signatures[j] = original.signatures[j];
        }
      }
      outputs.push(signed);
    }
    return outputs;
  }

  async signMessage(message) {
    console.log('solanaProvider::signMessage, message:', message);
    const signed = await this._hookRequest({
      method: 'solana_signMessage',
      params: {
        message: uint82Hex(message),
      },
    });
    if (typeof signed !== 'string') {
      throw new Error(JSON.stringify(signed));
    }
    return { signature: hex2UInt8(signed.replace(/^0x/, '')) };
  }

  _hookRequest(paramsObj) {
    if (typeof paramsObj === 'string') {
      // eslint-disable-next-line no-param-reassign
      paramsObj = {
        method: paramsObj,
      };
    }
    // eslint-disable-next-line no-param-reassign
    paramsObj = {
      ...paramsObj,
      provider: this.walletProvider,
    };
    return this.walletRef.hookRequest(paramsObj);
  }
}

window.solanaDebugDeserializeTx = (str, encoding = 'base64') => {
  let buffer;
  switch (encoding) {
    case 'base64':
      buffer = base642UInt8(str);
      break;
    case 'base58':
      buffer = base58.decode(str);
      break;
    default:
      throw new Error('unsupported type');
  }
  console.log(VersionedTransaction.deserialize(buffer));
};

export default SolanaInpageProvider;
