export class TonConnectError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}

const tonRejectedError = new TonConnectError('Reject request', 1002);

function getPlatform() {
  const platform =
    window.navigator?.userAgentData?.platform || window.navigator.platform;

  const userAgent = window.navigator.userAgent;

  const macosPlatforms = ['macOS', 'Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
  const windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
  const iphonePlatforms = ['iPhone'];
  const iosPlatforms = ['iPad', 'iPod'];

  let os = null;

  if (macosPlatforms.indexOf(platform) !== -1) {
    os = 'mac';
  } else if (iphonePlatforms.indexOf(platform) !== -1) {
    os = 'iphone';
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    os = 'ipad';
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    os = 'windows';
  } else if (/Android/.test(userAgent)) {
    os = 'linux';
  } else if (/Linux/.test(platform)) {
    os = 'linux';
  }

  return os;
}

export const getDeviceInfo = () => {
  return {
    platform: getPlatform(),
    appName: 'OpenMask',
    appVersion: '0.21.0',
    maxProtocolVersion: 2,
    features: [
      'SendTransaction',
      {
        name: 'SendTransaction',
        maxMessages: 4,
      },
    ],
  };
};

const formatConnectEventError = (error) => {
  return {
    event: 'connect_error',
    payload: {
      code: error.code ?? 0,
      message: error.message,
    },
  };
};

const mapErrorCode = (code) => {
  switch (code) {
    case 1001:
      return 100;
    case 1002:
      return 300;
    default:
      return 0;
  }
};

export class TonConnect {
  callbacks = [];

  deviceInfo = getDeviceInfo();
  walletInfo = {
    name: 'OpenBlock',
    image:
      'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTUiIGhlaWdodD0iNTUiIHZpZXdCb3g9IjAgMCA1NSA1NSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjU1IiBoZWlnaHQ9IjU1IiBmaWxsPSIjRjlGQkZGIi8+CjxwYXRoIGQ9Ik0zNi44MTQ3IDEwLjc3NTFDNDMuNTQ0NSAxMC43NzUxIDQ5IDE2LjIzMDYgNDkgMjIuOTYwNFYyMy4yNDc2TDQ0Ljc0NDIgMjcuNUw0OSAzMS43NDgzVjMyLjAzOTZDNDkgMzguNzY5NCA0My41Mzk5IDQ0LjIyNDkgMzYuODEwMiA0NC4yMjQ5SDUuOTg4NTNMMTUuODQ0NSAzNy4xMTAzTDMyLjI3NTEgMzcuMjMwN0MzNy41NTMzIDM3LjIz MDcgNDEuOTAzMSAzMi43NzgyIDQxLjkwMzEgMjcuNUM0MS45MDMxIDIyLjIyMTggMzcuNTUzMyAxNy43NjEgMzIuMjc1MSAxNy43NjFIMTUuODQ0NUw1Ljk5MzA4IDEwLjc3NTFIMzYuODE0N1oiIGZpbGw9IiM0QTNERTYiLz4KPHBhdGggZD0iTTE4LjEzODQgMjMuNDM4MkMxNS44OTUyIDIzLjQzODIgMTQuMDc2NyAyNS4yNTY3IDE0LjA3NjcgMjcuNDk5OUMxNC4wNzY3IDI5Ljc0MzIgMTUuODk1MiAzMS41NjE3IDE4LjEzODQgMzEuNTYxN0gzMi4yODkyQzM0LjUzMjUgMzEuNTYxNyAzNi4zNTEgMjkuNzQzMiAzNi4zNTEgMjcuNDk5OUMzNi4zNTEgMjUuMjU2NyAzNC41MzI1IDIzLjQzODIgMzIuMjg5MiAyMy40MzgySDE4LjEzODRaIiBmaWxsPSIjNEEzREU2Ii8+Cjwvc3ZnPgo=',
    about_url: 'https://openblock.com',
  };
  protocolVersion = 2;
  isWalletBrowser = false;

  constructor(provider) {
    this.provider = provider;

    provider.on('chainChanged', () => {
      this.notify({
        event: 'disconnect',
        payload: {},
      });
    });
  }

  connect = async (protocolVersion, message) => {
    console.log('tonConnect::connect', { protocolVersion, message });
    if (protocolVersion > this.protocolVersion) {
      return this.notify(
        formatConnectEventError(
          new TonConnectError('Unsupported protocol version', 1),
        ),
      );
    }
    try {
      let items;
      if (message.items.find((i) => i.name === 'ton_proof')) {
        items = await this.provider.send('ton_signMessage', message);
      } else {
        items = await this.provider.send('ton_accounts', message);
        if (!items || !items.length) {
          await this.provider.send('ton_requestAccounts', message);
          items = await this.provider.send('ton_accounts', message);
        }
      }

      return this.notify({
        event: 'connect',
        payload: {
          items: items,
          device: getDeviceInfo(),
        },
      });
    } catch (e) {
      if (e instanceof TonConnectError) {
        return this.notify(formatConnectEventError(e));
      } else {
        return this.notify(
          formatConnectEventError(
            new TonConnectError(
              e.message ?? 'Unknown error',
              mapErrorCode(e.code),
            ),
          ),
        );
      }
    }
  };

  disconnect = async () => {
    console.log('tonConnect::disconnect');
    await new Promise((resolve) => setTimeout(resolve));
    return this.notify({
      event: 'disconnect',
      payload: {},
    });
  };

  restoreConnection = async () => {
    console.log('tonConnect::restoreConnection');
    try {
      const items = await this.provider.send('ton_accounts', {
        items: [{ name: 'ton_addr' }],
      });

      return this.notify({
        event: 'connect',
        payload: {
          items: items,
          device: getDeviceInfo(),
        },
      });
    } catch (e) {
      if (e instanceof TonConnectError) {
        return this.notify(formatConnectEventError(e));
      } else {
        return this.notify(
          formatConnectEventError(
            new TonConnectError(e.message ?? 'Unknown error'),
          ),
        );
      }
    }
  };

  send = async (message) => {
    console.log('tonConnect::send', message);
    try {
      const result = await this.provider.send(
        `tonConnect_${message.method}`,
        message.params.map((item) => JSON.parse(item)),
      );
      return {
        result,
        id: String(message.id),
      };
    } catch (e) {
      return {
        error: e,
        id: String(message.id),
      };
    }
  };

  listen = (callback) => {
    this.callbacks.push(callback);
    return () => {
      this.callbacks = this.callbacks.filter((item) => item != callback);
    };
  };

  notify = (event) => {
    this.callbacks.forEach((item) => item(event));
    return event;
  };
}

export class TonProvider {
  isOpenMask = true;

  targetOrigin = '*';
  nextJsonRpcId = 0;
  promises;
  callbacks = {};

  constructor(walletRef) {
    this.walletRef = walletRef;
    this.walletProvider = 'ton';
  }

  isConnected = () => {
    console.log('tonProvider::isConnected');
    return this.send('ton_accounts').then(() => true);
  };

  isLocked = () => {
    return false;
  };

  send(method, params) {
    console.log('tonProvider::send', { method, params });
    if (method === 'tonConnect_sendTransaction') {
      method = 'ton_sendTransaction';
    }
    return this._hookRequest({
      method,
      params,
    });
  }

  on(event, cb) {
    if (!this.callbacks[event]) this.callbacks[event] = [];
    this.callbacks[event].push(cb);
  }

  off(event, cb) {
    let cbs = this.callbacks[event];
    if (cbs) {
      this.callbacks[event] = cbs.filter((item) => item !== cb);
    }
  }

  emit(event, data) {
    let cbs = this.callbacks[event];
    if (cbs) {
      cbs.forEach((cb) => cb(data));
    }
  }

  _hookRequest(paramsObj) {
    if (typeof paramsObj === 'string') {
      paramsObj = {
        method: paramsObj,
      };
    }

    paramsObj = {
      ...paramsObj,
      provider: this.walletProvider,
    };
    return this.walletRef.hookRequest(paramsObj);
  }

  addListener = this.on;
  removeListener = this.off;

  addEventListener = this.on;
  removeEventListener = this.off;
}
