"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _get_prototype_of(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = function(target, all) {
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = function(to, from, except, desc) {
    if (from && (typeof from === "undefined" ? "undefined" : _type_of(from)) === "object" || typeof from === "function") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var key = _step.value;
                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                    get: function() {
                        return from[key];
                    },
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            };
            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return to;
};
var __toESM = function(mod, isNodeMode, target) {
    return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod);
};
var __toCommonJS = function(mod) {
    return __copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
};
// src/index.ts
var index_exports = {};
__export(index_exports, {
    APTOS_CONNECT_ACCOUNT_URL: function() {
        return APTOS_CONNECT_ACCOUNT_URL;
    },
    APTOS_CONNECT_BASE_URL: function() {
        return APTOS_CONNECT_BASE_URL;
    },
    ChainIdToAnsSupportedNetworkMap: function() {
        return ChainIdToAnsSupportedNetworkMap;
    },
    NetworkName: function() {
        return NetworkName;
    },
    WalletCore: function() {
        return WalletCore;
    },
    WalletReadyState: function() {
        return WalletReadyState;
    },
    aptosStandardSupportedWalletList: function() {
        return aptosStandardSupportedWalletList;
    },
    convertNetwork: function() {
        return convertNetwork;
    },
    crossChainStandardSupportedWalletList: function() {
        return crossChainStandardSupportedWalletList;
    },
    fetchDevnetChainId: function() {
        return fetchDevnetChainId;
    },
    generalizedErrorMessage: function() {
        return generalizedErrorMessage;
    },
    getAptosConfig: function() {
        return getAptosConfig;
    },
    getAptosConnectWallets: function() {
        return getAptosConnectWallets;
    },
    getLocalStorage: function() {
        return getLocalStorage;
    },
    getSDKWallets: function() {
        return getSDKWallets;
    },
    groupAndSortWallets: function() {
        return groupAndSortWallets;
    },
    handlePublishPackageTransaction: function() {
        return handlePublishPackageTransaction;
    },
    isAptosConnectWallet: function() {
        return isAptosConnectWallet;
    },
    isAptosLiveNetwork: function() {
        return isAptosLiveNetwork;
    },
    isAptosNetwork: function() {
        return isAptosNetwork;
    },
    isInAppBrowser: function() {
        return isInAppBrowser;
    },
    isInstallRequired: function() {
        return isInstallRequired;
    },
    isInstalledOrLoadable: function() {
        return isInstalledOrLoadable;
    },
    isMobile: function() {
        return isMobile;
    },
    isRedirectable: function() {
        return isRedirectable;
    },
    partitionWallets: function() {
        return partitionWallets;
    },
    removeLocalStorage: function() {
        return removeLocalStorage;
    },
    setLocalStorage: function() {
        return setLocalStorage;
    },
    truncateAddress: function() {
        return truncateAddress;
    }
});
module.exports = __toCommonJS(index_exports);
// src/version.ts
var WALLET_ADAPTER_CORE_VERSION = "6.0.1";
// src/WalletCore.ts
var import_eventemitter3 = __toESM(require("eventemitter3"));
var import_ts_sdk2 = require("@aptos-labs/ts-sdk");
var import_wallet_standard = require("@aptos-labs/wallet-standard");
// src/ga/index.ts
var GA4 = /*#__PURE__*/ function() {
    function GA4() {
        _class_call_check(this, GA4);
        this.aptosGAID = "G-GNVVWBL3J9";
        this.injectGA(this.aptosGAID);
    }
    _create_class(GA4, [
        {
            key: "gtag",
            value: function gtag(a, b, c) {
                var dataLayer = window.dataLayer || [];
                dataLayer.push(arguments);
            }
        },
        {
            key: "injectGA",
            value: function injectGA(gaID) {
                if (typeof window === "undefined") return;
                if (!gaID) return;
                var head = document.getElementsByTagName("head")[0];
                var myScript = document.createElement("script");
                myScript.setAttribute("src", "https://www.googletagmanager.com/gtag/js?id=".concat(gaID));
                var that = this;
                myScript.onload = function() {
                    that.gtag("js", /* @__PURE__ */ new Date());
                    that.gtag("config", "".concat(gaID), {
                        send_page_view: false
                    });
                };
                head.insertBefore(myScript, head.children[1]);
            }
        }
    ]);
    return GA4;
}();
// src/error/index.ts
var WalletError = /*#__PURE__*/ function(Error1) {
    _inherits(WalletError, Error1);
    function WalletError(message, error) {
        _class_call_check(this, WalletError);
        var _this;
        _this = _call_super(this, WalletError, [
            message
        ]);
        _this.error = error;
        return _this;
    }
    return WalletError;
}(_wrap_native_super(Error));
var WalletNotSelectedError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNotSelectedError, WalletError);
    function WalletNotSelectedError() {
        _class_call_check(this, WalletNotSelectedError);
        var _this;
        _this = _call_super(this, WalletNotSelectedError, arguments);
        _this.name = "WalletNotSelectedError";
        return _this;
    }
    return WalletNotSelectedError;
}(WalletError);
var WalletNotReadyError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNotReadyError, WalletError);
    function WalletNotReadyError() {
        _class_call_check(this, WalletNotReadyError);
        var _this;
        _this = _call_super(this, WalletNotReadyError, arguments);
        _this.name = "WalletNotReadyError";
        return _this;
    }
    return WalletNotReadyError;
}(WalletError);
var WalletConnectionError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletConnectionError, WalletError);
    function WalletConnectionError() {
        _class_call_check(this, WalletConnectionError);
        var _this;
        _this = _call_super(this, WalletConnectionError, arguments);
        _this.name = "WalletConnectionError";
        return _this;
    }
    return WalletConnectionError;
}(WalletError);
var WalletDisconnectionError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletDisconnectionError, WalletError);
    function WalletDisconnectionError() {
        _class_call_check(this, WalletDisconnectionError);
        var _this;
        _this = _call_super(this, WalletDisconnectionError, arguments);
        _this.name = "WalletDisconnectionError";
        return _this;
    }
    return WalletDisconnectionError;
}(WalletError);
var WalletAccountError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletAccountError, WalletError);
    function WalletAccountError() {
        _class_call_check(this, WalletAccountError);
        var _this;
        _this = _call_super(this, WalletAccountError, arguments);
        _this.name = "WalletAccountError";
        return _this;
    }
    return WalletAccountError;
}(WalletError);
var WalletGetNetworkError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletGetNetworkError, WalletError);
    function WalletGetNetworkError() {
        _class_call_check(this, WalletGetNetworkError);
        var _this;
        _this = _call_super(this, WalletGetNetworkError, arguments);
        _this.name = "WalletGetNetworkError";
        return _this;
    }
    return WalletGetNetworkError;
}(WalletError);
var WalletAccountChangeError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletAccountChangeError, WalletError);
    function WalletAccountChangeError() {
        _class_call_check(this, WalletAccountChangeError);
        var _this;
        _this = _call_super(this, WalletAccountChangeError, arguments);
        _this.name = "WalletAccountChangeError";
        return _this;
    }
    return WalletAccountChangeError;
}(WalletError);
var WalletNetworkChangeError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNetworkChangeError, WalletError);
    function WalletNetworkChangeError() {
        _class_call_check(this, WalletNetworkChangeError);
        var _this;
        _this = _call_super(this, WalletNetworkChangeError, arguments);
        _this.name = "WalletNetworkChangeError";
        return _this;
    }
    return WalletNetworkChangeError;
}(WalletError);
var WalletNotConnectedError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNotConnectedError, WalletError);
    function WalletNotConnectedError() {
        _class_call_check(this, WalletNotConnectedError);
        var _this;
        _this = _call_super(this, WalletNotConnectedError, arguments);
        _this.name = "WalletNotConnectedError";
        return _this;
    }
    return WalletNotConnectedError;
}(WalletError);
var WalletSignMessageError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletSignMessageError, WalletError);
    function WalletSignMessageError() {
        _class_call_check(this, WalletSignMessageError);
        var _this;
        _this = _call_super(this, WalletSignMessageError, arguments);
        _this.name = "WalletSignMessageError";
        return _this;
    }
    return WalletSignMessageError;
}(WalletError);
var WalletSignMessageAndVerifyError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletSignMessageAndVerifyError, WalletError);
    function WalletSignMessageAndVerifyError() {
        _class_call_check(this, WalletSignMessageAndVerifyError);
        var _this;
        _this = _call_super(this, WalletSignMessageAndVerifyError, arguments);
        _this.name = "WalletSignMessageAndVerifyError";
        return _this;
    }
    return WalletSignMessageAndVerifyError;
}(WalletError);
var WalletSignAndSubmitMessageError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletSignAndSubmitMessageError, WalletError);
    function WalletSignAndSubmitMessageError() {
        _class_call_check(this, WalletSignAndSubmitMessageError);
        var _this;
        _this = _call_super(this, WalletSignAndSubmitMessageError, arguments);
        _this.name = "WalletSignAndSubmitMessageError";
        return _this;
    }
    return WalletSignAndSubmitMessageError;
}(WalletError);
var WalletSignTransactionError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletSignTransactionError, WalletError);
    function WalletSignTransactionError() {
        _class_call_check(this, WalletSignTransactionError);
        var _this;
        _this = _call_super(this, WalletSignTransactionError, arguments);
        _this.name = "WalletSignTransactionError";
        return _this;
    }
    return WalletSignTransactionError;
}(WalletError);
var WalletNotSupportedMethod = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNotSupportedMethod, WalletError);
    function WalletNotSupportedMethod() {
        _class_call_check(this, WalletNotSupportedMethod);
        var _this;
        _this = _call_super(this, WalletNotSupportedMethod, arguments);
        _this.name = "WalletNotSupportedMethod";
        return _this;
    }
    return WalletNotSupportedMethod;
}(WalletError);
var WalletChangeNetworkError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletChangeNetworkError, WalletError);
    function WalletChangeNetworkError() {
        _class_call_check(this, WalletChangeNetworkError);
        var _this;
        _this = _call_super(this, WalletChangeNetworkError, arguments);
        _this.name = "WalletChangeNetworkError";
        return _this;
    }
    return WalletChangeNetworkError;
}(WalletError);
var WalletSubmitTransactionError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletSubmitTransactionError, WalletError);
    function WalletSubmitTransactionError() {
        _class_call_check(this, WalletSubmitTransactionError);
        var _this;
        _this = _call_super(this, WalletSubmitTransactionError, arguments);
        _this.name = "WalletSubmitTransactionError";
        return _this;
    }
    return WalletSubmitTransactionError;
}(WalletError);
var WalletNotFoundError = /*#__PURE__*/ function(WalletError) {
    _inherits(WalletNotFoundError, WalletError);
    function WalletNotFoundError() {
        _class_call_check(this, WalletNotFoundError);
        var _this;
        _this = _call_super(this, WalletNotFoundError, arguments);
        _this.name = "WalletNotFoundError";
        return _this;
    }
    return WalletNotFoundError;
}(WalletError);
// src/constants.ts
var WalletReadyState = /* @__PURE__ */ function(WalletReadyState2) {
    WalletReadyState2["Installed"] = "Installed";
    WalletReadyState2["NotDetected"] = "NotDetected";
    return WalletReadyState2;
}(WalletReadyState || {});
var NetworkName = /* @__PURE__ */ function(NetworkName2) {
    NetworkName2["Mainnet"] = "mainnet";
    NetworkName2["Testnet"] = "testnet";
    NetworkName2["Devnet"] = "devnet";
    return NetworkName2;
}(NetworkName || {});
var ChainIdToAnsSupportedNetworkMap = {
    "1": "mainnet",
    // mainnet
    "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
// src/utils/helpers.ts
var import_ts_sdk = require("@aptos-labs/ts-sdk");
function isMobile() {
    return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(navigator.userAgent);
}
function isInAppBrowser() {
    var isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
    var isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(navigator.userAgent);
    return isIphone || isAndroid;
}
function isRedirectable() {
    if (typeof navigator === "undefined" || !navigator) return false;
    return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
    return (typeof error === "undefined" ? "undefined" : _type_of(error)) === "object" && "message" in error ? error.message : error;
}
var getAptosConfig = function(networkInfo, dappConfig) {
    if (!networkInfo) {
        throw new Error("Undefined network");
    }
    var pluginSettings = {
        TRANSACTION_SUBMITTER: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.transactionSubmitter
    };
    if (isAptosNetwork(networkInfo)) {
        var currentNetwork = convertNetwork(networkInfo);
        if (isAptosLiveNetwork(currentNetwork)) {
            var apiKey = dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosApiKeys;
            return new import_ts_sdk.AptosConfig({
                network: currentNetwork,
                clientConfig: {
                    API_KEY: apiKey ? apiKey[currentNetwork] : void 0
                },
                pluginSettings: pluginSettings
            });
        }
        return new import_ts_sdk.AptosConfig({
            network: currentNetwork,
            pluginSettings: pluginSettings
        });
    }
    var knownNetworks = {
        okx: "https://wallet.okx.com/fullnode/aptos/discover/rpc"
    };
    if (networkInfo.url) {
        var isKnownNetwork = Object.values(knownNetworks).includes(networkInfo.url);
        if (isKnownNetwork) {
            return new import_ts_sdk.AptosConfig({
                network: import_ts_sdk.Network.CUSTOM,
                fullnode: networkInfo.url,
                pluginSettings: pluginSettings
            });
        }
    }
    throw new Error("Invalid network, network ".concat(networkInfo.name, " not supported with Aptos wallet adapter to prevent user from using an unexpected network."));
};
var isAptosNetwork = function(networkInfo) {
    if (!networkInfo) {
        throw new Error("Undefined network");
    }
    return import_ts_sdk.NetworkToNodeAPI[networkInfo.name] !== void 0;
};
var isAptosLiveNetwork = function(networkInfo) {
    return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = /*#__PURE__*/ function() {
    var _ref = _async_to_generator(function() {
        var aptos;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    aptos = new import_ts_sdk.Aptos();
                    return [
                        4,
                        aptos.getChainId()
                    ];
                case 1:
                    return [
                        2,
                        _state.sent()
                    ];
            }
        });
    });
    return function fetchDevnetChainId() {
        return _ref.apply(this, arguments);
    };
}();
var handlePublishPackageTransaction = function(transactionInput) {
    var metadataBytes = transactionInput.data.functionArguments[0];
    if (typeof metadataBytes === "string") {
        metadataBytes = import_ts_sdk.Hex.fromHexInput(metadataBytes).toUint8Array();
    }
    var byteCode = transactionInput.data.functionArguments[1];
    if (Array.isArray(byteCode)) {
        byteCode = byteCode.map(function(byte) {
            if (typeof byte === "string") {
                return import_ts_sdk.Hex.fromHexInput(byte).toUint8Array();
            }
            return byte;
        });
    } else {
        throw new WalletSignAndSubmitMessageError("The bytecode argument must be an array.").message;
    }
    return {
        metadataBytes: metadataBytes,
        byteCode: byteCode
    };
};
function convertNetwork(networkInfo) {
    switch(networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.name){
        case "mainnet":
            return import_ts_sdk.Network.MAINNET;
        case "testnet":
            return import_ts_sdk.Network.TESTNET;
        case "devnet":
            return import_ts_sdk.Network.DEVNET;
        case "local":
            return import_ts_sdk.Network.LOCAL;
        default:
            throw new Error("Invalid Aptos network name");
    }
}
// src/utils/localStorage.ts
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
    localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
    localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
    localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
// src/utils/walletSelector.ts
function partitionWallets(wallets) {
    var partitionFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInstalledOrLoadable;
    var defaultWallets = [];
    var moreWallets = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = wallets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var wallet = _step.value;
            if (partitionFunction(wallet)) defaultWallets.push(wallet);
            else moreWallets.push(wallet);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return {
        defaultWallets: defaultWallets,
        moreWallets: moreWallets
    };
}
function isInstalledOrLoadable(wallet) {
    return wallet.readyState === "Installed" /* Installed */ ;
}
function isInstallRequired(wallet) {
    var isWalletReady = isInstalledOrLoadable(wallet);
    var isMobile2 = !isWalletReady && isRedirectable();
    return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
    if (!address) return;
    return "".concat(address.slice(0, 6), "...").concat(address.slice(-5));
}
function isAptosConnectWallet(wallet) {
    if (!wallet.url) return false;
    return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);
}
function getAptosConnectWallets(wallets) {
    var _partitionWallets = partitionWallets(wallets, isAptosConnectWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
    return {
        aptosConnectWallets: defaultWallets,
        otherWallets: moreWallets
    };
}
function groupAndSortWallets(wallets, options) {
    var _getAptosConnectWallets = getAptosConnectWallets(wallets), aptosConnectWallets = _getAptosConnectWallets.aptosConnectWallets, otherWallets = _getAptosConnectWallets.otherWallets;
    var _partitionWallets = partitionWallets(otherWallets), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
    if (options === null || options === void 0 ? void 0 : options.sortAptosConnectWallets) {
        aptosConnectWallets.sort(options.sortAptosConnectWallets);
    }
    if (options === null || options === void 0 ? void 0 : options.sortAvailableWallets) {
        defaultWallets.sort(options.sortAvailableWallets);
    }
    if (options === null || options === void 0 ? void 0 : options.sortInstallableWallets) {
        moreWallets.sort(options.sortInstallableWallets);
    }
    return {
        /** Wallets that use social login to create an account on the blockchain */ aptosConnectWallets: aptosConnectWallets,
        /** Wallets that are currently installed or loadable. */ availableWallets: defaultWallets,
        /** Wallets that are NOT currently installed or loadable. */ installableWallets: moreWallets
    };
}
// src/registry.ts
var aptosStandardSupportedWalletList = [
    {
        name: "OKX Wallet",
        url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true
    },
    {
        name: "Petra",
        url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWbSURBVHgB7Z09c9NYFIaPlFSpUqQNK6rQhbSkWJghLZP9BesxfwAqytg1xe7+AY+3go5ACzObBkpwSqrVQkuRCiqkva8UZW1je22wpHPveZ8ZRU6wwwznueee+6FLJCuSdzrb7nZTNjaOJc9/ctdNiaJESPPkeeq+phLH5/L162k0HJ7JikTLvtEFPnFBf+D+0l/dt9tCNJK6xnjmZOg7GdJlPvC/AhQtPo5P3MsHQvwhiobLiLBQABf82y74z4Qt3ldSybKHToLTeW+I5/1B3u2euOD/JQy+zyRowEUs5zAzA1x+oCckJHrRYNCf/uE3AjD4QfONBBMC5PfvY2j3TEi4ZNmd8eHilQDFMK/s8xMhIXPhJLjuJLjAN/8VgRsbPWHwLbAtm5tXRWGRAS5b/99C7FBmgbTMAGXrJ5aIomJir8wA3S5afyLEEkUtEBezfQy+RYpFvdilgmMhNnGxRw2wL8QqScy1fMNE0T4yQCLEKkksxDQUwDj2BNjbK69pdndn/zxwNsUCCOyNGyJ374psbYkMBiLv30++59o1kW5X5NMnkdFI5OXL8nXghCsAAn10NL/Fz2NnpxQFFyR5/bq8BypDWAIg6AcHIoeH60nn4/K8e1deECIgwhAAQULQEXxIUAf43bju3ZvMDJ7jrwDT/XpToIvABeECqBf8EuB7+/W6CKBe0C/Auvv1uvC0XtArQBP9el14VC/oEqCtfr0uPKgX2hdAW79eF0rrhfYFQPCRKi1RyY4ZyZYF4GKQcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcShAm3z+LG1DAdqEAhjn40dpGwrQFtgIwgxgGAWtH1CAtsC2cQVQgLZQsk2cArSBoqeHKEAbKHpiiAI0DVq+kv4fUICmQetXMPyroABNgtb/5o1oggI0icJzBChAUyDwr16JNihAUzx+LBqhAE3w5InaU0MoQN08f64y9VdQgDrBkO/FC9EMBagLBB/P/yvHxlGxTYPh3tOn4gMUYN2g4FPc509DAdYFqvxZh1ArhwKsg6rSVzTHvywU4EeoqnyPTxKnAKuCVo4iD4s6ARwhTwGWoTrk8e3bIE4IH4cCVCDI1U6dL1/K73Eh4B727ctCASoQ6MBa9zJwJtA4FMA4FMA4FMA4FMA4FMA4FMA4FMA47Qtg4P/n1Uz7AgQ8zeoD7Qug5KQMq+joApgFWkNHEWhwEUYLFMA4OgRQdGCCNXQIUG28II2jZyKIWaAV9Aig7OgUK+gRAMH36ImaUNC1FoDt1swCjaJLAAQfT9mQxtC3GohugCOCxtC5HIyHLNkVNIJOATAv4Mnz9b6jd0MIhoWsB2pH944gPHmLkQGpDf1bwtAVUILa8GNPICRgd1AL/mwKRXfA0cHa8WtXMArDfp8bSdeIf9vCEfxHj8psQBF+GH/PB0A2wIzhrVsih4ciOztCVsfvAyKQAVAbYPr44EDk6Ehkd1fI8oRxQggKQ2QEXMgEe3ulELhvbQmZT3hHxFRn+1Tn/UAAZAWIUXUTHz4IKQn/jCBkB6Pn/ywDHw41DgUwDgRIhVgljSWKzoXYJM+dAFmWCrHKeewsOBViExd71AAjd10IsUYaDYdnsfty4Uz4U4g1zvClHAbm+e9CbJFlfdwKAVwWSJ0EfwixwrCIuYxPBOV5T1gLWCCtWj+4EqCoBbLsFyFhk2UPq9YPJqaCURW6W19IqPRdjCeG/dGsd+Xdbs/dToSERD8aDHrTP4zmvZsSBMXM4INo0afyTudY4vg39zIR4iNFXXfZtc9k4XJw0V9k2R1OFHkIhvVZdn1R8MHCDDDx+zqdxK0c9tz1szAjaKWc1XUTe+OV/iKWFmAcJ8NtJ8Kxe7kvkCGKEiHN45Zz3b/9yN3/uVzUGxXD+RX4F56985hsqA6SAAAAAElFTkSuQmCC",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "https://petra.app/explore?link="
    },
    {
        name: "Nightly",
        url: "https://nightly.app/",
        icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "nightly://v1?network=aptos&url="
    },
    {
        name: "Pontem Wallet",
        url: "https://pontem.network/pontem-wallet",
        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true
    },
    {
        name: "Rimosafe",
        url: "https://chromewebstore.google.com/detail/rimo-safe-wallet/kiicddjcakdmobjkcpppkgcjbpakcagp",
        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiLz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzLCAzKSBzY2FsZSgwLjgpIj4KICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjkuNTMxMSA5Ljg0MzY5VjBIMTkuNjg3NEwxOS42ODc3IDAuMDAwMzQwNTU1TDAgMC4wMDAzNDE0MTVMNC4zMjEzNGUtMDcgOS44NDQwM0g5Ljg0MzY5QzQuNDA3MTcgOS44NDQwMyAwIDE0LjI1MTIgMCAxOS42ODc3VjMwLjAwMDFIOS44NDM2OVYxOS42ODc5TDE5LjY4NzEgMzAuMDAwMUwxOS42ODcxIDE5LjY4NzdMMjkuNTMwOCA5Ljg0NDAzTDI5LjUzMTEgOS44NDQwM1Y5Ljg0MzY1TDI5LjUzMTEgOS44NDM2OVpNMTkuNjg3MSAxOS42ODc2TDE5LjY4NzEgOS44NDQwM0g5Ljg0MzY5VjE5LjY4NzZIMTkuNjg3MVpNMjkuNTMxMSA5Ljg0MzY1TDE5LjY4NzcgMC4wMDAzNDA1NTVMMjkuNTMxMSAwLjAwMDM0MDEyNVY5Ljg0MzY1Wk0xOS42ODc0IDE5LjY4NzZIMjkuNTMxMVYzMC4wMDAxSDE5LjY4NzRWMTkuNjg3NloiIGZpbGw9IiNGRjVDMjgiLz4KICA8L2c+Cjwvc3ZnPgo=",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true
    }
];
var crossChainStandardSupportedWalletList = [
    {
        name: "Phantom (Solana)",
        url: "https://phantom.com/",
        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "https://phantom.app/ul/browse/"
    },
    {
        name: "Phantom (Ethereum)",
        url: "https://phantom.com/",
        icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "https://phantom.app/ul/browse/"
    },
    {
        name: "Nightly (Solana)",
        url: "https://nightly.app/",
        icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "nightly://v1?network=aptos&url="
    },
    {
        name: "Nightly (Ethereum)",
        url: "https://nightly.app/",
        icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "nightly://v1?network=aptos&url="
    }
];
// src/sdkWallets.ts
var import_wallet_adapter_plugin = require("@aptos-connect/wallet-adapter-plugin");
var import_aptos_aip62_wallet = require("@msafe/aptos-aip62-wallet");
function getSDKWallets(dappConfig) {
    var sdkWallets = [];
    if (typeof window !== "undefined") {
        sdkWallets.push(new import_wallet_adapter_plugin.AptosConnectGoogleWallet(_object_spread({
            network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
            dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
        }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new import_wallet_adapter_plugin.AptosConnectAppleWallet(_object_spread({
            network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
            dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
        }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)));
    }
    if ((dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.msafeWalletConfig) && dappConfig.network && (0, import_aptos_aip62_wallet.inMSafeWallet)()) {
        sdkWallets.push(new import_aptos_aip62_wallet.MSafeWallet(_object_spread_props(_object_spread({}, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.msafeWalletConfig), {
            network: dappConfig.network
        })));
    }
    return sdkWallets;
}
// src/WalletCore.ts
var WalletCore = /*#__PURE__*/ function(_import_eventemitter3_default) {
    _inherits(WalletCore, _import_eventemitter3_default);
    function WalletCore(optInWallets, dappConfig, disableTelemetry) {
        _class_call_check(this, WalletCore);
        var _this;
        _this = _call_super(this, WalletCore);
        // Local private variable to hold the wallet that is currently connected
        _this._wallet = null;
        // Local private variable to hold SDK wallets in the adapter
        _this._sdkWallets = [];
        // Local array that holds all the wallets that are AIP-62 standard compatible
        _this._standard_wallets = [];
        // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine
        _this._standard_not_detected_wallets = [];
        // Local private variable to hold the network that is currently connected
        _this._network = null;
        // Local private variable to hold the wallet connected state
        _this._connected = false;
        // Local private variable to hold the connecting state
        _this._connecting = false;
        // Local private variable to hold the account that is currently connected
        _this._account = null;
        // Private array that holds all the Wallets a dapp decided to opt-in to
        _this._optInWallets = [];
        // Local flag to disable the adapter telemetry tool
        _this._disableTelemetry = false;
        // Google Analytics 4 module
        _this.ga4 = null;
        _this._optInWallets = optInWallets || [];
        _this._dappConfig = dappConfig;
        _this._disableTelemetry = disableTelemetry !== null && disableTelemetry !== void 0 ? disableTelemetry : false;
        _this._sdkWallets = getSDKWallets(_this._dappConfig);
        if (!_this._disableTelemetry) {
            _this.ga4 = new GA4();
        }
        _this.fetchExtensionAIP62AptosWallets();
        _this.fetchSDKAIP62AptosWallets();
        _this.appendNotDetectedStandardSupportedWallets();
        return _this;
    }
    _create_class(WalletCore, [
        {
            key: "fetchExtensionAIP62AptosWallets",
            value: function fetchExtensionAIP62AptosWallets() {
                var _ref = (0, import_wallet_standard.getAptosWallets)(), aptosWallets = _ref.aptosWallets, on = _ref.on;
                this.setExtensionAIP62Wallets(aptosWallets);
                if (typeof window === "undefined") return;
                var that = this;
                var removeRegisterListener = on("register", function() {
                    var _ref = (0, import_wallet_standard.getAptosWallets)(), aptosWallets2 = _ref.aptosWallets;
                    that.setExtensionAIP62Wallets(aptosWallets2);
                });
                var removeUnregisterListener = on("unregister", function() {
                    var _ref = (0, import_wallet_standard.getAptosWallets)(), aptosWallets2 = _ref.aptosWallets;
                    that.setExtensionAIP62Wallets(aptosWallets2);
                });
            }
        },
        {
            /**
   * Set AIP-62 extension wallets
   *
   * @param extensionwWallets
   */ key: "setExtensionAIP62Wallets",
            value: function setExtensionAIP62Wallets(extensionwWallets) {
                var _this = this;
                extensionwWallets.map(function(wallet) {
                    if (_this.excludeWallet(wallet)) {
                        return;
                    }
                    var isValid = (0, import_wallet_standard.isWalletWithRequiredFeatureSet)(wallet);
                    if (isValid) {
                        var index = _this._standard_not_detected_wallets.findIndex(function(notDetctedWallet) {
                            return notDetctedWallet.name == wallet.name;
                        });
                        if (index !== -1) {
                            _this._standard_not_detected_wallets.splice(index, 1);
                        }
                        var alreadyExists = _this._standard_wallets.some(function(w) {
                            return w.name === wallet.name;
                        });
                        if (!alreadyExists) {
                            wallet.readyState = "Installed" /* Installed */ ;
                            wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
                            _this._standard_wallets.push(wallet);
                            _this.emit("standardWalletsAdded", wallet);
                        }
                    }
                });
            }
        },
        {
            /**
   * Set AIP-62 SDK wallets
   */ key: "fetchSDKAIP62AptosWallets",
            value: function fetchSDKAIP62AptosWallets() {
                var _this = this;
                this._sdkWallets.map(function(wallet) {
                    if (_this.excludeWallet(wallet)) {
                        return;
                    }
                    var isValid = (0, import_wallet_standard.isWalletWithRequiredFeatureSet)(wallet);
                    if (isValid) {
                        wallet.readyState = "Installed" /* Installed */ ;
                        wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
                        _this._standard_wallets.push(wallet);
                    }
                });
            }
        },
        {
            // Aptos native wallets do not have an authenticationFunction property
            key: "isAptosNativeWallet",
            value: function isAptosNativeWallet(wallet) {
                return !("authenticationFunction" in wallet);
            }
        },
        {
            // Since we can't discover AIP-62 wallets that are not installed on the user machine,
            // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.
            // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array
            // when wallet is not installed on the user machine
            key: "appendNotDetectedStandardSupportedWallets",
            value: function appendNotDetectedStandardSupportedWallets() {
                var _this = this;
                var _this__dappConfig;
                var walletRegistry = ((_this__dappConfig = this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.crossChainWallets) ? _to_consumable_array(aptosStandardSupportedWalletList).concat(_to_consumable_array(crossChainStandardSupportedWalletList)) : aptosStandardSupportedWalletList;
                walletRegistry.map(function(supportedWallet) {
                    var existingStandardWallet = _this._standard_wallets.find(function(wallet) {
                        return wallet.name == supportedWallet.name;
                    });
                    if (existingStandardWallet) {
                        return;
                    }
                    if (_this.excludeWallet(supportedWallet)) {
                        return;
                    }
                    if (!existingStandardWallet) {
                        supportedWallet.isAptosNativeWallet = !("authenticationFunction" in supportedWallet);
                        _this._standard_not_detected_wallets.push(supportedWallet);
                        _this.emit("standardNotDetectedWalletAdded", supportedWallet);
                    }
                });
            }
        },
        {
            /**
   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include
   *
   * @param wallet AdapterWallet | AdapterNotDetectedWallet
   * @returns boolean
   */ key: "excludeWallet",
            value: function excludeWallet(wallet) {
                if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
                    return true;
                }
                return false;
            }
        },
        {
            key: "recordEvent",
            value: function recordEvent(eventName, additionalInfo) {
                var _this__wallet, _this__network, _this__network1, _this_ga4;
                (_this_ga4 = this.ga4) === null || _this_ga4 === void 0 ? void 0 : _this_ga4.gtag("event", "wallet_adapter_".concat(eventName), _object_spread({
                    wallet: (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name,
                    network: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                    network_url: (_this__network1 = this._network) === null || _this__network1 === void 0 ? void 0 : _this__network1.url,
                    adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
                    send_to: "G-GNVVWBL3J9"
                }, additionalInfo));
            }
        },
        {
            /**
   * Helper function to ensure wallet exists
   *
   * @param wallet A wallet
   */ key: "ensureWalletExists",
            value: function ensureWalletExists(wallet) {
                if (!wallet) {
                    throw new WalletNotConnectedError().name;
                }
                if (!(wallet.readyState === "Installed" /* Installed */ )) throw new WalletNotReadyError("Wallet is not set").name;
            }
        },
        {
            /**
   * Helper function to ensure account exists
   *
   * @param account An account
   */ key: "ensureAccountExists",
            value: function ensureAccountExists(account) {
                if (!account) {
                    throw new WalletAccountError("Account is not set").name;
                }
            }
        },
        {
            key: "setAnsName",
            value: /**
   * Queries and sets ANS name for the current connected wallet account
   */ function setAnsName() {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__network, aptosConfig, aptos, name, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!(((_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.chainId) && _this._account)) return [
                                    3,
                                    4
                                ];
                                if (_this._account.ansName) return [
                                    2
                                ];
                                if (!ChainIdToAnsSupportedNetworkMap[_this._network.chainId] || !isAptosNetwork(_this._network)) {
                                    _this._account.ansName = void 0;
                                    return [
                                        2
                                    ];
                                }
                                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                                aptos = new import_ts_sdk2.Aptos(aptosConfig);
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    aptos.ans.getPrimaryName({
                                        address: _this._account.address.toString()
                                    })
                                ];
                            case 2:
                                name = _state.sent();
                                _this._account.ansName = name;
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                error = _state.sent();
                                console.log("Error setting ANS name ".concat(error));
                                return [
                                    3,
                                    4
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            /**
   * Function to cleat wallet adapter data.
   *
   * - Removes current connected wallet state
   * - Removes current connected account state
   * - Removes current connected network state
   * - Removes autoconnect local storage value
   */ key: "clearData",
            value: function clearData() {
                this._connected = false;
                this.setWallet(null);
                this.setAccount(null);
                this.setNetwork(null);
                removeLocalStorage();
            }
        },
        {
            /**
   * Sets the connected wallet
   *
   * @param wallet A wallet
   */ key: "setWallet",
            value: function setWallet(wallet) {
                this._wallet = wallet;
            }
        },
        {
            /**
   * Sets the connected account
   *
   * @param account An account
   */ key: "setAccount",
            value: function setAccount(account) {
                this._account = account;
            }
        },
        {
            /**
   * Sets the connected network
   *
   * @param network A network
   */ key: "setNetwork",
            value: function setNetwork(network) {
                this._network = network;
            }
        },
        {
            /**
   * Helper function to detect whether a wallet is connected
   *
   * @returns boolean
   */ key: "isConnected",
            value: function isConnected() {
                return this._connected;
            }
        },
        {
            key: "wallets",
            get: /**
   * Getter to fetch all detected wallets
   */ function get() {
                return this._standard_wallets;
            }
        },
        {
            key: "notDetectedWallets",
            get: function get() {
                return this._standard_not_detected_wallets;
            }
        },
        {
            key: "wallet",
            get: /**
   * Getter for the current connected wallet
   *
   * @return wallet info
   * @throws WalletNotSelectedError
   */ function get() {
                try {
                    if (!this._wallet) return null;
                    return this._wallet;
                } catch (error) {
                    throw new WalletNotSelectedError(error).message;
                }
            }
        },
        {
            key: "account",
            get: /**
   * Getter for the current connected account
   *
   * @return account info
   * @throws WalletAccountError
   */ function get() {
                try {
                    return this._account;
                } catch (error) {
                    throw new WalletAccountError(error).message;
                }
            }
        },
        {
            key: "network",
            get: /**
   * Getter for the current wallet network
   *
   * @return network info
   * @throws WalletGetNetworkError
   */ function get() {
                try {
                    return this._network;
                } catch (error) {
                    throw new WalletGetNetworkError(error).message;
                }
            }
        },
        {
            key: "connect",
            value: /**
   * Helper function to run some checks before we connect with a wallet.
   *
   * @param walletName. The wallet name we want to connect with.
   */ function connect(walletName) {
                var _this = this;
                return _async_to_generator(function() {
                    var selectedWallet2, uninstalledWallet, parameter, url, ref, location, allDetectedWallets, selectedWallet, _this__wallet;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (isRedirectable()) {
                                    selectedWallet2 = _this._standard_not_detected_wallets.find(function(wallet) {
                                        return wallet.name === walletName;
                                    });
                                    if (selectedWallet2) {
                                        uninstalledWallet = selectedWallet2;
                                        if (uninstalledWallet.deeplinkProvider) {
                                            parameter = "";
                                            if (uninstalledWallet.name.includes("Phantom")) {
                                                url = encodeURIComponent(window.location.href);
                                                ref = encodeURIComponent(window.location.origin);
                                                parameter = "".concat(url, "?ref=").concat(ref);
                                            } else {
                                                parameter = encodeURIComponent(window.location.href);
                                            }
                                            location = uninstalledWallet.deeplinkProvider.concat(parameter);
                                            window.location.href = location;
                                            return [
                                                2
                                            ];
                                        }
                                    }
                                }
                                allDetectedWallets = _this._standard_wallets;
                                selectedWallet = allDetectedWallets.find(function(wallet) {
                                    return wallet.name === walletName;
                                });
                                if (!selectedWallet) return [
                                    2
                                ];
                                if (_this._connected && _this._account) {
                                    ;
                                    if (((_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name) === walletName) throw new WalletConnectionError("".concat(walletName, " wallet is already connected")).message;
                                }
                                return [
                                    4,
                                    _this.connectWallet(selectedWallet, /*#__PURE__*/ _async_to_generator(function() {
                                        var response;
                                        return _ts_generator(this, function(_state) {
                                            switch(_state.label){
                                                case 0:
                                                    return [
                                                        4,
                                                        selectedWallet.features["aptos:connect"].connect()
                                                    ];
                                                case 1:
                                                    response = _state.sent();
                                                    if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                                        throw new WalletConnectionError("User has rejected the request").message;
                                                    }
                                                    return [
                                                        2,
                                                        {
                                                            account: response.args,
                                                            output: void 0
                                                        }
                                                    ];
                                            }
                                        });
                                    }))
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signIn",
            value: /**
   * Signs into the wallet by connecting and signing an authentication messages.
   *
   * For more information, visit: https://siwa.aptos.dev
   *
   * @param args
   * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed
   * @param args.walletName The name of the wallet to sign into
   * @returns The AptosSignInOutput which contains the account and signature information
   */ function signIn(args) {
                var _this = this;
                return _async_to_generator(function() {
                    var input, walletName, allDetectedWallets, selectedWallet;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                input = args.input, walletName = args.walletName;
                                allDetectedWallets = _this._standard_wallets;
                                selectedWallet = allDetectedWallets.find(function(wallet) {
                                    return wallet.name === walletName;
                                });
                                if (!selectedWallet) {
                                    throw new WalletNotFoundError("Wallet ".concat(walletName, " not found")).message;
                                }
                                if (!selectedWallet.features["aptos:signIn"]) {
                                    throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(walletName)).message;
                                }
                                return [
                                    4,
                                    _this.connectWallet(selectedWallet, /*#__PURE__*/ _async_to_generator(function() {
                                        var response;
                                        return _ts_generator(this, function(_state) {
                                            switch(_state.label){
                                                case 0:
                                                    if (!selectedWallet.features["aptos:signIn"]) {
                                                        throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(selectedWallet.name)).message;
                                                    }
                                                    return [
                                                        4,
                                                        selectedWallet.features["aptos:signIn"].signIn(input)
                                                    ];
                                                case 1:
                                                    response = _state.sent();
                                                    if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                                        throw new WalletConnectionError("User has rejected the request").message;
                                                    }
                                                    return [
                                                        2,
                                                        {
                                                            account: response.args.account,
                                                            output: response.args
                                                        }
                                                    ];
                                            }
                                        });
                                    }))
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "connectWallet",
            value: /**
   * Connects a wallet to the dapp.
   * On connect success, we set the current account and the network, and keeping the selected wallet
   * name in LocalStorage to support autoConnect function.
   *
   * @param selectedWallet. The wallet we want to connect.
   * @emit emits "connect" event
   * @throws WalletConnectionError
   */ function connectWallet(selectedWallet, onConnect) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, account, output, network, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    4,
                                    5,
                                    6
                                ]);
                                _this._connecting = true;
                                _this.setWallet(selectedWallet);
                                return [
                                    4,
                                    onConnect()
                                ];
                            case 1:
                                _ref = _state.sent(), account = _ref.account, output = _ref.output;
                                _this.setAccount(account);
                                return [
                                    4,
                                    selectedWallet.features["aptos:network"].network()
                                ];
                            case 2:
                                network = _state.sent();
                                _this.setNetwork(network);
                                return [
                                    4,
                                    _this.setAnsName()
                                ];
                            case 3:
                                _state.sent();
                                setLocalStorage(selectedWallet.name);
                                _this._connected = true;
                                _this.recordEvent("wallet_connect");
                                _this.emit("connect", account);
                                return [
                                    2,
                                    output
                                ];
                            case 4:
                                error = _state.sent();
                                _this.clearData();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletConnectionError(errMsg).message;
                            case 5:
                                _this._connecting = false;
                                return [
                                    7
                                ];
                            case 6:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "disconnect",
            value: /**
   * Disconnect the current connected wallet. On success, we clear the
   * current account, current network and LocalStorage data.
   *
   * @emit emits "disconnect" event
   * @throws WalletDisconnectionError
   */ function disconnect() {
                var _this = this;
                return _async_to_generator(function() {
                    var error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                return [
                                    4,
                                    _this._wallet.features["aptos:disconnect"].disconnect()
                                ];
                            case 1:
                                _state.sent();
                                _this.clearData();
                                _this.recordEvent("wallet_disconnect");
                                _this.emit("disconnect");
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletDisconnectionError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signAndSubmitTransaction",
            value: /**
   * Signs and submits a transaction to chain
   *
   * @param transactionInput InputTransactionData
   * @returns AptosSignAndSubmitTransactionOutput
   */ function signAndSubmitTransaction(transactionInput) {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__dappConfig, ref, shouldUseTxnSubmitter, _transactionInput_options, _transactionInput_options1, aptosConfig2, aptos2, transaction2, signAndSubmitTransactionMethod, response3, response2, aptosConfig, aptos, transaction, signTransactionResponse, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    9,
                                    ,
                                    10
                                ]);
                                if ("function" in transactionInput.data) {
                                    if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
                                        throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
                                    }
                                    if (transactionInput.data.function === "0x1::code::publish_package_txn") {
                                        ;
                                        ref = handlePublishPackageTransaction(transactionInput), transactionInput.data.functionArguments[0] = ref.metadataBytes, transactionInput.data.functionArguments[1] = ref.byteCode, ref;
                                    }
                                }
                                _this.ensureWalletExists(_this._wallet);
                                _this.ensureAccountExists(_this._account);
                                _this.recordEvent("sign_and_submit_transaction");
                                shouldUseTxnSubmitter = ((_this__dappConfig = _this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.transactionSubmitter) !== void 0 || transactionInput.transactionSubmitter !== void 0;
                                if (!(_this._wallet.features["aptos:signAndSubmitTransaction"] && !shouldUseTxnSubmitter)) return [
                                    3,
                                    5
                                ];
                                if (!(_this._wallet.features["aptos:signAndSubmitTransaction"].version !== "1.1.0")) return [
                                    3,
                                    3
                                ];
                                aptosConfig2 = getAptosConfig(_this._network, _this._dappConfig);
                                aptos2 = new import_ts_sdk2.Aptos(aptosConfig2);
                                return [
                                    4,
                                    aptos2.transaction.build.simple({
                                        sender: _this._account.address.toString(),
                                        data: transactionInput.data,
                                        options: transactionInput.options
                                    })
                                ];
                            case 1:
                                transaction2 = _state.sent();
                                signAndSubmitTransactionMethod = _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction;
                                return [
                                    4,
                                    signAndSubmitTransactionMethod(transaction2)
                                ];
                            case 2:
                                response3 = _state.sent();
                                if (response3.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response3.args
                                ];
                            case 3:
                                return [
                                    4,
                                    _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction({
                                        payload: transactionInput.data,
                                        gasUnitPrice: (_transactionInput_options = transactionInput.options) === null || _transactionInput_options === void 0 ? void 0 : _transactionInput_options.gasUnitPrice,
                                        maxGasAmount: (_transactionInput_options1 = transactionInput.options) === null || _transactionInput_options1 === void 0 ? void 0 : _transactionInput_options1.maxGasAmount
                                    })
                                ];
                            case 4:
                                response2 = _state.sent();
                                if (response2.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response2.args
                                ];
                            case 5:
                                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                                aptos = new import_ts_sdk2.Aptos(aptosConfig);
                                return [
                                    4,
                                    aptos.transaction.build.simple({
                                        sender: _this._account.address.toString(),
                                        data: transactionInput.data,
                                        options: transactionInput.options,
                                        withFeePayer: shouldUseTxnSubmitter
                                    })
                                ];
                            case 6:
                                transaction = _state.sent();
                                return [
                                    4,
                                    _this.signTransaction({
                                        transactionOrPayload: transaction
                                    })
                                ];
                            case 7:
                                signTransactionResponse = _state.sent();
                                return [
                                    4,
                                    _this.submitTransaction({
                                        transaction: transaction,
                                        senderAuthenticator: signTransactionResponse.authenticator,
                                        transactionSubmitter: transactionInput.transactionSubmitter,
                                        pluginParams: transactionInput.pluginParams
                                    })
                                ];
                            case 8:
                                response = _state.sent();
                                return [
                                    2,
                                    {
                                        hash: response.hash
                                    }
                                ];
                            case 9:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignAndSubmitMessageError(errMsg).message;
                            case 10:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signTransaction",
            value: /**
   * Signs a transaction
   *
   * This method supports 2 input types -
   * 1. A raw transaction that was already built by the dapp,
   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing
   *
   * @param transactionOrPayload AnyRawTransaction | InputTransactionData
   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer
   * @param options optional. Transaction options
   *
   * @returns AccountAuthenticator
   */ function signTransaction(args) {
                var _this = this;
                return _async_to_generator(function() {
                    var transactionOrPayload, asFeePayer, _this__wallet_features_aptossignTransaction, _this__wallet, response, _transactionOrPayload_options, _transactionOrPayload_options1, _transactionOrPayload_options2, _transactionOrPayload_options3, _transactionOrPayload_options4, _this__wallet1, signTransactionV1_1StandardInput, walletSignTransactionMethod, response1, _this__wallet2, aptosConfig, aptos, transaction, response2, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                transactionOrPayload = args.transactionOrPayload, asFeePayer = args.asFeePayer;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    9,
                                    ,
                                    10
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                _this.ensureAccountExists(_this._account);
                                _this.recordEvent("sign_transaction");
                                if (!("rawTransaction" in transactionOrPayload)) return [
                                    3,
                                    3
                                ];
                                return [
                                    4,
                                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.features["aptos:signTransaction"].signTransaction(transactionOrPayload, asFeePayer)
                                ];
                            case 2:
                                response = _state.sent();
                                if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response.args,
                                        rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()
                                    }
                                ];
                            case 3:
                                if (!(((_this__wallet_features_aptossignTransaction = _this._wallet.features["aptos:signTransaction"]) === null || _this__wallet_features_aptossignTransaction === void 0 ? void 0 : _this__wallet_features_aptossignTransaction.version) === "1.1")) return [
                                    3,
                                    5
                                ];
                                signTransactionV1_1StandardInput = {
                                    payload: transactionOrPayload.data,
                                    expirationTimestamp: (_transactionOrPayload_options = transactionOrPayload.options) === null || _transactionOrPayload_options === void 0 ? void 0 : _transactionOrPayload_options.expirationTimestamp,
                                    expirationSecondsFromNow: (_transactionOrPayload_options1 = transactionOrPayload.options) === null || _transactionOrPayload_options1 === void 0 ? void 0 : _transactionOrPayload_options1.expirationSecondsFromNow,
                                    gasUnitPrice: (_transactionOrPayload_options2 = transactionOrPayload.options) === null || _transactionOrPayload_options2 === void 0 ? void 0 : _transactionOrPayload_options2.gasUnitPrice,
                                    maxGasAmount: (_transactionOrPayload_options3 = transactionOrPayload.options) === null || _transactionOrPayload_options3 === void 0 ? void 0 : _transactionOrPayload_options3.maxGasAmount,
                                    sequenceNumber: (_transactionOrPayload_options4 = transactionOrPayload.options) === null || _transactionOrPayload_options4 === void 0 ? void 0 : _transactionOrPayload_options4.accountSequenceNumber,
                                    sender: transactionOrPayload.sender ? {
                                        address: import_ts_sdk2.AccountAddress.from(transactionOrPayload.sender)
                                    } : void 0
                                };
                                walletSignTransactionMethod = (_this__wallet1 = _this._wallet) === null || _this__wallet1 === void 0 ? void 0 : _this__wallet1.features["aptos:signTransaction"].signTransaction;
                                return [
                                    4,
                                    walletSignTransactionMethod(signTransactionV1_1StandardInput)
                                ];
                            case 4:
                                response1 = _state.sent();
                                if (response1.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response1.args.authenticator,
                                        rawTransaction: response1.args.rawTransaction.bcsToBytes()
                                    }
                                ];
                            case 5:
                                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                                aptos = new import_ts_sdk2.Aptos(aptosConfig);
                                return [
                                    4,
                                    aptos.transaction.build.simple({
                                        sender: _this._account.address,
                                        data: transactionOrPayload.data,
                                        options: transactionOrPayload.options,
                                        withFeePayer: transactionOrPayload.withFeePayer
                                    })
                                ];
                            case 6:
                                transaction = _state.sent();
                                return [
                                    4,
                                    (_this__wallet2 = _this._wallet) === null || _this__wallet2 === void 0 ? void 0 : _this__wallet2.features["aptos:signTransaction"].signTransaction(transaction, asFeePayer)
                                ];
                            case 7:
                                response2 = _state.sent();
                                if (response2.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response2.args,
                                        rawTransaction: transaction.bcsToBytes()
                                    }
                                ];
                            case 8:
                                return [
                                    3,
                                    10
                                ];
                            case 9:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignTransactionError(errMsg).message;
                            case 10:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signMessage",
            value: /**
   * Sign a message (doesnt submit to chain).
   *
   * @param message - AptosSignMessageInput
   *
   * @return response from the wallet's signMessage function
   * @throws WalletSignMessageError
   */ function signMessage(message) {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__wallet_features_aptossignMessage, _this__wallet, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                _this.recordEvent("sign_message");
                                return [
                                    4,
                                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : (_this__wallet_features_aptossignMessage = _this__wallet.features["aptos:signMessage"]) === null || _this__wallet_features_aptossignMessage === void 0 ? void 0 : _this__wallet_features_aptossignMessage.signMessage(message)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response.args
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignMessageError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "submitTransaction",
            value: /**
   * Submits transaction to chain
   *
   * @param transaction - InputSubmitTransactionData
   * @returns PendingTransactionResponse
   */ function submitTransaction(transaction) {
                var _this = this;
                return _async_to_generator(function() {
                    var additionalSignersAuthenticators, transactionType, aptosConfig, aptos, multiAgentTxn, errMsg;
                    return _ts_generator(this, function(_state) {
                        try {
                            _this.ensureWalletExists(_this._wallet);
                            additionalSignersAuthenticators = transaction.additionalSignersAuthenticators;
                            transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
                            _this.recordEvent("submit_transaction", {
                                transaction_type: transactionType
                            });
                            aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                            aptos = new import_ts_sdk2.Aptos(aptosConfig);
                            if (additionalSignersAuthenticators !== void 0) {
                                multiAgentTxn = _object_spread_props(_object_spread({}, transaction), {
                                    additionalSignersAuthenticators: additionalSignersAuthenticators
                                });
                                return [
                                    2,
                                    aptos.transaction.submit.multiAgent(multiAgentTxn)
                                ];
                            } else {
                                return [
                                    2,
                                    aptos.transaction.submit.simple(transaction)
                                ];
                            }
                        } catch (error) {
                            errMsg = generalizedErrorMessage(error);
                            throw new WalletSubmitTransactionError(errMsg).message;
                        }
                        return [
                            2
                        ];
                    });
                })();
            }
        },
        {
            key: "onAccountChange",
            value: /**
   Event for when account has changed on the wallet
   @return the new account info
   @throws WalletAccountChangeError
   */ function onAccountChange() {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__wallet_features_aptosonAccountChange, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                return [
                                    4,
                                    (_this__wallet_features_aptosonAccountChange = _this._wallet.features["aptos:onAccountChange"]) === null || _this__wallet_features_aptosonAccountChange === void 0 ? void 0 : _this__wallet_features_aptosonAccountChange.onAccountChange(/*#__PURE__*/ function() {
                                        var _ref = _async_to_generator(function(data) {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        _this.setAccount(data);
                                                        return [
                                                            4,
                                                            _this.setAnsName()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        _this.recordEvent("account_change");
                                                        _this.emit("accountChange", _this._account);
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        });
                                        return function(data) {
                                            return _ref.apply(this, arguments);
                                        };
                                    }())
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletAccountChangeError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "onNetworkChange",
            value: /**
   Event for when network has changed on the wallet
   @return the new network info
   @throws WalletNetworkChangeError
   */ function onNetworkChange() {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__wallet_features_aptosonNetworkChange, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                return [
                                    4,
                                    (_this__wallet_features_aptosonNetworkChange = _this._wallet.features["aptos:onNetworkChange"]) === null || _this__wallet_features_aptosonNetworkChange === void 0 ? void 0 : _this__wallet_features_aptosonNetworkChange.onNetworkChange(/*#__PURE__*/ function() {
                                        var _ref = _async_to_generator(function(data) {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        _this.setNetwork(data);
                                                        return [
                                                            4,
                                                            _this.setAnsName()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        _this.emit("networkChange", _this._network);
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        });
                                        return function(data) {
                                            return _ref.apply(this, arguments);
                                        };
                                    }())
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletNetworkChangeError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "changeNetwork",
            value: /**
   * Sends a change network request to the wallet to change the connected network
   *
   * @param network - Network
   * @returns AptosChangeNetworkOutput
   */ function changeNetwork(network) {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__network, chainId, _tmp, networkInfo, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    6,
                                    ,
                                    7
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                _this.recordEvent("change_network_request", {
                                    from: (_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                                    to: network
                                });
                                if (!(network === import_ts_sdk2.Network.DEVNET)) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    fetchDevnetChainId()
                                ];
                            case 1:
                                _tmp = _state.sent();
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                _tmp = import_ts_sdk2.NetworkToChainId[network];
                                _state.label = 3;
                            case 3:
                                chainId = _tmp;
                                networkInfo = {
                                    name: network,
                                    chainId: chainId
                                };
                                if (!_this._wallet.features["aptos:changeNetwork"]) return [
                                    3,
                                    5
                                ];
                                return [
                                    4,
                                    _this._wallet.features["aptos:changeNetwork"].changeNetwork(networkInfo)
                                ];
                            case 4:
                                response = _state.sent();
                                if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response.args
                                ];
                            case 5:
                                throw new WalletChangeNetworkError("".concat(_this._wallet.name, " does not support changing network request")).message;
                            case 6:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletChangeNetworkError(errMsg).message;
                            case 7:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signMessageAndVerify",
            value: /**
   * Signs a message and verifies the signer
   * @param message - AptosSignMessageInput
   * @returns boolean
   */ function signMessageAndVerify(message) {
                var _this = this;
                return _async_to_generator(function() {
                    var response, aptosConfig, signingMessage, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    4,
                                    ,
                                    5
                                ]);
                                _this.ensureWalletExists(_this._wallet);
                                _this.ensureAccountExists(_this._account);
                                _this.recordEvent("sign_message_and_verify");
                                return [
                                    4,
                                    _this._wallet.features["aptos:signMessage"].signMessage(message)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("Failed to sign a message").message;
                                }
                                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                                signingMessage = new TextEncoder().encode(response.args.fullMessage);
                                if (!("verifySignatureAsync" in _this._account.publicKey)) return [
                                    3,
                                    3
                                ];
                                return [
                                    4,
                                    _this._account.publicKey.verifySignatureAsync({
                                        aptosConfig: aptosConfig,
                                        message: signingMessage,
                                        signature: response.args.signature,
                                        options: {
                                            throwErrorWithReason: true
                                        }
                                    })
                                ];
                            case 2:
                                return [
                                    2,
                                    _state.sent()
                                ];
                            case 3:
                                return [
                                    2,
                                    _this._account.publicKey.verifySignature({
                                        message: signingMessage,
                                        signature: response.args.signature
                                    })
                                ];
                            case 4:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignMessageAndVerifyError(errMsg).message;
                            case 5:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        }
    ]);
    return WalletCore;
}(import_eventemitter3.default);
// src/index.ts
if (typeof window !== "undefined") {
    window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    APTOS_CONNECT_ACCOUNT_URL: APTOS_CONNECT_ACCOUNT_URL,
    APTOS_CONNECT_BASE_URL: APTOS_CONNECT_BASE_URL,
    ChainIdToAnsSupportedNetworkMap: ChainIdToAnsSupportedNetworkMap,
    NetworkName: NetworkName,
    WalletCore: WalletCore,
    WalletReadyState: WalletReadyState,
    aptosStandardSupportedWalletList: aptosStandardSupportedWalletList,
    convertNetwork: convertNetwork,
    crossChainStandardSupportedWalletList: crossChainStandardSupportedWalletList,
    fetchDevnetChainId: fetchDevnetChainId,
    generalizedErrorMessage: generalizedErrorMessage,
    getAptosConfig: getAptosConfig,
    getAptosConnectWallets: getAptosConnectWallets,
    getLocalStorage: getLocalStorage,
    getSDKWallets: getSDKWallets,
    groupAndSortWallets: groupAndSortWallets,
    handlePublishPackageTransaction: handlePublishPackageTransaction,
    isAptosConnectWallet: isAptosConnectWallet,
    isAptosLiveNetwork: isAptosLiveNetwork,
    isAptosNetwork: isAptosNetwork,
    isInAppBrowser: isInAppBrowser,
    isInstallRequired: isInstallRequired,
    isInstalledOrLoadable: isInstalledOrLoadable,
    isMobile: isMobile,
    isRedirectable: isRedirectable,
    partitionWallets: partitionWallets,
    removeLocalStorage: removeLocalStorage,
    setLocalStorage: setLocalStorage,
    truncateAddress: truncateAddress
});
//# sourceMappingURL=index.js.map