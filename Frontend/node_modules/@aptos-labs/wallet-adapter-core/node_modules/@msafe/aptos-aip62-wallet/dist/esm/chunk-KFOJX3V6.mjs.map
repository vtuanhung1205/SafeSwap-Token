{"version":3,"sources":["../../src/Bellhop.ts"],"sourcesContent":["import { BellhopEventDispatcher } from './BellhopEventDispatcher.js'\n\n/**\n *  Abstract communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  private id: string\n  private connected: boolean\n  private connecting: boolean\n  private isChild: boolean\n  private debug: boolean\n  private supported: boolean\n  private origin: string\n  private _sendLater: any[]\n  private iframe: HTMLIFrameElement | null\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super()\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`\n    /**\n     *  If we are connected to another instance of bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true\n\n    /**\n     *  If we are currently trying to connect\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false\n\n    /**\n     * If debug mode is turned on\n     *  @property {Boolean} debug\n     *  @default false\n     *  @private\n     */\n    this.debug = false\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*'\n\n    this.supported = false\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = []\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this)\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message: MessageEvent) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return\n    }\n\n    this.logDebugMessage(true, message)\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data)\n        } catch (err) {\n          console.warn('Bellhop error: ', err)\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data)\n      }\n      return\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data)\n  }\n  /**\n   * Handle the initial connected message\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message: object) {\n    this.connecting = false\n    this.connected = true\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      // Timing issue: this.iframe.contentWindow is null when parent closes child iframe before done with rendering\n      if (!this.target) {\n        return\n      }\n      this.target.postMessage(message, this.origin)\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i]\n      this.send(type, data)\n    }\n    this._sendLater.length = 0\n\n    // If there is a connection event assigned call it\n    this.trigger('connected')\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe?: HTMLIFrameElement, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect()\n\n    // We are trying to connect\n    this.connecting = true\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined\n\n    this.supported = true\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = (window as any) != iframe\n    }\n\n    this.origin = origin\n\n    window.addEventListener('message', this.receive)\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed')\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target?.postMessage('connected', this.origin)\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false\n    this.connecting = false\n    this.origin = ''\n    this.iframe = null\n    this.isChild = true\n    this._sendLater.length = 0\n\n    window.removeEventListener('message', this.receive)\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type: string, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string'\n    }\n\n    const message = {\n      type,\n      data\n    }\n\n    this.logDebugMessage(false, message)\n\n    if (this.connecting) {\n      this._sendLater.push(message)\n    } else {\n      this.target?.postMessage(\n        JSON.stringify(message, (_, v) => {\n          return typeof v === 'bigint' ? v.toString() : v\n        }),\n        this.origin\n      )\n    }\n  }\n\n  /**\n   *  A convenience method for sending and listening to create\n   *  a singular link for fetching data. This is the same as calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event: string, callback: any, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first'\n    }\n\n    const internalCallback = (e: any) => {\n      if (runOnce) {\n        this.off(e.type, internalCallback)\n      }\n\n      callback(e)\n    }\n\n    this.on(event, internalCallback)\n    this.send(event, data)\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function | Promise | string} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   *\n   */\n  respond(event: string, data = {}, runOnce = false) {\n    const bellhop = this //'this' for use inside async function\n    /**\n     * @ignore\n     */\n    const internalCallback = async function (event: any) {\n      if (runOnce) {\n        bellhop.off(event, internalCallback)\n      }\n\n      if (typeof data === 'function') {\n        bellhop.send(event.type, await data())\n      } else {\n        bellhop.send(event.type, data)\n      }\n    }\n    this.on(event, internalCallback)\n  }\n\n  /**\n   * Send either the default log message or the callback provided if debug\n   * is enabled\n   * @method logDebugMessage\n   */\n  logDebugMessage(received = false, message: any) {\n    if (this.debug && typeof this.debug === 'function') {\n      console.log({ isChild: this.isChild, received, message: message })\n    } else if (this.debug) {\n      console.log(\n        `Bellhop Instance (${this.isChild ? 'Child' : 'Parent'}) ${received ? 'Received' : 'Sent'}`,\n        message\n      )\n    }\n  }\n\n  /**\n   *  Destroy and don't use after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy()\n    this.disconnect()\n    this._sendLater.length = 0\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe?.contentWindow\n  }\n}\n"],"mappings":"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","names":["Bellhop","BellhopEventDispatcher","id","message","data","err","i","type","iframe","origin","_","v","event","callback","runOnce","internalCallback","e","bellhop","received"]}