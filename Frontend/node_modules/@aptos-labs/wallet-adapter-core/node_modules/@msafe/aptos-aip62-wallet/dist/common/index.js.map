{"version":3,"sources":["../../src/index.ts","../../src/BellhopEventDispatcher.ts","../../src/Bellhop.ts"],"names":["AccountAddress","Ed25519PublicKey","Hex","Network","Serializer","SigningScheme","APTOS_CHAINS","AccountInfo","UserResponseStatus","BellhopEventDispatcher","name","callback","priority","a","b","index","event","data","i","Bellhop","id","message","err","type","iframe","origin","_","v","runOnce","internalCallback","e","bellhop","received","MSafeWalletName","inMSafeWallet","MSafeWalletAccount","address","MSafeWalletServer","api","input","result","MSafeWallet","config","accountInfo","transaction","asFeePayer","listener","network","appId","appUrl","url","options","simpleTransaction","serializer","content","resolve"],"mappings":"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","sourcesContent":["import {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyRawTransaction,\n  Ed25519PublicKey,\n  Hex,\n  InputGenerateTransactionOptions,\n  InputSubmitTransactionData,\n  Network,\n  PendingTransactionResponse,\n  Serializer,\n  SigningScheme,\n  SimpleTransaction\n} from '@aptos-labs/ts-sdk'\nimport {\n  InputTransactionData,\n  Types,\n  Wallet,\n  WalletName,\n  WalletReadyState\n} from '@aptos-labs/wallet-adapter-core'\nimport {\n  APTOS_CHAINS,\n  AccountInfo,\n  AptosChangeNetworkMethod,\n  AptosConnectMethod,\n  AptosConnectOutput,\n  AptosDisconnectMethod,\n  AptosFeatures,\n  AptosGetAccountMethod,\n  AptosGetNetworkMethod,\n  AptosOnAccountChangeInput,\n  AptosOnAccountChangeMethod,\n  AptosOnNetworkChangeInput,\n  AptosOnNetworkChangeMethod,\n  AptosSignAndSubmitTransactionInput,\n  AptosSignAndSubmitTransactionOutput,\n  AptosSignMessageInput,\n  AptosSignMessageMethod,\n  AptosSignMessageOutput,\n  AptosSignTransactionMethod,\n  AptosSignTransactionOutput,\n  AptosWallet,\n  AptosWalletAccount,\n  IdentifierArray,\n  NetworkInfo,\n  UserResponse,\n  UserResponseStatus\n} from '@aptos-labs/wallet-standard'\nimport { Bellhop } from './Bellhop'\n\nexport const MSafeWalletName = 'MSafe' as WalletName<'MSafe'>\n\nexport function inMSafeWallet(): boolean {\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined' &&\n    typeof parent !== 'undefined' &&\n    typeof parent.window !== 'undefined' &&\n    parent.window !== window\n  )\n}\n\nexport interface ConnectResponse {\n  address: string\n}\n\nexport interface MSafeWalletServerApi {\n  connect: () => Promise<string>\n  signTransaction: AptosSignTransactionMethod\n  signMessage: AptosSignMessageMethod\n  signAndSubmitTransaction: (\n    transaction:\n      | Types.TransactionPayload\n      | InputTransactionData\n      | AnyRawTransaction\n      | AptosSignAndSubmitTransactionInput,\n    options?: InputGenerateTransactionOptions\n  ) => Promise<UserResponse<AptosSignAndSubmitTransactionOutput>>\n  submitTransaction(transaction: InputSubmitTransactionData): Promise<PendingTransactionResponse>\n}\n\nexport class MSafeWalletAccount implements AptosWalletAccount {\n  address: string\n  publicKey: Uint8Array\n  chains: IdentifierArray = APTOS_CHAINS\n  features: IdentifierArray = []\n  signingScheme: SigningScheme\n  label?: string\n  icon?:\n    | `data:image/svg+xml;base64,${string}`\n    | `data:image/webp;base64,${string}`\n    | `data:image/png;base64,${string}`\n    | `data:image/gif;base64,${string}`\n    | undefined\n  constructor(address: AccountAddress) {\n    this.address = address.toString()\n    this.publicKey = new Uint8Array()\n    this.chains = APTOS_CHAINS\n    this.signingScheme = SigningScheme.MultiEd25519\n  }\n}\n\nexport class MSafeWalletServer {\n  private bellhop = new Bellhop()\n\n  constructor(private iframe: HTMLIFrameElement, private api: MSafeWalletServerApi) {}\n\n  connect() {\n    this.bellhop.connect(this.iframe)\n\n    this.bellhop.on('connect', async () => {\n      const address = await this.api.connect()\n      console.log('ðŸš€ ~ MSafeWalletServer ~ on ~ connect:', address)\n      this.bellhop.respond('connectResponse', { address })\n    })\n\n    this.bellhop.on('signMessage', async (input: any) => {\n      const result = await this.api.signMessage(input)\n      console.log('ðŸš€ ~ MSafeWalletServer ~ on ~ signMessage:', result)\n      this.bellhop.respond('signMessageResponse', result)\n    })\n\n    this.bellhop.on('signTransaction', async (input: any) => {\n      const result = await this.api.signTransaction(input)\n      console.log('ðŸš€ ~ MSafeWalletServer ~ on ~ signTransaction:', result)\n      this.bellhop.respond('signTransactionResponse', result)\n    })\n\n    this.bellhop.on('submitTransaction', async (input: any) => {\n      const result = await this.api.submitTransaction(input)\n      console.log('ðŸš€ ~ MSafeWalletServer ~ on ~ submitTransaction:', result)\n      this.bellhop.respond('submitTransactionResponse', result)\n    })\n\n    this.bellhop.on('signAndSubmitTransaction', async (input: any) => {\n      const result = await this.api.signAndSubmitTransaction(input)\n      console.log('ðŸš€ ~ MSafeWalletServer ~ on ~ signAndSubmitTransaction:', result)\n      this.bellhop.respond('signAndSubmitTransactionResponse', result)\n    })\n  }\n\n  disconnect() {\n    console.log('ðŸš€ ~ MSafeWalletServer ~ disconnect:')\n    this.bellhop.disconnect()\n  }\n\n  changeAccount(address: string) {\n    console.log('ðŸš€ ~ MSafeWalletServer ~ changeAccount:', address)\n    this.bellhop.send('changeAccount', { address })\n  }\n}\n\nexport interface MSafeConfig {\n  network: Network\n  appId?: string // for registered app id\n  appUrl?: string // app url\n}\n\n/**\n * For 3rd party dApp\n */\nexport class MSafeWallet implements AptosWallet, Wallet {\n  readonly url: string\n  readonly isAIP62Standard = true\n  readonly version = '1.0.0'\n  readonly name = MSafeWalletName\n  readonly providerName = MSafeWalletName\n  readonly provider = null\n  // readonly readyState: WalletReadyState\n  readonly icon =\n    'data:image/png;base64,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'\n  chains = APTOS_CHAINS\n  accounts: MSafeWalletAccount[] = []\n  onAccountChangeInput?: AptosOnAccountChangeInput\n  onNetworkChangeInput?: AptosOnNetworkChangeInput\n\n  private bellhop = new Bellhop()\n\n  get features(): AptosFeatures {\n    return {\n      'aptos:connect': {\n        version: '1.0.0',\n        connect: this.connect\n      },\n      'aptos:network': {\n        version: '1.0.0',\n        network: this.network\n      },\n      'aptos:disconnect': {\n        version: '1.0.0',\n        disconnect: this.disconnect\n      },\n      'aptos:signTransaction': {\n        version: '1.0.0',\n        signTransaction: this.signTransaction\n      },\n      'aptos:signAndSubmitTransaction': {\n        // @ts-ignore\n        version: '1.0.0',\n        signAndSubmitTransaction: this.signAndSubmitTransaction\n      },\n      'aptos:signMessage': {\n        version: '1.0.0',\n        signMessage: this.signMessage\n      },\n      'aptos:onAccountChange': {\n        version: '1.0.0',\n        onAccountChange: this.onAccountChange\n      },\n      'aptos:onNetworkChange': {\n        version: '1.0.0',\n        onNetworkChange: this.onNetworkChange\n      },\n      'aptos:account': {\n        version: '1.0.0',\n        account: this.account\n      }\n    }\n  }\n\n  constructor(private config: MSafeConfig) {\n    const { network, appId, appUrl } = this.config\n\n    let url = 'https://aptos-testnet.m-safe.io/'\n\n    if (network !== Network.TESTNET) {\n      url = 'https://aptos.m-safe.io/'\n    }\n\n    if (appId) {\n      this.url = `${url}/store/${appId}`\n    } else {\n      this.url = `${url}/store/0?url=${appUrl}`\n    }\n\n    // this.readyState = inMSafeWallet() ? WalletReadyState.Installed : WalletReadyState.NotDetected\n\n    this.bellhop.connect()\n\n    this.bellhop.on('changeAccount', async (input: any) => {\n      console.log('ðŸš€ ~ MSafeWallet ~ on ~ changeAccount:', input, this.onAccountChangeInput)\n      if (this.onAccountChangeInput) {\n        const address = input.data.address\n        this.onAccountChangeInput(\n          new AccountInfo({\n            address: AccountAddress.fromString(address),\n            publicKey: new Ed25519PublicKey(address)\n          })\n        )\n      }\n    })\n  }\n  deeplinkProvider?: ((data: { url: string }) => string) | undefined\n  openInMobileApp?: (() => void) | undefined\n  changeNetwork?: AptosChangeNetworkMethod | undefined\n\n  account: AptosGetAccountMethod = async (): Promise<AccountInfo> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ AptosGetAccountMethod:')\n    return this.getCurrentAccountInfo()\n  }\n\n  connect: AptosConnectMethod = async (): Promise<UserResponse<AptosConnectOutput>> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ AptosConnectMethod:')\n    return this.getCurrentAccountInfo().then((accountInfo) => {\n      return {\n        status: UserResponseStatus.APPROVED,\n        args: accountInfo\n      }\n    })\n  }\n\n  network: AptosGetNetworkMethod = async (): Promise<NetworkInfo> => {\n    return {\n      name: this.config.network,\n      chainId: this.config.network === Network.MAINNET ? 1 : 2\n    }\n  }\n\n  disconnect: AptosDisconnectMethod = async (): Promise<void> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ disconnect:')\n    return Promise.resolve()\n  }\n\n  signMessage: AptosSignMessageMethod = async (\n    input: AptosSignMessageInput\n  ): Promise<UserResponse<AptosSignMessageOutput>> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ signMessage:')\n    this.bellhop.send('signMessage', input)\n    return this.fetch<UserResponse<AptosSignMessageOutput>>('signMessageResponse')\n  }\n\n  signTransaction: AptosSignTransactionMethod = async (\n    transaction: AnyRawTransaction,\n    asFeePayer?: boolean\n  ): Promise<UserResponse<AccountAuthenticator>> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ signTransaction:')\n    this.bellhop.send('signTransaction', { transaction, asFeePayer })\n    return this.fetch<UserResponse<AptosSignTransactionOutput>>('signTransactionResponse')\n  }\n\n  async submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> {\n    console.log('ðŸš€ ~ MSafeWallet ~ submitTransaction:')\n    this.bellhop.send('submitTransaction', { transaction })\n    return this.fetch<PendingTransactionResponse>('submitTransactionResponse')\n  }\n\n  async signAndSubmitTransaction(\n    transaction:\n      | Types.TransactionPayload\n      | InputTransactionData\n      | AnyRawTransaction\n      | AptosSignAndSubmitTransactionInput,\n    options?: InputGenerateTransactionOptions\n  ): Promise<UserResponse<AptosSignAndSubmitTransactionOutput>> {\n    console.log('ðŸš€ ~ MSafeWallet ~ signAndSubmitTransaction:', transaction)\n\n    if (transaction.rawTransaction) {\n      const simpleTransaction: SimpleTransaction = transaction\n      const serializer = new Serializer()\n      simpleTransaction.rawTransaction.serialize(serializer)\n      const content = Hex.fromHexInput(serializer.toUint8Array()).toString()\n      this.bellhop.send('signAndSubmitTransaction', { transaction, options, content })\n    } else {\n      this.bellhop.send('signAndSubmitTransaction', { transaction, options })\n    }\n\n    const response = await this.fetch<UserResponse<AptosSignAndSubmitTransactionOutput>>(\n      'signAndSubmitTransactionResponse'\n    )\n    return response\n  }\n\n  onAccountChange: AptosOnAccountChangeMethod = async (listener): Promise<void> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ onAccountChange ~ listener:', listener)\n    this.onAccountChangeInput = listener\n  }\n\n  onNetworkChange: AptosOnNetworkChangeMethod = async (listener): Promise<void> => {\n    console.log('ðŸš€ ~ MSafeWallet ~ onNetworkChange ~ listener:', listener)\n    this.onNetworkChangeInput = listener\n  }\n\n  private async getCurrentAccountInfo(): Promise<AccountInfo> {\n    this.bellhop.send('connect')\n    const { address } = await this.fetch<{ address: string }>('connectResponse')\n    console.log('ðŸš€ ~ MSafeWallet ~ getCurrentAccountInfo ~ address:', address)\n    return new AccountInfo({\n      address: AccountAddress.fromString(address),\n      publicKey: new Ed25519PublicKey(address)\n    })\n  }\n\n  private async fetch<T>(name: string) {\n    return new Promise<T>((resolve) => {\n      this.bellhop.fetch(name, (data: any) => {\n        resolve(data.data)\n      })\n    })\n  }\n}\n","export interface PriorityFunction extends Function {\n  _priority: number\n}\n\n/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  private _listeners: any = {}\n\n  /**\n   *  Add an event listener to listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen for\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name: string, callback: any, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = []\n    }\n    callback._priority = priority\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return\n    }\n\n    this._listeners[name].push(callback)\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter)\n    }\n  }\n\n  /**\n   *  Sorts listeners added by .on() by priority\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   */\n  listenerSorter(a: PriorityFunction, b: PriorityFunction) {\n    return a._priority - b._priority\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name: string, callback: Function) {\n    if (this._listeners[name] === undefined) {\n      return\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name]\n      return\n    }\n\n    const index = this._listeners[name].indexOf(callback)\n\n    ;-1 < index ? this._listeners[name].splice(index, 1) : undefined\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event: any, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      }\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event)\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {}\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js'\n\n/**\n *  Abstract communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  private id: string\n  private connected: boolean\n  private connecting: boolean\n  private isChild: boolean\n  private debug: boolean\n  private supported: boolean\n  private origin: string\n  private _sendLater: any[]\n  private iframe: HTMLIFrameElement | null\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super()\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`\n    /**\n     *  If we are connected to another instance of bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true\n\n    /**\n     *  If we are currently trying to connect\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false\n\n    /**\n     * If debug mode is turned on\n     *  @property {Boolean} debug\n     *  @default false\n     *  @private\n     */\n    this.debug = false\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*'\n\n    this.supported = false\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = []\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this)\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message: MessageEvent) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return\n    }\n\n    this.logDebugMessage(true, message)\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data)\n        } catch (err) {\n          console.warn('Bellhop error: ', err)\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data)\n      }\n      return\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data)\n  }\n  /**\n   * Handle the initial connected message\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message: object) {\n    this.connecting = false\n    this.connected = true\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      // Timing issue: this.iframe.contentWindow is null when parent closes child iframe before done with rendering\n      if (!this.target) {\n        return\n      }\n      this.target.postMessage(message, this.origin)\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i]\n      this.send(type, data)\n    }\n    this._sendLater.length = 0\n\n    // If there is a connection event assigned call it\n    this.trigger('connected')\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe?: HTMLIFrameElement, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect()\n\n    // We are trying to connect\n    this.connecting = true\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined\n\n    this.supported = true\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = (window as any) != iframe\n    }\n\n    this.origin = origin\n\n    window.addEventListener('message', this.receive)\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed')\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target?.postMessage('connected', this.origin)\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false\n    this.connecting = false\n    this.origin = ''\n    this.iframe = null\n    this.isChild = true\n    this._sendLater.length = 0\n\n    window.removeEventListener('message', this.receive)\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type: string, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string'\n    }\n\n    const message = {\n      type,\n      data\n    }\n\n    this.logDebugMessage(false, message)\n\n    if (this.connecting) {\n      this._sendLater.push(message)\n    } else {\n      this.target?.postMessage(\n        JSON.stringify(message, (_, v) => {\n          return typeof v === 'bigint' ? v.toString() : v\n        }),\n        this.origin\n      )\n    }\n  }\n\n  /**\n   *  A convenience method for sending and listening to create\n   *  a singular link for fetching data. This is the same as calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event: string, callback: any, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first'\n    }\n\n    const internalCallback = (e: any) => {\n      if (runOnce) {\n        this.off(e.type, internalCallback)\n      }\n\n      callback(e)\n    }\n\n    this.on(event, internalCallback)\n    this.send(event, data)\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function | Promise | string} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   *\n   */\n  respond(event: string, data = {}, runOnce = false) {\n    const bellhop = this //'this' for use inside async function\n    /**\n     * @ignore\n     */\n    const internalCallback = async function (event: any) {\n      if (runOnce) {\n        bellhop.off(event, internalCallback)\n      }\n\n      if (typeof data === 'function') {\n        bellhop.send(event.type, await data())\n      } else {\n        bellhop.send(event.type, data)\n      }\n    }\n    this.on(event, internalCallback)\n  }\n\n  /**\n   * Send either the default log message or the callback provided if debug\n   * is enabled\n   * @method logDebugMessage\n   */\n  logDebugMessage(received = false, message: any) {\n    if (this.debug && typeof this.debug === 'function') {\n      console.log({ isChild: this.isChild, received, message: message })\n    } else if (this.debug) {\n      console.log(\n        `Bellhop Instance (${this.isChild ? 'Child' : 'Parent'}) ${received ? 'Received' : 'Sent'}`,\n        message\n      )\n    }\n  }\n\n  /**\n   *  Destroy and don't use after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy()\n    this.disconnect()\n    this._sendLater.length = 0\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe?.contentWindow\n  }\n}\n"]}