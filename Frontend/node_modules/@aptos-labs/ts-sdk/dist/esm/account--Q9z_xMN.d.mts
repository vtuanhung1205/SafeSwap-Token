import { TokenStandard, OrderBy } from './types/indexer.mjs';
import { Network } from './utils/apiEndpoints.mjs';
import { AptosApiType } from './utils/const.mjs';
import { ParsingResult } from './core/common.mjs';

/**
 * Provides reasons for parsing failures related to hexadecimal values.
 * @group Implementation
 * @category Serialization
 */
declare enum HexInvalidReason {
    TOO_SHORT = "too_short",
    INVALID_LENGTH = "invalid_length",
    INVALID_HEX_CHARS = "invalid_hex_chars"
}
/**
 * NOTE: Do not use this class when working with account addresses; use AccountAddress instead.
 * When accepting hex data as input to a function, prefer to accept HexInput and
 *
 * A helper class for working with hex data. Hex data, when represented as a string,
 * generally looks like this, for example: 0xaabbcc, 45cd32, etc.
 *
 * then use the static helper methods of this class to convert it into the desired
 * format. This enables the greatest flexibility for the developer.
 *
 * Example usage:
 * ```typescript
 * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {
 *   const txnHashString = Hex.fromHexInput(txnHash).toString();
 *   return await getTransactionByHashInner(txnHashString);
 * }
 * ```
 * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string
 * with a leading 0x prefix, regardless of what the input format was.
 *
 * Other ways to chain the functions together:
 * - `Hex.fromHexString({ hexInput: "0x1f" }).toUint8Array()`
 * - `new Hex([1, 3]).toStringWithoutPrefix()`
 * @group Implementation
 * @category Serialization
 */
declare class Hex {
    private readonly data;
    /**
     * Create a new Hex instance from a Uint8Array.
     *
     * @param data - The Uint8Array containing the data to initialize the Hex instance.
     * @group Implementation
     * @category Serialization
     */
    constructor(data: Uint8Array);
    /**
     * Get the inner hex data as a Uint8Array. The inner data is already a Uint8Array, so no conversion takes place.
     *
     * @returns Hex data as Uint8Array
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the hex data as a string without the 0x prefix.
     *
     * @returns Hex string without 0x prefix
     * @group Implementation
     * @category Serialization
     */
    toStringWithoutPrefix(): string;
    /**
     * Get the hex data as a string with the 0x prefix.
     *
     * @returns Hex string with 0x prefix
     * @group Implementation
     * @category Serialization
     */
    toString(): string;
    /**
     * Converts a hex string into a Hex instance, allowing for both prefixed and non-prefixed formats.
     *
     * @param str - A hex string, with or without the 0x prefix.
     *
     * @throws ParsingError - If the hex string is too short, has an odd number of characters, or contains invalid hex characters.
     *
     * @returns Hex - The resulting Hex instance created from the provided string.
     * @group Implementation
     * @category Serialization
     */
    static fromHexString(str: string): Hex;
    /**
     * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Hex instance.
     * This function is useful for transforming hexadecimal representations into a structured Hex object for further manipulation.
     *
     * @param hexInput - A HexInput which can be a string or Uint8Array.
     * @returns A Hex instance created from the provided hexInput.
     * @group Implementation
     * @category Serialization
     */
    static fromHexInput(hexInput: HexInput): Hex;
    /**
     * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Uint8Array.
     *
     * @param hexInput - A HexInput which can be a string or Uint8Array.
     * @returns A Uint8Array created from the provided hexInput.
     */
    static hexInputToUint8Array(hexInput: HexInput): Uint8Array;
    /**
     * Converts a HexInput (string or Uint8Array) to a hex string with '0x' prefix.
     *
     * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array
     * @returns A hex string with '0x' prefix (e.g., "0x1234")
     *
     * @example
     * ```typescript
     * Hex.hexInputToString("1234")        // returns "0x1234"
     * Hex.hexInputToString("0x1234")      // returns "0x1234"
     * Hex.hexInputToString(new Uint8Array([0x12, 0x34])) // returns "0x1234"
     * ```
     */
    static hexInputToString(hexInput: HexInput): string;
    /**
     * Converts a HexInput (string or Uint8Array) to a hex string without '0x' prefix.
     *
     * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array
     * @returns A hex string without '0x' prefix (e.g., "1234")
     *
     * @example
     * ```typescript
     * Hex.hexInputToStringWithoutPrefix("1234")        // returns "1234"
     * Hex.hexInputToStringWithoutPrefix("0x1234")      // returns "1234"
     * Hex.hexInputToStringWithoutPrefix(new Uint8Array([0x12, 0x34])) // returns "1234"
     * ```
     */
    static hexInputToStringWithoutPrefix(hexInput: HexInput): string;
    /**
     * Check if the provided string is a valid hexadecimal representation.
     *
     * @param str - A hex string representing byte data.
     *
     * @returns An object containing:
     *  - valid: A boolean indicating whether the string is valid.
     *  - invalidReason: The reason for invalidity if the string is not valid.
     *  - invalidReasonMessage: A message explaining why the string is invalid.
     * @group Implementation
     * @category Serialization
     */
    static isValid(str: string): ParsingResult<HexInvalidReason>;
    /**
     * Determine if two Hex instances are equal by comparing their underlying byte data.
     *
     * @param other The Hex instance to compare to.
     * @returns true if the Hex instances are equal, false if not.
     * @group Implementation
     * @category Serialization
     */
    equals(other: Hex): boolean;
}
declare const hexToAsciiString: (hex: string) => string;

/**
 * This class serves as a base class for all serializable types. It facilitates
 * composable serialization of complex types and enables the serialization of
 * instances to their BCS (Binary Canonical Serialization) representation.
 * @group Implementation
 * @category BCS
 */
declare abstract class Serializable {
    abstract serialize(serializer: Serializer): void;
    /**
     * Serializes a `Serializable` value to its BCS representation.
     * This function is the TypeScript SDK equivalent of `bcs::to_bytes` in Move.
     * @returns the BCS representation of the Serializable instance as a byte buffer.
     * @group Implementation
     * @category BCS
     */
    bcsToBytes(): Uint8Array;
    /**
     * Converts the BCS-serialized bytes of a value into a Hex instance.
     * This function provides a Hex representation of the BCS-serialized data for easier handling and manipulation.
     * @returns A Hex instance with the BCS-serialized bytes loaded into its underlying Uint8Array.
     * @group Implementation
     * @category BCS
     */
    bcsToHex(): Hex;
    /**
     * Returns the hex string representation of the `Serializable` value without the 0x prefix.
     * @returns the hex format as a string without `0x` prefix.
     */
    toStringWithoutPrefix(): string;
    /**
     * Returns the hex string representation of the `Serializable` value with the 0x prefix.
     * @returns the hex formatas a string prefixed by `0x`.
     */
    toString(): string;
}
/**
 * A class for serializing various data types into a binary format.
 * It provides methods to serialize strings, bytes, numbers, and other serializable objects
 * using the Binary Coded Serialization (BCS) layout. The serialized data can be retrieved as a
 * Uint8Array.
 * @group Implementation
 * @category BCS
 */
declare class Serializer {
    private buffer;
    private offset;
    /**
     * Constructs a serializer with a buffer of size `length` bytes, 64 bytes by default.
     * The `length` must be greater than 0.
     *
     * @param length - The size of the buffer in bytes.
     * @group Implementation
     * @category BCS
     */
    constructor(length?: number);
    /**
     * Ensures that the internal buffer can accommodate the specified number of bytes.
     * This function dynamically resizes the buffer if the current size is insufficient.
     *
     * @param bytes - The number of bytes to ensure the buffer can handle.
     * @group Implementation
     * @category BCS
     */
    private ensureBufferWillHandleSize;
    /**
     * Appends the specified values to the buffer, ensuring that the buffer can accommodate the new data.
     *
     * @param {Uint8Array} values - The values to be appended to the buffer.
     * @group Implementation
     * @category BCS
     */
    protected appendToBuffer(values: Uint8Array): void;
    /**
     * Serializes a value into the buffer using the provided function, ensuring the buffer can accommodate the size.
     *
     * @param fn - The function to serialize the value, which takes a byte offset, the value to serialize, and an optional little-endian flag.
     * @param fn.byteOffset - The byte offset at which to write the value.
     * @param fn.value - The numeric value to serialize into the buffer.
     * @param fn.littleEndian - Optional flag indicating whether to use little-endian byte order (defaults to true).
     * @group Implementation
     * @category BCS
     */
    private serializeWithFunction;
    /**
     * Serializes a string. UTF8 string is supported.
     * The number of bytes in the string content is serialized first, as a uleb128-encoded u32 integer.
     * Then the string content is serialized as UTF8 encoded bytes.
     *
     * BCS layout for "string": string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     *
     * @param value - The string to serialize.
     *
     * @example
     * ```typescript
     * const serializer = new Serializer();
     * serializer.serializeStr("1234abcd");
     * assert(serializer.toUint8Array() === new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * ```
     * @group Implementation
     * @category BCS
     */
    serializeStr(value: string): void;
    /**
     * Serializes an array of bytes.
     *
     * This function encodes the length of the byte array as a u32 integer in uleb128 format, followed by the byte array itself.
     * BCS layout for "bytes": bytes_length | bytes
     * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.
     * @param value - The byte array to serialize.
     * @group Implementation
     * @category BCS
     */
    serializeBytes(value: Uint8Array): void;
    /**
     * Serializes an array of bytes with a known length, allowing for efficient deserialization without needing to serialize the
     * length itself.
     * When deserializing, the number of bytes to deserialize needs to be passed in.
  
     * @param value - The Uint8Array to be serialized.
     * @group Implementation
     * @category BCS
     */
    serializeFixedBytes(value: Uint8Array): void;
    /**
     * Serializes a boolean value into a byte representation.
     *
     * The BCS layout for a boolean uses one byte, where "0x01" represents true and "0x00" represents false.
     *
     * @param value - The boolean value to serialize.
     * @group Implementation
     * @category BCS
     */
    serializeBool(value: boolean): void;
    /**
     * Serializes a Uint8 value and appends it to the buffer.
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     *
     * @param value - The Uint8 value to serialize.
     * @group Implementation
     * @category BCS
     */
    serializeU8(value: Uint8): void;
    /**
     * Serializes a uint16 number.
     *
     * @group Implementation
     * @category BCS
  
     */
    /**
     * Serializes a 16-bit unsigned integer value into a binary format.
     * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
     *
     * @param value - The 16-bit unsigned integer value to serialize.
     * @example
     * ```typescript
     * const serializer = new Serializer();
     * serializer.serializeU16(4660);
     * assert(serializer.toUint8Array() === new Uint8Array([0x34, 0x12]));
     * ```
     * @group Implementation
     * @category BCS
     */
    serializeU16(value: Uint16): void;
    /**
     * Serializes a 32-bit unsigned integer value into a binary format.
     * This function is useful for encoding data that needs to be stored or transmitted in a compact form.
     * @example
     * ```typescript
     * const serializer = new Serializer();
     * serializer.serializeU32(305419896);
     * assert(serializer.toUint8Array() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * ```
     * @param value - The 32-bit unsigned integer value to serialize.
     * @group Implementation
     * @category BCS
     */
    serializeU32(value: Uint32): void;
    /**
     * Serializes a 64-bit unsigned integer into a format suitable for storage or transmission.
     * This function breaks down the value into two 32-bit components and writes them in little-endian order.
     *
     * @param value - The 64-bit unsigned integer to serialize, represented as a number.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU64(1311768467750121216);
     * assert(serializer.toUint8Array() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * ```
     * @group Implementation
     * @category BCS
     */
    serializeU64(value: AnyNumber): void;
    /**
     * Serializes a U128 value into a format suitable for storage or transmission.
     *
     * @param value - The U128 value to serialize, represented as a number.
     * @group Implementation
     * @category BCS
     */
    serializeU128(value: AnyNumber): void;
    /**
     * Serializes a U256 value into a byte representation.
     * This function is essential for encoding large numbers in a compact format suitable for transmission or storage.
     *
     * @param value - The U256 value to serialize, represented as an AnyNumber.
     * @group Implementation
     * @category BCS
     */
    serializeU256(value: AnyNumber): void;
    /**
     * Serializes a 32-bit unsigned integer as a variable-length ULEB128 encoded byte array.
     * BCS uses uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
     *
     * @param val - The 32-bit unsigned integer value to be serialized.
     * @group Implementation
     * @category BCS
     */
    serializeU32AsUleb128(val: Uint32): void;
    /**
     * Returns the buffered bytes as a Uint8Array.
     *
     * This function allows you to retrieve the byte representation of the buffer up to the current offset.
     *
     * @returns Uint8Array - The byte array representation of the buffer.
     * @group Implementation
     * @category BCS
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes a `Serializable` value, facilitating composable serialization.
     *
     * @param value The Serializable value to serialize.
     *
     * @returns the serializer instance
     * @group Implementation
     * @category BCS
     */
    serialize<T extends Serializable>(value: T): void;
    /**
     * Serializes an array of BCS Serializable values to a serializer instance.
     * The bytes are added to the serializer instance's byte buffer.
     *
     * @param values The array of BCS Serializable values
     * @example
     * const addresses = new Array<AccountAddress>(
     *   AccountAddress.from("0x1"),
     *   AccountAddress.from("0x2"),
     *   AccountAddress.from("0xa"),
     *   AccountAddress.from("0xb"),
     * );
     * const serializer = new Serializer();
     * serializer.serializeVector(addresses);
     * const serializedBytes = serializer.toUint8Array();
     * // serializedBytes is now the BCS-serialized bytes
     * // The equivalent value in Move would be:
     * // `bcs::to_bytes(&vector<address> [@0x1, @0x2, @0xa, @0xb])`;
     * @group Implementation
     * @category BCS
     */
    serializeVector<T extends Serializable>(values: Array<T>): void;
    /**
     * Serializes an optional value which can be a Serializable, string, or Uint8Array.
     * For strings and Uint8Arrays, it uses the appropriate serialization method.
     *
     * @param value The value to serialize (Serializable, string, Uint8Array, or undefined)
     * @param len Optional fixed length for Uint8Array serialization. If provided, uses serializeFixedBytes instead of serializeBytes
     *
     * @example
     * ```typescript
     * const serializer = new Serializer();
     * serializer.serializeOption("hello");  // Serializes optional string
     * serializer.serializeOption(new Uint8Array([1, 2, 3]));  // Serializes optional bytes
     * serializer.serializeOption(new Uint8Array([1, 2, 3]), 3);  // Serializes optional fixed-length bytes
     * serializer.serializeOption(new AccountAddress(...));  // Serializes optional Serializable
     * serializer.serializeOption(undefined);  // Serializes none case
     * ```
     * @group Implementation
     * @category BCS
     */
    serializeOption<T extends Serializable | string | Uint8Array>(value?: T, len?: number): void;
    /**
     * @deprecated use `serializeOption` instead.
     * Serializes an optional string, supporting UTF8 encoding.
     * The function encodes the existence of the string first, followed by the length and content if it exists.
     *
     * BCS layout for optional "string": 1 | string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     * BCS layout for undefined: 0
     *
     * @param value - The optional string to serialize. If undefined, it will serialize as 0.
     * @group Implementation
     * @category BCS
     */
    serializeOptionStr(value?: string): void;
}
/**
 * @group Implementation
 * @category BCS
 */
declare function ensureBoolean(value: unknown): asserts value is boolean;
/**
 * @group Implementation
 * @category BCS
 */
declare const outOfRangeErrorMessage: (value: AnyNumber, min: AnyNumber, max: AnyNumber) => string;
/**
 * Validates that a given number is within a specified range.
 * This function throws an error if the value is outside the defined minimum and maximum bounds.
 *
 * @param value - The number to validate.
 * @param minValue - The minimum allowable value (inclusive).
 * @param maxValue - The maximum allowable value (inclusive).
 * @group Implementation
 * @category BCS
 */
declare function validateNumberInRange<T extends AnyNumber>(value: T, minValue: T, maxValue: T): void;

interface TransactionArgument extends EntryFunctionArgument, ScriptFunctionArgument {
}
/**
 * Represents an argument for entry functions, providing methods to serialize the argument
 * to BCS-serialized bytes and convert it to different formats.
 * @group Implementation
 * @category Transactions
 */
interface EntryFunctionArgument {
    /**
     * Serialize an argument to BCS-serialized bytes.
     *
     * @param serializer - The serializer instance used for serialization.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Serialize an argument to BCS-serialized bytes.
     * Serialize an argument as a type-agnostic, fixed byte sequence. The byte sequence contains
     * the number of the following bytes followed by the BCS-serialized bytes for a typed argument.
     *
     * @param serializer - The serializer used to convert the argument.
     * @group Implementation
     * @category Transactions
     */
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * Convert the argument to BCS-serialized bytes.
     *
     * @returns Uint8Array representing the BCS-serialized bytes of the argument.
     * @group Implementation
     * @category Transactions
     */
    bcsToBytes(): Uint8Array;
    /**
     * Converts the BCS-serialized bytes of an argument into a hexadecimal representation.
     * This function is useful for obtaining a Hex instance that encapsulates the BCS-serialized bytes,
     * allowing for easier manipulation and representation of the data.
     * @returns A Hex instance containing the BCS-serialized bytes.
     * @group Implementation
     * @category Transactions
     */
    bcsToHex(): Hex;
}
/**
 * Represents an argument for script functions, providing methods to serialize and convert to bytes.
 * @group Implementation
 * @category Transactions
 */
interface ScriptFunctionArgument {
    /**
     * Serialize an argument to BCS-serialized bytes.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Serialize an argument to BCS-serialized bytes as a type aware byte sequence.
     * The byte sequence contains an enum variant index followed by the BCS-serialized
     * bytes for a typed argument.
     * @group Implementation
     * @category Transactions
     */
    serializeForScriptFunction(serializer: Serializer): void;
    bcsToBytes(): Uint8Array;
    bcsToHex(): Hex;
}

/**
 * Provides reasons for an address was invalid.
 * @group Implementation
 * @category Serialization
 */
declare enum AddressInvalidReason {
    INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes",
    INVALID_HEX_CHARS = "invalid_hex_chars",
    TOO_SHORT = "too_short",
    TOO_LONG = "too_long",
    LEADING_ZERO_X_REQUIRED = "leading_zero_x_required",
    LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special",
    INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES",
    INVALID_PADDING_STRICTNESS = "INVALID_PADDING_STRICTNESS"
}
/**
 * The input for an account address, which can be either a hexadecimal string or a standard account address.
 * @group Implementation
 * @category Serialization
 */
type AccountAddressInput = HexInput | AccountAddress;
/**
 * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction
 * hashes, use the Hex class.
 *
 * AccountAddress is used for working with account addresses. Account addresses, when
 * represented as a string, generally look like these examples:
 * - 0x1
 * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c
 *
 * Proper formatting and parsing of account addresses is defined by AIP-40.
 * To learn more about the standard, read the AIP here:
 * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
 *
 * The comments in this class make frequent reference to the LONG and SHORT formats,
 * as well as "special" addresses. To learn what these refer to see AIP-40.
 * @group Implementation
 * @category Serialization
 */
declare class AccountAddress extends Serializable implements TransactionArgument {
    /**
     * This is the internal representation of an account address.
     * @group Implementation
     * @category Serialization
     */
    readonly data: Uint8Array;
    /**
     * The number of bytes that make up an account address.
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH: number;
    /**
     * The length of an address string in LONG form without a leading 0x.
     * @group Implementation
     * @category Serialization
     */
    static readonly LONG_STRING_LENGTH: number;
    static ZERO: AccountAddress;
    static ONE: AccountAddress;
    static TWO: AccountAddress;
    static THREE: AccountAddress;
    static FOUR: AccountAddress;
    static A: AccountAddress;
    /**
     * Creates an instance of AccountAddress from a Uint8Array.
     *
     * This function ensures that the input data is exactly 32 bytes long, which is required for a valid account address.
     *
     * @param input A Uint8Array representing an account address.
     * @throws ParsingError if the input length is not equal to 32 bytes.
     * @group Implementation
     * @category Serialization
     */
    constructor(input: Uint8Array);
    /**
     * Determines if the address is classified as special, which is defined as 0x0 to 0xf inclusive.
     * In other words, the last byte of the address must be < 0b10000 (16)
     * and every other byte must be zero.
     *
     * For more information on how special addresses are defined, see AIP-40:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @returns true if the address is special, false otherwise.
     * @group Implementation
     * @category Serialization
     */
    isSpecial(): boolean;
    /**
     * Return the AccountAddress as a string as per AIP-40.
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     * This representation returns special addresses in SHORT form (0xf)
     * and other addresses in LONG form (0x + 64 characters).
     *
     * @returns AccountAddress as a string conforming to AIP-40.
     * @group Implementation
     * @category Serialization
     */
    toString(): `0x${string}`;
    /**
     * Return the AccountAddress as a string conforming to AIP-40 but without the leading 0x.
     *
     * NOTE: Prefer to use `toString` where possible.
     *
     * @returns AccountAddress as a string without the leading 0x.
     * @group Implementation
     * @category Serialization
     */
    toStringWithoutPrefix(): string;
    /**
     * Convert the account address to a string in LONG format, which is always 0x followed by 64 hex characters.
     *
     * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).
     *
     * @returns AccountAddress as a string in LONG form.
     * @group Implementation
     * @category Serialization
     */
    toStringLong(): `0x${string}`;
    /**
     * Returns the account address as a string in LONG form without a leading 0x.
     * This function will include leading zeroes and will produce a string of 64 hex characters.
     *
     * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).
     *
     * @returns {string} The account address in LONG form.
     * @group Implementation
     * @category Serialization
     */
    toStringLongWithoutPrefix(): string;
    /**
     * Convert the account address to a string in SHORT format, which is 0x followed by the shortest
     * possible representation (no leading zeros).
     *
     * @returns AccountAddress as a string in SHORT form.
     * @group Implementation
     * @category Serialization
     */
    toStringShort(): `0x${string}`;
    /**
     * Returns a lossless short string representation of the address by trimming leading zeros.
     * If the address consists of all zeros, returns "0".
     *
     * @returns A string representation of the address without leading zeros
     * @group Implementation
     * @category Serialization
     */
    toStringShortWithoutPrefix(): string;
    /**
     * Get the inner data as a Uint8Array.
     * The inner data is already a Uint8Array, so no conversion takes place.
     *
     * @returns Hex data as Uint8Array
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Serialize the AccountAddress to a Serializer instance's data buffer.
     * @param serializer The serializer to serialize the AccountAddress to.
     * @returns void
     * @example
     * const serializer = new Serializer();
     * const address = AccountAddress.fromString("0x1");
     * address.serialize(serializer);
     * const bytes = serializer.toUint8Array();
     * // `bytes` is now the BCS-serialized address.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Serializes the current instance into a byte sequence suitable for entry functions.
     * This allows for the proper encoding of data when interacting with entry functions in the blockchain.
     *
     * @param serializer - The serializer instance used to convert the data into bytes.
     * @group Implementation
     * @category Serialization
     */
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * Serializes the current instance for use in a script function by encoding it into a byte sequence.
     * This process involves serializing the variant index and the instance data, making it suitable for transmission.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Serialization
     */
    serializeForScriptFunction(serializer: Serializer): void;
    /**
     * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.
     * This function allows you to convert a byte representation of an AccountAddress into an instance of AccountAddress.
     * @param deserializer The deserializer to deserialize the AccountAddress from.
     * @returns An instance of AccountAddress.
     * @example
     * const bytes = hexToBytes("0x0102030405060708091011121314151617181920212223242526272829303132");
     * const deserializer = new Deserializer(bytes);
     * const address = AccountAddress.deserialize(deserializer);
     * // `address` is now an instance of AccountAddress.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): AccountAddress;
    /**
     * NOTE: This function has strict parsing behavior. For relaxed behavior, please use
     * the `fromString` function.
     *
     * Creates an instance of AccountAddress from a hex string.
     *
     * This function allows only the strictest formats defined by AIP-40. In short this
     * means only the following formats are accepted:
     *
     * - LONG
     * - SHORT for special addresses
     *
     * Where:
     * - LONG is defined as 0x + 64 hex characters.
     * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.
     *
     * This means the following are not accepted:
     * - SHORT for non-special addresses.
     * - Any address without a leading 0x.
     *
     * @param input - A hex string representing an account address.
     *
     * @throws {ParsingError} If the hex string does not start with 0x or is not in a valid format.
     *
     * @remarks
     *
     * This function has strict parsing behavior. For relaxed behavior, please use the `fromString` function.
     *
     * @see AIP-40 documentation for more details on address formats:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @returns An instance of AccountAddress.
     * @group Implementation
     * @category Serialization
     */
    static fromStringStrict(input: string): AccountAddress;
    /**
     * NOTE: This function has relaxed parsing behavior. For strict behavior, please use
     * the `fromStringStrict` function. Where possible use `fromStringStrict` rather than this
     * function, `fromString`.
     *
     * Creates an instance of AccountAddress from a hex string.
     *
     * This function allows all formats defined by AIP-40. In short this means the
     * following formats are accepted:
     *
     * - LONG, with or without leading 0x
     * - SHORT*, with or without leading 0x
     *
     * Where:
     * - LONG is 64 hex characters.
     * - SHORT* is 1 to 63 hex characters inclusive. The address can have missing values up to `maxMissingChars` before it is padded.
     * - Padding zeroes are allowed, e.g. 0x0123 is valid.
     *
     * Learn more about the different address formats by reading AIP-40:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @param input A hex string representing an account address.
     * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.
     *
     * @returns An instance of AccountAddress.
     *
     * @throws ParsingError if the hex string is too short, too long, or contains invalid characters.
     * @group Implementation
     * @category Serialization
     */
    static fromString(input: string, { maxMissingChars }?: {
        maxMissingChars?: number;
    }): AccountAddress;
    /**
     * Convenience method for creating an AccountAddress from various input types.
     * This function accepts a string, Uint8Array, or an existing AccountAddress instance and returns the corresponding
     * AccountAddress.
     *
     * @param input - The input to convert into an AccountAddress. This can be a string representation of an address, a Uint8Array,
     * or an existing AccountAddress.
     * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.
     * @group Implementation
     * @category Serialization
     */
    static from(input: AccountAddressInput, { maxMissingChars }?: {
        maxMissingChars?: number;
    }): AccountAddress;
    /**
     * Create an AccountAddress from various input types, including strings, Uint8Array, and AccountAddress instances.
     *
     * @param input - The input to convert into an AccountAddress, which can be a string, a Uint8Array, or an AccountAddress.
     * @group Implementation
     * @category Serialization
     */
    static fromStrict(input: AccountAddressInput): AccountAddress;
    /**
     * Check if the provided input is a valid AccountAddress.
     *
     * @param args - The arguments for validation.
     * @param args.input - A hex string representing an account address.
     * @param args.strict - If true, use strict parsing behavior; if false, use relaxed parsing behavior.
     *
     * @returns An object indicating whether the address is valid. If valid, valid = true; if not, valid = false with additional details.
     * If the address is invalid, invalidReason will explain why it is invalid, and invalidReasonMessage will provide the error message.
     * @group Implementation
     * @category Serialization
     */
    static isValid(args: {
        input: AccountAddressInput;
        strict?: boolean;
    }): ParsingResult<AddressInvalidReason>;
    /**
     * Determine if two AccountAddresses are equal based on their underlying byte data.
     *
     * @param other - The AccountAddress to compare to.
     * @returns true if the AccountAddresses are equal, false if not.
     * @group Implementation
     * @category Serialization
     */
    equals(other: AccountAddress): boolean;
}

/**
 * An abstract representation of a crypto signature,
 * associated with a specific signature scheme, e.g., Ed25519 or Secp256k1.
 *
 * This class represents the product of signing a message directly from a
 * PrivateKey and can be verified against a CryptoPublicKey.
 * @group Implementation
 * @category Serialization
 */
declare abstract class Signature extends Serializable {
    /**
     * Get the raw signature bytes
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the signature as a hex string with a 0x prefix e.g. 0x123456...
     * @returns The hex string representation of the signature.
     * @group Implementation
     * @category Serialization
     */
    toString(): string;
}

/**
 * Represents the arguments required to verify a digital signature.
 *
 * @param message - The original message that was signed.
 * @param signature - The signature to be verified against the message.
 * @group Implementation
 * @category Serialization
 */
interface VerifySignatureArgs {
    message: HexInput;
    signature: Signature;
}
/**
 * Represents the arguments required to verify a digital signature asynchronously.
 *
 * The validity of certain types of signatures are dependent on network state.  This is the case for
 * Keyless signatures which need to lookup the verification key and keyless configuration.
 *
 * @param aptosConfig - The Aptos configuration to use
 * @param message - The original message that was signed.
 * @param signature - The signature to be verified against the message.
 * @group Implementation
 * @category Serialization
 */
type VerifySignatureAsyncArgs = VerifySignatureArgs & {
    aptosConfig: AptosConfig;
    options?: any;
};
/**
 * Represents an abstract public key.
 *
 * This class provides a common interface for verifying signatures associated with the public key.
 * It allows for the retrieval of the raw public key bytes and the public key in a hexadecimal string format.
 * @group Implementation
 * @category Serialization
 */
declare abstract class PublicKey extends Serializable {
    /**
     * Verifies that the private key associated with this public key signed the message with the given signature.
     * @param args.message The message that was signed
     * @param args.signature The signature to verify
     * @group Implementation
     * @category Serialization
     */
    abstract verifySignature(args: VerifySignatureArgs): boolean;
    /**
     * Verifies signature with the public key and makes any network calls required to get state required to verify the signature.
     * @param args.aptosConfig The Aptos configuration
     * @param args.message The message that was signed
     * @param args.signature The signature to verify
     * @group Implementation
     * @category Serialization
     */
    verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean>;
    /**
     * Get the raw public key bytes
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the public key as a hex string with a 0x prefix.
     *
     * @returns The public key in hex format.
     * @group Implementation
     * @category Serialization
     */
    toString(): string;
}
/**
 * An abstract representation of an account public key.
 *
 * Provides a common interface for deriving an authentication key.
 *
 * @abstract
 * @group Implementation
 * @category Serialization
 */
declare abstract class AccountPublicKey extends PublicKey {
    /**
     * Get the authentication key associated with this public key
     * @group Implementation
     * @category Serialization
     */
    abstract authKey(): AuthenticationKey;
}

/**
 * Represents a private key used for signing messages and deriving the associated public key.
 * @group Implementation
 * @category Serialization
 */
interface PrivateKey {
    /**
     * Sign the given message with the private key to create a signature.
     * @param message - The message to be signed, provided in HexInput format.
     * @returns A Signature object representing the signed message.
     * @group Implementation
     * @category Serialization
     */
    sign(message: HexInput): Signature;
    /**
     * Derive the public key associated with the private key.
     * @group Implementation
     * @category Serialization
     */
    publicKey(): PublicKey;
    /**
     * Get the private key in bytes (Uint8Array).
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
}
declare class PrivateKey {
    /**
     * The AIP-80 compliant prefixes for each private key type. Append this to a private key's hex representation
     * to get an AIP-80 compliant string.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     */
    static readonly AIP80_PREFIXES: {
        ed25519: string;
        secp256k1: string;
    };
    /**
     * Format a HexInput to an AIP-80 compliant string.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @param privateKey - The HexString or Uint8Array format of the private key.
     * @param privateKeyType - The private key type
     */
    static formatPrivateKey(privateKey: HexInput, type: PrivateKeyVariants): string;
    /**
     * Parse a HexInput that may be a HexString, Uint8Array, or a AIP-80 compliant string to a Hex instance.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @param value - A HexString, Uint8Array, or a AIP-80 compliant string.
     * @param privateKeyType - The private key type
     * @param strict - If true, the value MUST be compliant with AIP-80.
     */
    static parseHexInput(value: HexInput, type: PrivateKeyVariants, strict?: boolean): Hex;
}

/**
 * Checks if an ED25519 signature is non-canonical.
 * This function helps determine the validity of a signature by verifying its canonical form.
 *
 * @param signature - The signature to be checked for canonicality.
 * @returns A boolean indicating whether the signature is non-canonical.
 *
 * Comes from Aptos Core
 * https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-crypto/src/ed25519/ed25519_sigs.rs#L47-L85
 * @group Implementation
 * @category Serialization
 */
declare function isCanonicalEd25519Signature(signature: Signature): boolean;
/**
 * Represents the public key of an Ed25519 key pair.
 *
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports
 * `Legacy` and `Unified` authentication keys.
 *
 * Ed25519 scheme is represented in the SDK as `Legacy authentication key` and also
 * as `AnyPublicKey` that represents any `Unified authentication key`.
 * @group Implementation
 * @category Serialization
 */
declare class Ed25519PublicKey extends AccountPublicKey {
    /**
     * Length of an Ed25519 public key
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH: number;
    /**
     * Bytes of the public key
     * @private
     * @group Implementation
     * @category Serialization
     */
    private readonly key;
    /**
     * Creates an instance of the Ed25519Signature class from a hex input.
     * This constructor validates the length of the signature to ensure it meets the required specifications.
     *
     * @param hexInput - The hex input representing the Ed25519 signature.
     * @throws Error if the signature length is not equal to Ed25519Signature.LENGTH.
     * @group Implementation
     * @category Serialization
     */
    constructor(hexInput: HexInput);
    /**
     * Verifies a signed message using a public key.
     *
     * @param args - The arguments for verification.
     * @param args.message - A signed message as a Hex string or Uint8Array.
     * @param args.signature - The signature of the message.
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: VerifySignatureArgs): boolean;
    /**
     * Note: Ed25519Signatures can be verified syncronously.
     *
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.
     *
     * @param args - The arguments for signature verification.
     * @param args.aptosConfig - The configuration object for connecting to the Aptos network
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.
     * @returns A boolean indicating whether the signature is valid for the given message.
     * @group Implementation
     * @category Serialization
     */
    verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean>;
    /**
     * Generates an authentication key from the public key using the Ed25519 scheme.
     * This function is essential for creating a secure authentication key that can be used for further cryptographic operations.
     *
     * @returns {AuthenticationKey} The generated authentication key.
     * @group Implementation
     * @category Serialization
     */
    authKey(): AuthenticationKey;
    /**
     * Convert the internal data representation to a Uint8Array.
     *
     * @returns Uint8Array representation of the data.
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes the data into a byte array using the provided serializer.
     * This allows for the conversion of data into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserialize bytes into an Ed25519Signature object.
     * This function is used to convert serialized byte data into a usable Ed25519Signature instance.
     *
     * @param deserializer - The deserializer instance used to read the byte data.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): Ed25519PublicKey;
    /**
     * Determine if the provided public key is an instance of Ed25519PublicKey.
     *
     * @param publicKey - The public key to check.
     * @returns True if the public key is an instance of Ed25519PublicKey, otherwise false.
     * @deprecated use `instanceof Ed25519PublicKey` instead.
     * @group Implementation
     * @category Serialization
     */
    static isPublicKey(publicKey: AccountPublicKey): publicKey is Ed25519PublicKey;
    /**
     * Determines if the provided public key is a valid Ed25519 public key.
     * This function checks for the presence of the "key" property and verifies that its data length matches the expected length
     * for Ed25519 public keys.
     *
     * @param publicKey - The public key to validate.
     * @returns A boolean indicating whether the public key is a valid Ed25519 public key.
     * @group Implementation
     * @category Serialization
     */
    static isInstance(publicKey: PublicKey): publicKey is Ed25519PublicKey;
}
/**
 * Represents the private key of an Ed25519 key pair.
 * @group Implementation
 * @category Serialization
 */
declare class Ed25519PrivateKey extends Serializable implements PrivateKey {
    /**
     * Length of an Ed25519 private key
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH: number;
    /**
     * The Ed25519 key seed to use for BIP-32 compatibility
     * See more {@link https://github.com/satoshilabs/slips/blob/master/slip-0010.md}
     * @group Implementation
     * @category Serialization
     */
    static readonly SLIP_0010_SEED = "ed25519 seed";
    /**
     * The Ed25519 signing key
     * @private
     * @group Implementation
     * @category Serialization
     */
    private readonly signingKey;
    /**
     * Create a new PrivateKey instance from a Uint8Array or String.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @param hexInput HexInput (string or Uint8Array)
     * @param strict If true, private key must AIP-80 compliant.
     * @group Implementation
     * @category Serialization
     */
    constructor(hexInput: HexInput, strict?: boolean);
    /**
     * Generate a new random private key.
     *
     * @returns Ed25519PrivateKey A newly generated Ed25519 private key.
     * @group Implementation
     * @category Serialization
     */
    static generate(): Ed25519PrivateKey;
    /**
     * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.
     * To derive multiple keys from the same phrase, change the path
     *
     * IMPORTANT: Ed25519 supports hardened derivation only, as it lacks a key homomorphism, making non-hardened derivation impossible.
     *
     * @param path - The BIP44 path used for key derivation.
     * @param mnemonics - The mnemonic seed phrase from which the key will be derived.
     * @throws Error if the provided path is not a valid hardened path.
     * @group Implementation
     * @category Serialization
     */
    static fromDerivationPath(path: string, mnemonics: string): Ed25519PrivateKey;
    /**
     * Derives a child private key from a given BIP44 path and seed.
     * A private inner function so we can separate from the main fromDerivationPath() method
     * to add tests to verify we create the keys correctly.
     *
     * @param path - The BIP44 path used for key derivation.
     * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.
     * @param offset - The offset used for key derivation, defaults to HARDENED_OFFSET.
     * @returns An instance of Ed25519PrivateKey derived from the specified path and seed.
     * @group Implementation
     * @category Serialization
     */
    private static fromDerivationPathInner;
    /**
     * Derive the Ed25519PublicKey for this private key.
     *
     * @returns Ed25519PublicKey - The derived public key corresponding to the private key.
     * @group Implementation
     * @category Serialization
     */
    publicKey(): Ed25519PublicKey;
    /**
     * Sign the given message with the private key.
     * This function generates a digital signature for the specified message, ensuring its authenticity and integrity.
     *
     * @param message - A message as a string or Uint8Array in HexInput format.
     * @returns A digital signature for the provided message.
     * @group Implementation
     * @category Serialization
     */
    sign(message: HexInput): Ed25519Signature;
    /**
     * Get the private key in bytes (Uint8Array).
     *
     * @returns Uint8Array representation of the private key
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the private key as a hex string with the 0x prefix.
     *
     * @returns string representation of the private key.
     * @group Implementation
     * @category Serialization
     */
    toString(): string;
    /**
     * Get the private key as a hex string with the 0x prefix.
     *
     * @returns string representation of the private key.
     */
    toHexString(): string;
    /**
     * Get the private key as a AIP-80 compliant hex string.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @returns AIP-80 compliant string representation of the private key.
     */
    toAIP80String(): string;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Ed25519PrivateKey;
    /**
     * Determines if the provided private key is an instance of Ed25519PrivateKey.
     *
     * @param privateKey - The private key to check.
     * @returns A boolean indicating whether the private key is an Ed25519PrivateKey.
     *
     * @deprecated Use `instanceof Ed25519PrivateKey` instead.
     * @group Implementation
     * @category Serialization
     */
    static isPrivateKey(privateKey: PrivateKey): privateKey is Ed25519PrivateKey;
}
/**
 * Represents a signature of a message signed using an Ed25519 private key.
 * @group Implementation
 * @category Serialization
 */
declare class Ed25519Signature extends Signature {
    /**
     * Length of an Ed25519 signature, which is 64 bytes.
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH = 64;
    /**
     * The signature bytes
     * @private
     * @group Implementation
     * @category Serialization
     */
    private readonly data;
    constructor(hexInput: HexInput);
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Ed25519Signature;
}

/**
 * Represents the configuration settings for an Aptos SDK client instance.
 * This class allows customization of various endpoints and client settings.
 *
 * @example
 * ```typescript
 * import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";
 *
 * async function runExample() {
 *     // Create a configuration for connecting to the Aptos testnet
 *     const config = new AptosConfig({ network: Network.TESTNET });
 *
 *     // Initialize the Aptos client with the configuration
 *     const aptos = new Aptos(config);
 *
 *     console.log("Aptos client initialized:", aptos);
 * }
 * runExample().catch(console.error);
 * ```
 * @group Client
 */
declare class AptosConfig {
    /**
     * The Network that this SDK is associated with. Defaults to DEVNET
     * @group Client
     */
    readonly network: Network;
    /**
     * The client instance the SDK uses. Defaults to `@aptos-labs/aptos-client
     * @group Client
     */
    readonly client: Client;
    /**
     * The optional hardcoded fullnode URL to send requests to instead of using the network
     * @group Client
     */
    readonly fullnode?: string;
    /**
     * The optional hardcoded faucet URL to send requests to instead of using the network
     * @group Client
     */
    readonly faucet?: string;
    /**
     * The optional hardcoded pepper service URL to send requests to instead of using the network
     * @group Client
     */
    readonly pepper?: string;
    /**
     * The optional hardcoded prover service URL to send requests to instead of using the network
     * @group Client
     */
    readonly prover?: string;
    /**
     * The optional hardcoded indexer URL to send requests to instead of using the network
     * @group Client
     */
    readonly indexer?: string;
    /**
     * Optional client configurations
     * @group Client
     */
    readonly clientConfig?: ClientConfig;
    /**
     * Optional specific Fullnode configurations
     * @group Client
     */
    readonly fullnodeConfig?: FullNodeConfig;
    /**
     * Optional specific Indexer configurations
     * @group Client
     */
    readonly indexerConfig?: IndexerConfig;
    /**
     * Optional specific Faucet configurations
     * @group Client
     */
    readonly faucetConfig?: FaucetConfig;
    /**
     * Optional specific Transaction Generation configurations
     * @group Client
     */
    readonly transactionGenerationConfig?: TransactionGenerationConfig;
    /**
     * Optional plugin config to override client behavior.
     * @group Client
     */
    private pluginConfig?;
    /**
     * Initializes an instance of the Aptos client with the specified settings.
     * This allows users to configure various aspects of the client, such as network and endpoints.
     *
     * @param settings - Optional configuration settings for the Aptos client.
     * @param settings.network - The network to connect to, defaults to `Network.DEVNET`.
     * @param settings.fullnode - The fullnode endpoint to use for requests.
     * @param settings.faucet - The faucet endpoint for obtaining test tokens.
     * @param settings.pepper - The pepper used for transaction signing.
     * @param settings.prover - The prover endpoint for transaction verification.
     * @param settings.indexer - The indexer endpoint for querying blockchain data.
     * @param settings.client - Custom client settings, defaults to a standard Aptos client.
     * @param settings.clientConfig - Additional configuration for the client.
     * @param settings.fullnodeConfig - Additional configuration for the fullnode.
     * @param settings.indexerConfig - Additional configuration for the indexer.
     * @param settings.faucetConfig - Additional configuration for the faucet.
     *
     * @example
     * ```typescript
     * import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";
     *
     * async function runExample() {
     *     // Create a new Aptos client with default settings
     *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network
     *     const aptos = new Aptos(config);
     *
     *     console.log("Aptos client initialized:", aptos);
     * }
     * runExample().catch(console.error);
     * ```
     * @group Client
     */
    constructor(settings?: AptosSettings);
    /**
     * Returns the URL endpoint to send the request to based on the specified API type.
     * If a custom URL was provided in the configuration, that URL is returned. Otherwise, the URL endpoint is derived from the network.
     *
     * @param apiType - The type of Aptos API to get the URL for. This can be one of the following: FULLNODE, FAUCET, INDEXER, PEPPER, PROVER.
     *
     * @example
     * ```typescript
     * import { Aptos, AptosConfig, Network, AptosApiType } from "@aptos-labs/ts-sdk";
     *
     * const config = new AptosConfig({ network: Network.TESTNET });
     * const aptos = new Aptos(config);
     *
     * async function runExample() {
     *   // Getting the request URL for the FULLNODE API
     *   const url = config.getRequestUrl(AptosApiType.FULLNODE);
     *   console.log("Request URL for FULLNODE:", url);
     * }
     * runExample().catch(console.error);
     * ```
     * @group Client
     */
    getRequestUrl(apiType: AptosApiType): string;
    /**
     * Checks if the provided URL is a known pepper service endpoint.
     *
     * @param url - The URL to check against the known pepper service endpoints.
     *
     * @example
     * ```typescript
     * import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";
     *
     * const config = new AptosConfig({ network: Network.TESTNET });
     * const aptos = new Aptos(config);
     *
     * async function runExample() {
     *     const url = "https://example.pepper.service"; // replace with a real pepper service URL
     *
     *     // Check if the URL is a known pepper service endpoint
     *     const isPepperService = config.isPepperServiceRequest(url);
     *
     *     console.log(`Is the URL a known pepper service? ${isPepperService}`);
     * }
     * runExample().catch(console.error);
     * ```
     * @group Client
     */
    isPepperServiceRequest(url: string): boolean;
    /**
     * Checks if the provided URL is a known prover service endpoint.
     *
     * @param url - The URL to check against known prover service endpoints.
     * @returns A boolean indicating whether the URL is a known prover service endpoint.
     *
     * @example
     * ```typescript
     * import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";
     *
     * const config = new AptosConfig({ network: Network.TESTNET });
     * const aptos = new Aptos(config);
     *
     * // Check if the URL is a known prover service endpoint
     * const url = "https://prover.testnet.aptos.dev"; // replace with a real URL if needed
     * const isProver = config.isProverServiceRequest(url);
     *
     * console.log(`Is the URL a known prover service? ${isProver}`);
     * ```
     * @group Client
     */
    isProverServiceRequest(url: string): boolean;
    getDefaultMaxGasAmount(): number;
    getDefaultTxnExpirySecFromNow(): number;
    /**
     * If you have set a custom transaction submitter, you can use this to determine
     * whether to use it or not. For example, to stop using the transaction submitter:
     *
     * @example
     * ```
     * aptos.config.setIgnoreTransactionSubmitter(true);
     * ```
     *
     * @group Client
     */
    setIgnoreTransactionSubmitter(ignore: boolean): void;
    /**
     * If a custom transaction submitter has been specified in the PluginConfig and
     * IGNORE_TRANSACTION_SUBMITTER is false, this will return a transaction submitter
     * that should be used instead of the default transaction submission behavior.
     */
    getTransactionSubmitter(): TransactionSubmitter | undefined;
}

/**
 * Represents a Secp256k1 ECDSA public key.
 *
 * @extends PublicKey
 * @property LENGTH - The length of the Secp256k1 public key in bytes.
 * @group Implementation
 * @category Serialization
 */
declare class Secp256k1PublicKey extends PublicKey {
    static readonly LENGTH: number;
    static readonly COMPRESSED_LENGTH: number;
    private readonly key;
    /**
     * Create a new PublicKey instance from a HexInput, which can be a string or Uint8Array.
     * This constructor validates the length of the provided signature data.
     *
     * @param hexInput - A HexInput (string or Uint8Array) representing the signature data.
     * @throws Error if the length of the signature data is not equal to Secp256k1Signature.LENGTH.
     * @group Implementation
     * @category Serialization
     */
    constructor(hexInput: HexInput);
    /**
     * Verifies a Secp256k1 signature against the public key.
     *
     * This function checks the validity of a signature for a given message, ensuring that the signature is canonical as a malleability check.
     *
     * @param args - The arguments for verifying the signature.
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify against the public key.
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: {
        message: HexInput;
        signature: Secp256k1Signature;
    }): boolean;
    /**
     * Note: Secp256k1Signatures can be verified syncronously.
     *
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.
     *
     * @param args - The arguments for signature verification.
     * @param args.aptosConfig - The configuration object for connecting to the Aptos network
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.
     * @returns A boolean indicating whether the signature is valid for the given message.
     * @group Implementation
     * @category Serialization
     */
    verifySignatureAsync(args: {
        aptosConfig: AptosConfig;
        message: HexInput;
        signature: Secp256k1Signature;
    }): Promise<boolean>;
    /**
     * Get the data as a Uint8Array representation.
     *
     * @returns Uint8Array representation of the data.
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes the data into a byte array using the provided serializer.
     * This function is essential for converting data into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to convert the data.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a Secp256k1Signature from the provided deserializer.
     * This function allows you to reconstruct a Secp256k1Signature object from its serialized byte representation.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Serialization
     */
    deserialize(deserializer: Deserializer): Secp256k1Signature;
    static deserialize(deserializer: Deserializer): Secp256k1PublicKey;
    /**
     * Determine if the provided public key is an instance of Secp256k1PublicKey.
     *
     * @deprecated use `instanceof Secp256k1PublicKey` instead
     * @param publicKey - The public key to check.
     * @group Implementation
     * @category Serialization
     */
    static isPublicKey(publicKey: PublicKey): publicKey is Secp256k1PublicKey;
    /**
     * Determines if the provided public key is a valid instance of a Secp256k1 public key.
     * This function checks for the presence of a "key" property and validates the length of the key data.
     *
     * @param publicKey - The public key to validate.
     * @returns A boolean indicating whether the public key is a valid Secp256k1 public key.
     * @group Implementation
     * @category Serialization
     */
    static isInstance(publicKey: PublicKey): publicKey is Secp256k1PublicKey;
}
/**
 * Represents a Secp256k1 ECDSA private key, providing functionality to create, sign messages,
 * derive public keys, and serialize/deserialize the key.
 * @group Implementation
 * @category Serialization
 */
declare class Secp256k1PrivateKey extends Serializable implements PrivateKey {
    /**
     * Length of Secp256k1 ecdsa private key
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH: number;
    /**
     * The private key bytes
     * @private
     * @group Implementation
     * @category Serialization
     */
    private readonly key;
    /**
     * Create a new PrivateKey instance from a Uint8Array or String.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @param hexInput A HexInput (string or Uint8Array)
     * @param strict If true, private key must AIP-80 compliant.
     * @group Implementation
     * @category Serialization
     */
    constructor(hexInput: HexInput, strict?: boolean);
    /**
     * Generate a new random private key.
     *
     * @returns Secp256k1PrivateKey - A newly generated Secp256k1 private key.
     * @group Implementation
     * @category Serialization
     */
    static generate(): Secp256k1PrivateKey;
    /**
     * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.
     *
     * @param path - The BIP44 path to derive the key from.
     * @param mnemonics - The mnemonic seed phrase used for key generation.
     *
     * @returns The generated private key.
     *
     * @throws Error if the provided path is not a valid BIP44 path.
     * @group Implementation
     * @category Serialization
     */
    static fromDerivationPath(path: string, mnemonics: string): Secp256k1PrivateKey;
    /**
     * Derives a private key from a specified BIP44 path using a given seed.
     * This function is essential for generating keys that follow the hierarchical deterministic (HD) wallet structure.
     *
     * @param path - The BIP44 path used for key derivation.
     * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.
     * @returns The generated private key as an instance of Secp256k1PrivateKey.
     * @throws Error if the derived private key is invalid.
     * @group Implementation
     * @category Serialization
     */
    private static fromDerivationPathInner;
    /**
     * Sign the given message with the private key.
     * This function generates a cryptographic signature for the provided message, ensuring the signature is canonical and non-malleable.
     *
     * @param message - A message in HexInput format to be signed.
     * @returns Signature - The generated signature for the provided message.
     * @group Implementation
     * @category Serialization
     */
    sign(message: HexInput): Secp256k1Signature;
    /**
     * Derive the Secp256k1PublicKey from this private key.
     *
     * @returns Secp256k1PublicKey The derived public key.
     * @group Implementation
     * @category Serialization
     */
    publicKey(): Secp256k1PublicKey;
    /**
     * Get the private key in bytes (Uint8Array).
     *
     * @returns
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the private key as a string representation.
     *
     * @returns string representation of the private key
     * @group Implementation
     * @category Serialization
     */
    toString(): string;
    /**
     * Get the private key as a hex string with the 0x prefix.
     *
     * @returns string representation of the private key.
     */
    toHexString(): string;
    /**
     * Get the private key as a AIP-80 compliant hex string.
     *
     * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)
     *
     * @returns AIP-80 compliant string representation of the private key.
     */
    toAIP80String(): string;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Secp256k1PrivateKey;
    /**
     * Determines if the provided private key is an instance of Secp256k1PrivateKey.
     *
     * @param privateKey - The private key to be checked.
     *
     * @deprecated use `instanceof Secp256k1PrivateKey` instead
     * @group Implementation
     * @category Serialization
     */
    static isPrivateKey(privateKey: PrivateKey): privateKey is Secp256k1PrivateKey;
}
/**
 * Represents a signature of a message signed using a Secp256k1 ECDSA private key.
 *
 * @group Implementation
 * @category Serialization
 */
declare class Secp256k1Signature extends Signature {
    /**
     * Secp256k1 ecdsa signatures are 256-bit.
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH = 64;
    /**
     * The signature bytes
     * @private
     * @group Implementation
     * @category Serialization
     */
    private readonly data;
    /**
     * Create a new Signature instance from a Uint8Array or String.
     *
     * @param hexInput A HexInput (string or Uint8Array)
     * @group Implementation
     * @category Serialization
     */
    constructor(hexInput: HexInput);
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Secp256k1Signature;
}

type PrivateKeyInput = Ed25519PrivateKey | Secp256k1PrivateKey;
/**
 * Represents any public key supported by Aptos.
 *
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports
 * `Legacy` and `Unified` authentication keys.
 *
 * Any unified authentication key is represented in the SDK as `AnyPublicKey`.
 * @group Implementation
 * @category Serialization
 */
declare class AnyPublicKey extends AccountPublicKey {
    /**
     * Reference to the inner public key
     * @group Implementation
     * @category Serialization
     */
    readonly publicKey: PublicKey;
    /**
     * Index of the underlying enum variant
     * @group Implementation
     * @category Serialization
     */
    readonly variant: AnyPublicKeyVariant;
    /**
     * Creates an instance of the signature class based on the provided signature type.
     * This allows for the handling of different signature variants such as Ed25519, Secp256k1, and Keyless.
     *
     * @param publicKey - The publicKey object which determines the variant to be used.
     * @throws Error if the provided signature type is unsupported.
     * @group Implementation
     * @category Serialization
     */
    constructor(publicKey: PublicKey);
    /**
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.
     *
     * @param args - The arguments for signature verification.
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify, which must be an instance of AnySignature.
     * @returns A boolean indicating whether the signature is valid for the given message.
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: {
        message: HexInput;
        signature: AnySignature;
    }): boolean;
    /**
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.
     *
     * @param args - The arguments for signature verification.
     * @param args.aptosConfig - The configuration object for connecting to the Aptos network
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify, which must be an instance of AnySignature.
     * @returns A boolean indicating whether the signature is valid for the given message.
     * @group Implementation
     * @category Serialization
     */
    verifySignatureAsync(args: {
        aptosConfig: AptosConfig;
        message: HexInput;
        signature: Signature;
        options?: {
            throwErrorWithReason?: boolean;
        };
    }): Promise<boolean>;
    /**
     * Generates an authentication key from the current instance's byte representation.
     * This function is essential for creating a unique identifier for authentication purposes.
     *
     * @returns {AuthenticationKey} The generated authentication key.
     * @group Implementation
     * @category Serialization
     */
    authKey(): AuthenticationKey;
    /**
     * Get the signature in bytes (Uint8Array).
     *
     * This function is a warning that it will soon return the underlying signature bytes directly.
     * Use AnySignature.bcsToBytes() instead.
     *
     * @returns Uint8Array representation of the signature.
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes the current object using the provided serializer.
     * This function helps in converting the object into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes an AnySignature from the provided deserializer.
     * This function helps in reconstructing the AnySignature object from its serialized form, allowing for further processing or validation.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): AnyPublicKey;
    /**
     * Determines if the provided public key is an instance of AnyPublicKey.
     *
     * @param publicKey - The public key to check.
     * @deprecated Use `instanceof AnyPublicKey` instead.
     * @group Implementation
     * @category Serialization
     */
    static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey;
    /**
     * Determines if the current public key is an instance of Ed25519PublicKey.
     *
     * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.
     * @group Implementation
     * @category Serialization
     */
    isEd25519(): boolean;
    /**
     * Checks if the public key is an instance of Secp256k1PublicKey.
     *
     * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.
     * @group Implementation
     * @category Serialization
     */
    isSecp256k1PublicKey(): boolean;
    /**
     * Determines if the provided publicKey is an instance of a valid PublicKey object.
     *
     * @param publicKey - The publicKey to be checked for validity.
     * @param publicKey.publicKey - The actual publicKey object that needs to be validated.
     * @returns True if the signature is a valid instance; otherwise, false.
     * @group Implementation
     * @category Serialization
     */
    static isInstance(publicKey: PublicKey): publicKey is AnyPublicKey;
}
/**
 * Represents a signature that utilizes the SingleKey authentication scheme.
 * This class is designed to encapsulate various types of signatures, which can
 * only be generated by a `SingleKeySigner` due to the shared authentication mechanism.
 *
 * @extends Signature
 * @group Implementation
 * @category Serialization
 */
declare class AnySignature extends Signature {
    readonly signature: Signature;
    /**
     * Index of the underlying enum variant
     * @group Implementation
     * @category Serialization
     */
    private readonly variant;
    constructor(signature: Signature);
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): AnySignature;
    static isInstance(signature: Signature): signature is AnySignature;
}

declare abstract class AbstractMultiKey extends AccountPublicKey {
    publicKeys: PublicKey[];
    constructor(args: {
        publicKeys: PublicKey[];
    });
    /**
     * Create a bitmap that holds the mapping from the original public keys
     * to the signatures passed in
     *
     * @param args.bits array of the index mapping to the matching public keys
     * @returns Uint8array bit map
     * @group Implementation
     * @category Serialization
     */
    createBitmap(args: {
        bits: number[];
    }): Uint8Array;
    /**
     * Get the index of the provided public key.
     *
     * This function retrieves the index of a specified public key within the MultiKey.
     * If the public key does not exist, it throws an error.
     *
     * @param publicKey - The public key to find the index for.
     * @returns The corresponding index of the public key, if it exists.
     * @throws Error - If the public key is not found in the MultiKey.
     * @group Implementation
     * @category Serialization
     */
    getIndex(publicKey: PublicKey): number;
    abstract getSignaturesRequired(): number;
}
/**
 * Represents a multi-key authentication scheme for accounts, allowing multiple public keys
 * to be associated with a single account. This class enforces a minimum number of valid signatures
 * required to authorize actions, ensuring enhanced security for multi-agent accounts.
 *
 * The public keys of each individual agent can be any type of public key supported by Aptos.
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263), Aptos supports
 * `Legacy` and `Unified` authentication keys.
 * @group Implementation
 * @category Serialization
 */
declare class MultiKey extends AbstractMultiKey {
    /**
     * List of any public keys
     * @group Implementation
     * @category Serialization
     */
    readonly publicKeys: AnyPublicKey[];
    /**
     * The minimum number of valid signatures required, for the number of public keys specified
     * @group Implementation
     * @category Serialization
     */
    readonly signaturesRequired: number;
    /**
     * Signature for a K-of-N multi-sig transaction.
     * This constructor initializes a multi-signature transaction with the provided signatures and bitmap.
     *
     * @param args An object containing the parameters for the multi-signature transaction.
     * @param args.signatures A list of signatures.
     * @param args.bitmap A bitmap represented as a Uint8Array or an array of numbers, where each bit indicates whether a
     * corresponding signature is present. A maximum of 32 signatures is supported, and the length of the bitmap must be 4 bytes.
     *
     * @throws Error if the number of signatures exceeds the maximum supported, if the bitmap length is incorrect, or if the number
     * of signatures does not match the bitmap.
     * @group Implementation
     * @category Serialization
     */
    constructor(args: {
        publicKeys: Array<PublicKey>;
        signaturesRequired: number;
    });
    getSignaturesRequired(): number;
    /**
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.
     *
     * Note: This function will fail if a keyless signature is used.  Use `verifySignatureAsync` instead.
     *
     * @param args - The arguments for verifying the signature.
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify.
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: {
        message: HexInput;
        signature: MultiKeySignature;
    }): boolean;
    /**
     * Verifies the provided signature against the given message.
     * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.
     *
     * @param args - The arguments for verifying the signature.
     * @param args.aptosConfig - The Aptos configuration to use
     * @param args.message - The message that was signed.
     * @param args.signature - The signature to verify.
     * @group Implementation
     * @category Serialization
     */
    verifySignatureAsync(args: {
        aptosConfig: AptosConfig;
        message: HexInput;
        signature: Signature;
        options?: {
            throwErrorWithReason?: boolean;
        };
    }): Promise<boolean>;
    /**
     * Generates an authentication key based on the current instance's byte representation.
     * This key can be used for secure authentication processes within the system.
     *
     * @returns {AuthenticationKey} The generated authentication key.
     * @group Implementation
     * @category Serialization
     */
    authKey(): AuthenticationKey;
    /**
     * Serializes the object by writing its signatures and bitmap to the provided serializer.
     * This allows the object to be converted into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a MultiKeySignature from the provided deserializer.
     * This function retrieves the signatures and bitmap necessary for creating a MultiKeySignature object.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): MultiKey;
    /**
     * Get the index of the provided public key.
     *
     * This function retrieves the index of a specified public key within the MultiKey.
     * If the public key does not exist, it throws an error.
     *
     * @param publicKey - The public key to find the index for.
     * @returns The corresponding index of the public key, if it exists.
     * @throws Error - If the public key is not found in the MultiKey.
     * @group Implementation
     */
    getIndex(publicKey: PublicKey): number;
    static isInstance(value: PublicKey): value is MultiKey;
}
/**
 * Represents a multi-signature transaction using Ed25519 signatures.
 * This class allows for the creation and management of a K-of-N multi-signature scheme,
 * where a specified number of signatures are required to authorize a transaction.
 *
 * It includes functionality to validate the number of signatures against a bitmap,
 * which indicates which public keys have signed the transaction.
 * @group Implementation
 * @category Serialization
 */
declare class MultiKeySignature extends Signature {
    /**
     * Number of bytes in the bitmap representing who signed the transaction (32-bits)
     * @group Implementation
     * @category Serialization
     */
    static BITMAP_LEN: number;
    /**
     * Maximum number of Ed25519 signatures supported
     * @group Implementation
     * @category Serialization
     */
    static MAX_SIGNATURES_SUPPORTED: number;
    /**
     * The list of underlying Ed25519 signatures
     * @group Implementation
     * @category Serialization
     */
    readonly signatures: AnySignature[];
    /**
     * 32-bit Bitmap representing who signed the transaction
     *
     * This is represented where each public key can be masked to determine whether the message was signed by that key.
     * @group Implementation
     * @category Serialization
     */
    readonly bitmap: Uint8Array;
    /**
     * Signature for a K-of-N multi-sig transaction.
     *
     * @see {@link
     * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}
     *
     * @param args.signatures A list of signatures
     * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
     * signature should be provided in `signatures`. Bits are read from left to right
     * @group Implementation
     * @category Serialization
     */
    constructor(args: {
        signatures: Array<Signature | AnySignature>;
        bitmap: Uint8Array | number[];
    });
    /**
     * Helper method to create a bitmap out of the specified bit positions
     * @param args.bits The bitmap positions that should be set. A position starts at index 0.
     * Valid position should range between 0 and 31.
     * @example
     * Here's an example of valid `bits`
     * ```
     * [0, 2, 31]
     * ```
     * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
     * The result bitmap should be 0b1010000000000000000000000000001
     *
     * @returns bitmap that is 32bit long
     * @group Implementation
     * @category Serialization
     */
    static createBitmap(args: {
        bits: number[];
    }): Uint8Array;
    /**
     * Converts the bitmap to an array of signer indices.
     *
     * Example:
     *
     * bitmap: [0b10001000, 0b01000000, 0b00000000, 0b00000000]
     * signerIndices: [0, 4, 9]
     *
     * @returns An array of signer indices.
     * @group Implementation
     * @category Serialization
     */
    bitMapToSignerIndices(): number[];
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiKeySignature;
}

/**
 * Represents the public key of a K-of-N Ed25519 multi-sig transaction.
 *
 * A K-of-N multi-sig transaction requires at least K out of N authorized signers to sign the transaction
 * for it to be executed. This class encapsulates the logic for managing the public keys and the threshold
 * for valid signatures.
 *
 * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}
 * @group Implementation
 * @category Serialization
 */
declare class MultiEd25519PublicKey extends AbstractMultiKey {
    /**
     * Maximum number of public keys supported
     * @group Implementation
     * @category Serialization
     */
    static readonly MAX_KEYS = 32;
    /**
     * Minimum number of public keys needed
     * @group Implementation
     * @category Serialization
     */
    static readonly MIN_KEYS = 2;
    /**
     * Minimum threshold for the number of valid signatures required
     * @group Implementation
     * @category Serialization
     */
    static readonly MIN_THRESHOLD = 1;
    /**
     * List of Ed25519 public keys for this LegacyMultiEd25519PublicKey
     * @group Implementation
     * @category Serialization
     */
    readonly publicKeys: Ed25519PublicKey[];
    /**
     * The minimum number of valid signatures required, for the number of public keys specified
     * @group Implementation
     * @category Serialization
     */
    readonly threshold: number;
    /**
     * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a
     * transaction to be executed, at least K out of the N authorized signers have signed the transaction
     * and passed the check conducted by the chain.
     *
     * @see {@link
     * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}
     * @param args - A wrapper to let you choose the param order.
     * @param args.publicKeys A list of public keys
     * @param args.threshold At least "threshold" signatures must be valid
     * @group Implementation
     * @category Serialization
     */
    constructor(args: {
        publicKeys: Ed25519PublicKey[];
        threshold: number;
    });
    getSignaturesRequired(): number;
    /**
     * Verifies a multi-signature against a given message.
     * This function ensures that the provided signatures meet the required threshold and are valid for the given message.
     *
     * @param args - The arguments for verifying the signature.
     * @param args.message - The message that was signed.
     * @param args.signature - The multi-signature containing multiple signatures and a bitmap indicating which signatures are valid.
     * @returns True if the signature is valid; otherwise, false.
     * @throws Error if the bitmap and signatures length mismatch or if there are not enough valid signatures.
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: {
        message: HexInput;
        signature: Signature;
    }): boolean;
    verifySignatureAsync(args: {
        aptosConfig: AptosConfig;
        message: HexInput;
        signature: Signature;
    }): Promise<boolean>;
    /**
     * Generates an authentication key based on the current instance's byte representation.
     * This function is essential for creating a secure authentication key that can be used for various cryptographic operations.
     *
     * @returns {AuthenticationKey} The generated authentication key.
     * @group Implementation
     * @category Serialization
     */
    authKey(): AuthenticationKey;
    /**
     * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes the current instance into bytes using the provided serializer.
     * This allows for the conversion of the instance's data into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer used to convert the instance into bytes.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a MultiEd25519Signature from the provided deserializer.
     * This function helps in reconstructing a MultiEd25519Signature object from its serialized byte representation.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): MultiEd25519PublicKey;
    /**
     * Deserializes a MultiEd25519Signature from the provided deserializer.
     * This function helps in reconstructing a MultiEd25519Signature object from its serialized byte representation.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Serialization
     */
    static deserializeWithoutLength(deserializer: Deserializer): MultiEd25519PublicKey;
    /**
     * Get the index of the provided public key.
     *
     * This function retrieves the index of a specified public key within the MultiKey.
     * If the public key does not exist, it throws an error.
     *
     * @param publicKey - The public key to find the index for.
     * @returns The corresponding index of the public key, if it exists.
     * @throws Error - If the public key is not found in the MultiKey.
     * @group Implementation
     */
    getIndex(publicKey: Ed25519PublicKey): number;
}
/**
 * Represents the signature of a K-of-N Ed25519 multi-sig transaction.
 *
 * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}
 * @group Implementation
 * @category Serialization
 */
declare class MultiEd25519Signature extends Signature {
    /**
     * Maximum number of Ed25519 signatures supported
     * @group Implementation
     * @category Serialization
     */
    static MAX_SIGNATURES_SUPPORTED: number;
    /**
     * Number of bytes in the bitmap representing who signed the transaction (32-bits)
     * @group Implementation
     * @category Serialization
     */
    static BITMAP_LEN: number;
    /**
     * The list of underlying Ed25519 signatures
     * @group Implementation
     * @category Serialization
     */
    readonly signatures: Ed25519Signature[];
    /**
     * 32-bit Bitmap representing who signed the transaction
     *
     * This is represented where each public key can be masked to determine whether the message was signed by that key.
     * @group Implementation
     * @category Serialization
     */
    readonly bitmap: Uint8Array;
    /**
     * Signature for a K-of-N multi-sig transaction.
     *
     * @see {@link
     * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}
     *
     * @param args.signatures A list of signatures
     * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
     * signature should be provided in `signatures`. Bits are read from left to right.
     * Alternatively, you can specify an array of bitmap positions.
     * Valid position should range between 0 and 31.
     * @see MultiEd25519Signature.createBitmap
     * @group Implementation
     * @category Serialization
     */
    constructor(args: {
        signatures: Ed25519Signature[];
        bitmap: Uint8Array | number[];
    });
    /**
     * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiEd25519Signature;
    /**
     * Helper method to create a bitmap out of the specified bit positions.
     * This function allows you to set specific bits in a 32-bit long bitmap based on the provided positions.
     *
     * @param args The arguments for creating the bitmap.
     * @param args.bits The bitmap positions that should be set. A position starts at index 0. Valid positions should range between 0 and 31.
     *
     * @example
     * Here's an example of valid `bits`
     * ```
     * [0, 2, 31]
     * ```
     * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
     * The result bitmap should be 0b1010000000000000000000000000001
     *
     * @returns bitmap that is 32 bits long.
     * @group Implementation
     * @category Serialization
     */
    static createBitmap(args: {
        bits: number[];
    }): Uint8Array;
}

/**
 * Represents an authentication key used for account management. Each account stores an authentication key that enables account
 * owners to rotate their private key(s) without changing the address that hosts their account. The authentication key is a
 * SHA3-256 hash of data and is always 32 bytes in length.
 *
 * @see {@link https://aptos.dev/concepts/accounts | Account Basics}
 *
 * Account addresses can be derived from the AuthenticationKey.
 * @group Implementation
 * @category Serialization
 */
declare class AuthenticationKey extends Serializable {
    /**
     * An authentication key is always a SHA3-256 hash of data, and is always 32 bytes.
     *
     * The data to hash depends on the underlying public key type and the derivation scheme.
     * @group Implementation
     * @category Serialization
     */
    static readonly LENGTH: number;
    /**
     * The raw bytes of the authentication key.
     * @group Implementation
     * @category Serialization
     */
    readonly data: Hex;
    /**
     * Creates an instance of the AuthenticationKey using the provided hex input.
     * This ensures that the hex input is valid and conforms to the required length for an Authentication Key.
     *
     * @param args - The arguments for constructing the AuthenticationKey.
     * @param args.data - The hex input data to be used for the Authentication Key.
     * @throws {Error} Throws an error if the length of the provided hex input is not equal to the required Authentication Key
     * length.
     * @group Implementation
     * @category Serialization
     */
    constructor(args: {
        data: HexInput;
    });
    /**
     * Serializes the fixed bytes data into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Serialization
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserialize an AuthenticationKey from the byte buffer in a Deserializer instance.
     * @param deserializer - The deserializer to deserialize the AuthenticationKey from.
     * @returns An instance of AuthenticationKey.
     * @group Implementation
     * @category Serialization
     */
    static deserialize(deserializer: Deserializer): AuthenticationKey;
    /**
     * Convert the internal data representation to a Uint8Array.
     *
     * This function is useful for obtaining a byte representation of the data, which can be utilized for serialization or transmission.
     *
     * @returns Uint8Array representation of the internal data.
     * @group Implementation
     * @category Serialization
     */
    toUint8Array(): Uint8Array;
    /**
     * Generates an AuthenticationKey from the specified scheme and input bytes.
     * This function is essential for creating a valid authentication key based on a given scheme.
     *
     * @param args - The arguments for generating the AuthenticationKey.
     * @param args.scheme - The authentication key scheme to use.
     * @param args.input - The input data in hexadecimal format to derive the key.
     * @returns An instance of AuthenticationKey containing the generated key data.
     * @group Implementation
     * @category Serialization
     */
    static fromSchemeAndBytes(args: {
        scheme: AuthenticationKeyScheme;
        input: HexInput;
    }): AuthenticationKey;
    /**
     * Derives an AuthenticationKey from the provided public key using a specified derivation scheme.
     *
     * @deprecated Use `fromPublicKey` instead.
     * @param args - The arguments for deriving the authentication key.
     * @param args.publicKey - The public key used for the derivation.
     * @param args.scheme - The scheme to use for deriving the authentication key.
     * @group Implementation
     * @category Serialization
     */
    static fromPublicKeyAndScheme(args: {
        publicKey: AccountPublicKey;
        scheme: AuthenticationKeyScheme;
    }): AuthenticationKey;
    /**
     * Converts a PublicKey to an AuthenticationKey using the derivation scheme inferred from the provided PublicKey instance.
     *
     * @param args - The arguments for the function.
     * @param args.publicKey - The PublicKey to be converted.
     * @returns AuthenticationKey - The derived AuthenticationKey.
     * @group Implementation
     * @category Serialization
     */
    static fromPublicKey(args: {
        publicKey: AccountPublicKey;
    }): AuthenticationKey;
    /**
     * Derives an account address from an AuthenticationKey by translating the AuthenticationKey bytes directly to an AccountAddress.
     *
     * @returns AccountAddress - The derived account address.
     * @group Implementation
     * @category Serialization
     */
    derivedAddress(): AccountAddress;
}

/**
 * Represents a ChainId that can be serialized and deserialized.
 *
 * @extends Serializable
 * @group Implementation
 * @category Transactions
 */
declare class ChainId extends Serializable {
    readonly chainId: number;
    /**
     * Initializes a new instance of the class with the specified chain ID.
     *
     * @param chainId - The ID of the blockchain network to be used.
     * @group Implementation
     * @category Transactions
     */
    constructor(chainId: number);
    /**
     * Serializes the current object using the provided serializer.
     * This function helps in converting the object into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a ChainId from the provided deserializer.
     * This function allows you to reconstruct a ChainId object from serialized data.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): ChainId;
}

/**
 * Represents an Identifier that can be serialized and deserialized.
 * This class is used to denote the module "name" in "ModuleId" and
 * the "function name" in "EntryFunction".
 *
 * @extends Serializable
 * @group Implementation
 * @category Transactions
 */
declare class Identifier extends Serializable {
    identifier: string;
    /**
     * Creates an instance of the class with a specified identifier.
     *
     * @param identifier - The unique identifier for the instance.
     * @group Implementation
     * @category Transactions
     */
    constructor(identifier: string);
    /**
     * Serializes the identifier of the current instance using the provided serializer.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes an identifier from the provided deserializer.
     * This function is useful for reconstructing an Identifier object from a serialized format.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): Identifier;
}

/**
 * Represents a ModuleId that can be serialized and deserialized.
 * A ModuleId consists of a module address (e.g., "0x1") and a module name (e.g., "coin").
 * @group Implementation
 * @category Transactions
 */
declare class ModuleId extends Serializable {
    readonly address: AccountAddress;
    readonly name: Identifier;
    /**
     * Initializes a new instance of the module with the specified account address and name.
     *
     * @param address - The account address, e.g., "0x1".
     * @param name - The module name under the specified address, e.g., "coin".
     * @group Implementation
     * @category Transactions
     */
    constructor(address: AccountAddress, name: Identifier);
    /**
     * Converts a string literal in the format "account_address::module_name" to a ModuleId.
     * @param moduleId - A string literal representing the module identifier.
     * @throws Error if the provided moduleId is not in the correct format.
     * @returns ModuleId - The corresponding ModuleId object.
     * @group Implementation
     * @category Transactions
     */
    static fromStr(moduleId: MoveModuleId): ModuleId;
    /**
     * Serializes the address and name properties using the provided serializer.
     * This function is essential for converting the object's data into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a ModuleId from the provided deserializer.
     * This function retrieves the account address and identifier to construct a ModuleId instance.
     *
     * @param deserializer - The deserializer instance used to read the data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): ModuleId;
}

/**
 * Represents a type tag in the serialization framework, serving as a base class for various specific type tags.
 * This class provides methods for serialization and deserialization of type tags, as well as type checking methods
 * to determine the specific type of the tag at runtime.
 *
 * @extends Serializable
 * @group Implementation
 * @category Transactions
 */
declare abstract class TypeTag extends Serializable {
    abstract serialize(serializer: Serializer): void;
    /**
     * Deserializes a StructTag from the provided deserializer.
     * This function allows you to reconstruct a StructTag object from its serialized form.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    deserialize(deserializer: Deserializer): StructTag;
    static deserialize(deserializer: Deserializer): TypeTag;
    abstract toString(): string;
    /**
     * Determines if the current instance is of type TypeTagBool.
     *
     * @returns {boolean} True if the instance is a TypeTagBool, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isBool(): this is TypeTagBool;
    /**
     * Determines if the current instance is of type TypeTagAddress.
     *
     * @returns {boolean} True if the instance is a TypeTagAddress, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isAddress(): this is TypeTagAddress;
    /**
     * Determines if the current instance is of type TypeTagGeneric.
     *
     * @returns {boolean} Returns true if the instance is a TypeTagGeneric, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isGeneric(): this is TypeTagGeneric;
    /**
     * Determine if the current instance is a TypeTagSigner.
     *
     * @returns {boolean} Returns true if the instance is a TypeTagSigner, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isSigner(): this is TypeTagSigner;
    /**
     * Checks if the current instance is a vector type.
     * This can help determine the specific type of data structure being used.
     *
     * @returns {boolean} True if the instance is of type TypeTagVector, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isVector(): this is TypeTagVector;
    /**
     * Determines if the current instance is a structure type.
     *
     * @returns {boolean} True if the instance is of type TypeTagStruct, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isStruct(): this is TypeTagStruct;
    /**
     * Determines if the current instance is of type `TypeTagU8`.
     *
     * @returns {boolean} Returns true if the instance is of type `TypeTagU8`, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU8(): this is TypeTagU8;
    /**
     * Checks if the current instance is of type TypeTagU16.
     *
     * @returns {boolean} True if the instance is TypeTagU16, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU16(): this is TypeTagU16;
    /**
     * Checks if the current instance is of type TypeTagU32.
     *
     * @returns {boolean} Returns true if the instance is TypeTagU32, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU32(): this is TypeTagU32;
    /**
     * Checks if the current instance is of type TypeTagU64.
     *
     * @returns {boolean} True if the instance is a TypeTagU64, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU64(): this is TypeTagU64;
    /**
     * Determines if the current instance is of the TypeTagU128 type.
     *
     * @returns {boolean} True if the instance is of TypeTagU128, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU128(): this is TypeTagU128;
    /**
     * Checks if the current instance is of type TypeTagU256.
     *
     * @returns {boolean} Returns true if the instance is of type TypeTagU256, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isU256(): this is TypeTagU256;
    isPrimitive(): boolean;
}
/**
 * Represents a boolean type tag in the type system.
 * This class extends the base TypeTag class and provides
 * methods for serialization and deserialization of the boolean
 * type tag.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagBool extends TypeTag {
    /**
     * Returns the string representation of the object.
     *
     * @returns {string} The string representation of the object.
     * @group Implementation
     * @category Transactions
     */
    toString(): string;
    /**
     * Serializes the current instance's properties into a provided serializer.
     * This function ensures that the address, module name, name, and type arguments are properly serialized.
     *
     * @param serializer - The serializer instance used to serialize the properties.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a StructTag and returns a new TypeTagStruct instance.
     *
     * @param _deserializer - The deserializer used to read the StructTag data.
     * @group Implementation
     * @category Transactions
     */
    static load(_deserializer: Deserializer): TypeTagBool;
}
/**
 * Represents a type tag for an 8-bit unsigned integer (u8).
 * This class extends the base TypeTag class and provides methods
 * for serialization and deserialization specific to the u8 type.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU8 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU8;
}
/**
 * Represents a type tag for unsigned 16-bit integers (u16).
 * This class extends the base TypeTag class and provides methods for serialization and deserialization.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU16 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU16;
}
/**
 * Represents a type tag for a 32-bit unsigned integer (u32).
 * This class extends the base TypeTag class and provides methods for serialization
 * and deserialization specific to the u32 type.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU32 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU32;
}
/**
 * Represents a type tag for 64-bit unsigned integers (u64).
 * This class extends the base TypeTag class and provides methods for serialization and deserialization.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU64 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU64;
}
/**
 * Represents a type tag for the u128 data type.
 * This class extends the base TypeTag class and provides methods for serialization and deserialization.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU128 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU128;
}
/**
 * Represents a type tag for the U256 data type.
 * This class extends the base TypeTag class and provides methods for serialization and deserialization.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagU256 extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagU256;
}
/**
 * Represents a type tag for an address in the system.
 * This class extends the TypeTag class and provides functionality
 * to serialize the address type and load it from a deserializer.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagAddress extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagAddress;
}
/**
 * Represents a type tag for a signer in the system.
 * This class extends the base TypeTag and provides specific functionality
 * related to the signer type.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagSigner extends TypeTag {
    toString(): string;
    serialize(serializer: Serializer): void;
    static load(_deserializer: Deserializer): TypeTagSigner;
}
/**
 * Represents a reference to a type tag in the type system.
 * This class extends the TypeTag class and provides functionality
 * to serialize and deserialize type tag references.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagReference extends TypeTag {
    readonly value: TypeTag;
    toString(): `&${string}`;
    /**
     * Initializes a new instance of the class with the specified parameters.
     *
     * @param value - The TypeTag to reference.
     * @group Implementation
     * @category Transactions
     */
    constructor(value: TypeTag);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagReference;
}
/**
 * Represents a generic type tag used for type parameters in entry functions.
 * Generics are not serialized into a real type, so they cannot be used as a type directly.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagGeneric extends TypeTag {
    readonly value: number;
    toString(): `T${number}`;
    constructor(value: number);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagGeneric;
}
/**
 * Represents a vector type tag, which encapsulates a single type tag value.
 * This class extends the base TypeTag class and provides methods for serialization,
 * deserialization, and string representation of the vector type tag.
 *
 * @extends TypeTag
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagVector extends TypeTag {
    readonly value: TypeTag;
    toString(): `vector<${string}>`;
    constructor(value: TypeTag);
    /**
     * Creates a new TypeTagVector instance with a TypeTagU8 type.
     *
     * @returns {TypeTagVector} A new TypeTagVector initialized with TypeTagU8.
     * @group Implementation
     * @category Transactions
     */
    static u8(): TypeTagVector;
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagVector;
}
/**
 * Represents a structured type tag in the system, extending the base TypeTag class.
 * This class encapsulates information about a specific structure, including its address,
 * module name, and type arguments, and provides methods for serialization and type checking.
 *
 * @param value - The StructTag instance containing the details of the structured type.
 * @group Implementation
 * @category Transactions
 */
declare class TypeTagStruct extends TypeTag {
    readonly value: StructTag;
    toString(): `0x${string}::${string}::${string}`;
    constructor(value: StructTag);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TypeTagStruct;
    /**
     * Determines if the provided address, module name, and struct name match the current type tag.
     *
     * @param address - The account address to compare against the type tag.
     * @param moduleName - The name of the module to compare against the type tag.
     * @param structName - The name of the struct to compare against the type tag.
     * @returns True if the address, module name, and struct name match the type tag; otherwise, false.
     * @group Implementation
     * @category Transactions
     */
    isTypeTag(address: AccountAddress, moduleName: string, structName: string): boolean;
    /**
     * Checks if the provided value is of type string.
     * This function can help ensure that the data being processed is in the correct format before further operations.
     *
     * @returns {boolean} Returns true if the value is a string, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isString(): boolean;
    /**
     * Checks if the specified account address is of type "option".
     *
     * @returns {boolean} Returns true if the account address is an option type, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isOption(): boolean;
    /**
     * Checks if the provided value is of type 'object'.
     * This function helps determine if a value can be treated as an object type in the context of the SDK.
     *
     * @returns {boolean} Returns true if the value is an object, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isObject(): boolean;
    /**
     * Checks if the provided value is a 'DelegationKey' for permissioned signers.
     *
     * @returns {boolean} Returns true if the value is a DelegationKey, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isDelegationKey(): boolean;
    /**
     * Checks if the provided value is of type `RateLimiter`.
     *
     * @returns {boolean} Returns true if the value is a RateLimiter, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isRateLimiter(): boolean;
}
/**
 * Represents a structured tag that includes an address, module name,
 * name, and type arguments. This class is used to define and manage
 * structured data types within the SDK.
 *
 * @property {AccountAddress} address - The address associated with the struct tag.
 * @property {Identifier} moduleName - The name of the module that contains the struct.
 * @property {Identifier} name - The name of the struct.
 * @property {Array<TypeTag>} typeArgs - An array of type arguments associated with the struct.
 * @group Implementation
 * @category Transactions
 */
declare class StructTag extends Serializable {
    readonly address: AccountAddress;
    readonly moduleName: Identifier;
    readonly name: Identifier;
    readonly typeArgs: Array<TypeTag>;
    constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Array<TypeTag>);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): StructTag;
}
/**
 * Retrieves the StructTag for the AptosCoin, which represents the Aptos Coin in the Aptos blockchain.
 *
 * @returns {StructTag} The StructTag for the AptosCoin.
 * @group Implementation
 * @category Transactions
 */
declare function aptosCoinStructTag(): StructTag;
/**
 * Returns a new StructTag representing a string type.
 *
 * @returns {StructTag} A StructTag for the string type.
 * @group Implementation
 * @category Transactions
 */
declare function stringStructTag(): StructTag;
/**
 * Creates a new StructTag for the Option type with the specified type argument.
 * This can help in defining a specific instance of an Option type in your application.
 *
 * @param typeArg - The type tag that specifies the type of the value contained in the Option.
 * @group Implementation
 * @category Transactions
 */
declare function optionStructTag(typeArg: TypeTag): StructTag;
/**
 * Creates a new StructTag for the Object type with the specified type argument.
 * This function helps in defining a structured representation of an Object with a specific type.
 *
 * @param typeArg - The type tag that specifies the type of the Object.
 * @group Implementation
 * @category Transactions
 */
declare function objectStructTag(typeArg: TypeTag): StructTag;

/**
 * Deserialize a Script Transaction Argument.
 * This function retrieves and deserializes various types of script transaction arguments based on the provided deserializer.
 *
 * @param deserializer - The deserializer used to read the script transaction argument.
 * @returns The deserialized script transaction argument.
 * @throws Error if the variant index is unknown.
 * @group Implementation
 * @category Transactions
 */
declare function deserializeFromScriptArgument(deserializer: Deserializer): TransactionArgument;
/**
 * Represents a supported Transaction Payload that can be serialized and deserialized.
 *
 * This class serves as a base for different types of transaction payloads, allowing for
 * their serialization into a format suitable for transmission and deserialization back
 * into their original form.
 * @group Implementation
 * @category Transactions
 */
declare abstract class TransactionPayload extends Serializable {
    /**
     * Serialize a Transaction Payload
     * @group Implementation
     * @category Transactions
     */
    abstract serialize(serializer: Serializer): void;
    /**
     * Deserialize a Transaction Payload
     * @group Implementation
     * @category Transactions
     */
    /**
     * Deserializes a multisig transaction payload from the provided deserializer.
     * This function enables the reconstruction of a MultiSigTransactionPayload object from its serialized form.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): TransactionPayload;
}
/**
 * Represents a transaction payload script that can be serialized and deserialized.
 *
 * This class encapsulates a script that defines the logic for a transaction payload.
 *
 * @extends TransactionPayload
 * @group Implementation
 * @category Transactions
 */
declare class TransactionPayloadScript extends TransactionPayload {
    readonly script: Script;
    /**
     * Initializes a multi-sig account transaction with the provided payload.
     *
     * @param script - The payload of the multi-sig transaction. This can only be an EntryFunction for now, but Script might be
     * supported in the future.
     * @group Implementation
     * @category Transactions
     */
    constructor(script: Script);
    /**
     * Serializes the transaction payload, enabling future support for multiple types of inner transaction payloads.
     *
     * @param serializer - The serializer instance used to serialize the transaction data.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Loads a MultiSig transaction payload from the provided deserializer.
     * This function helps in reconstructing a MultiSig transaction payload from its serialized form.
     *
     * @param deserializer - The deserializer used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static load(deserializer: Deserializer): TransactionPayloadScript;
}
/**
 * Represents a transaction payload entry function that can be serialized and deserialized.
 *
 * @extends TransactionPayload
 * @group Implementation
 * @category Transactions
 */
declare class TransactionPayloadEntryFunction extends TransactionPayload {
    readonly entryFunction: EntryFunction;
    constructor(entryFunction: EntryFunction);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionPayloadEntryFunction;
}
/**
 * Represents a multi-signature transaction payload that can be serialized and deserialized.
 * @group Implementation
 * @category Transactions
 */
declare class TransactionPayloadMultiSig extends TransactionPayload {
    readonly multiSig: MultiSig;
    constructor(multiSig: MultiSig);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionPayloadMultiSig;
}
/**
 * Represents an entry function that can be serialized and deserialized.
 * This class encapsulates the details required to invoke a function within a module,
 * including the module name, function name, type arguments, and function arguments.
 *
 * @param module_name - Fully qualified module name in the format "account_address::module_name" (e.g., "0x1::coin").
 * @param function_name - The name of the function (e.g., "transfer").
 * @param type_args - Type arguments required by the Move function.
 * @param args - Arguments to the Move function.
 * @group Implementation
 * @category Transactions
 */
declare class EntryFunction {
    readonly module_name: ModuleId;
    readonly function_name: Identifier;
    readonly type_args: Array<TypeTag>;
    readonly args: Array<EntryFunctionArgument>;
    /**
     * Contains the payload to run a function within a module.
     * @param module_name Fully qualified module name in format "account_address::module_name" e.g. "0x1::coin"
     * @param function_name The function name. e.g "transfer"
     * @param type_args Type arguments that move function requires.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     * @param args arguments to the move function.
     *
     * @example
     * A coin transfer function has three arguments "from", "to" and "amount".
     * ```
     * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     * @group Implementation
     * @category Transactions
     */
    constructor(module_name: ModuleId, function_name: Identifier, type_args: Array<TypeTag>, args: Array<EntryFunctionArgument>);
    /**
     * Build an EntryFunction payload from raw primitive values.
     *
     * @param module_id - Fully qualified module name in the format "AccountAddress::module_id", e.g., "0x1::coin".
     * @param function_name - The name of the function to be called.
     * @param type_args - Type arguments that the Move function requires.
     * @param args - Arguments to the Move function.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     *
     * A coin transfer function has three arguments "from", "to", and "amount".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     *
     * @returns EntryFunction
     * @group Implementation
     * @category Transactions
     */
    static build(module_id: MoveModuleId, function_name: string, type_args: Array<TypeTag>, args: Array<EntryFunctionArgument>): EntryFunction;
    serialize(serializer: Serializer): void;
    /**
     * Deserializes an entry function payload with the arguments represented as EntryFunctionBytes instances.
     * @see EntryFunctionBytes
     *
     * NOTE: When you deserialize an EntryFunction payload with this method, the entry function
     * arguments are populated into the deserialized instance as type-agnostic, raw fixed bytes
     * in the form of the EntryFunctionBytes class.
     *
     * In order to correctly deserialize these arguments as their actual type representations, you
     * must know the types of the arguments beforehand and deserialize them yourself individually.
     *
     * One way you could achieve this is by using the ABIs for an entry function and deserializing each
     * argument as its given, corresponding type.
     *
     * @param deserializer
     * @returns A deserialized EntryFunction payload for a transaction.
     *
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): EntryFunction;
}
/**
 * Represents a Script that can be serialized and deserialized.
 * Scripts contain the Move bytecode payload that can be submitted to the Aptos chain for execution.
 * @group Implementation
 * @category Transactions
 */
declare class Script {
    /**
     * The move module bytecode
     * @group Implementation
     * @category Transactions
     */
    readonly bytecode: Uint8Array;
    /**
     * The type arguments that the bytecode function requires.
     * @group Implementation
     * @category Transactions
     */
    readonly type_args: Array<TypeTag>;
    /**
     * The arguments that the bytecode function requires.
     * @group Implementation
     * @category Transactions
     */
    readonly args: Array<ScriptFunctionArgument>;
    /**
     * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.
     *
     * @param bytecode The move module bytecode
     * @param type_args The type arguments that the bytecode function requires.
     *
     * @example
     * A coin transfer function has one type argument "CoinType".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     * @param args The arguments that the bytecode function requires.
     *
     * @example
     * A coin transfer function has three arguments "from", "to" and "amount".
     * ```
     * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)
     * ```
     * @group Implementation
     * @category Transactions
     */
    constructor(bytecode: Uint8Array, type_args: Array<TypeTag>, args: Array<ScriptFunctionArgument>);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Script;
}
/**
 * Represents a MultiSig account that can be serialized and deserialized.
 *
 * This class encapsulates the functionality to manage multi-signature transactions, including the address of the
 * multi-sig account and the associated transaction payload.
 * @group Implementation
 * @category Transactions
 */
declare class MultiSig {
    readonly multisig_address: AccountAddress;
    readonly transaction_payload?: MultiSigTransactionPayload;
    /**
     * Contains the payload to run a multi-sig account transaction.
     *
     * @param multisig_address The multi-sig account address the transaction will be executed as.
     *
     * @param transaction_payload The payload of the multi-sig transaction. This is optional when executing a multi-sig
     *  transaction whose payload is already stored on chain.
     * @group Implementation
     * @category Transactions
     */
    constructor(multisig_address: AccountAddress, transaction_payload?: MultiSigTransactionPayload);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiSig;
}
/**
 * Represents a multi-signature transaction payload that can be serialized and deserialized.
 * This class is designed to encapsulate the transaction payload for multi-sig account transactions
 * as defined in the `multisig_account.move` module. Future enhancements may allow support for script
 * payloads as the `multisig_account.move` module evolves.
 * @group Implementation
 * @category Transactions
 */
declare class MultiSigTransactionPayload extends Serializable {
    readonly transaction_payload: EntryFunction;
    /**
     * Contains the payload to run a multi-sig account transaction.
     *
     * @param transaction_payload The payload of the multi-sig transaction.
     * This can only be EntryFunction for now but,
     * Script might be supported in the future.
     * @group Implementation
     * @category Transactions
     */
    constructor(transaction_payload: EntryFunction);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiSigTransactionPayload;
}
/**
 * Represents any transaction payload that can be submitted to the Aptos chain for execution.
 *
 * This is specifically required for orderless transactions, but can be used for any transaction payload.
 */
declare abstract class TransactionInnerPayload extends TransactionPayload {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionInnerPayload;
}
declare class TransactionInnerPayloadV1 extends TransactionInnerPayload {
    executable: TransactionExecutable;
    extra_config: TransactionExtraConfig;
    constructor(executable: TransactionExecutable, extra_config: TransactionExtraConfig);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionInnerPayloadV1;
}
declare abstract class TransactionExecutable {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionExecutable;
}
declare class TransactionExecutableScript extends TransactionExecutable {
    script: Script;
    constructor(script: Script);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionExecutableScript;
}
declare class TransactionExecutableEntryFunction extends TransactionExecutable {
    entryFunction: EntryFunction;
    constructor(entryFunction: EntryFunction);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionExecutableEntryFunction;
}
declare class TransactionExecutableEmpty extends TransactionExecutable {
    serialize(serializer: Serializer): void;
    static load(_: Deserializer): TransactionExecutableEmpty;
}
declare abstract class TransactionExtraConfig {
    abstract serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): TransactionExtraConfig;
}
declare class TransactionExtraConfigV1 extends TransactionExtraConfig {
    multisigAddress?: AccountAddress;
    replayProtectionNonce?: bigint;
    constructor(multisigAddress?: AccountAddress, replayProtectionNonce?: AnyNumber);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): TransactionExtraConfigV1;
}

/**
 * Represents a raw transaction that can be serialized and deserialized.
 * Raw transactions contain the metadata and payloads that can be submitted to the Aptos chain for execution.
 * They must be signed before the Aptos chain can execute them.
 * @group Implementation
 * @category Transactions
 */
declare class RawTransaction extends Serializable {
    readonly sender: AccountAddress;
    readonly sequence_number: bigint;
    readonly payload: TransactionPayload;
    readonly max_gas_amount: bigint;
    readonly gas_unit_price: bigint;
    readonly expiration_timestamp_secs: bigint;
    readonly chain_id: ChainId;
    /**
     * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.
     * RawTransactions must be signed before Aptos chain can execute them.
     *
     * @param sender The sender Account Address
     * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in
     *   the sender's account at the time the transaction executes.
     * @param payload Instructions for the Aptos Blockchain, including publishing a module,
     *   execute an entry function or execute a script payload.
     * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more
     *   than this gas or the transaction will be discarded during validation.
     * @param gas_unit_price Price to be paid per gas unit.
     * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.
     * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.
     * @group Implementation
     * @category Transactions
     */
    constructor(sender: AccountAddress, sequence_number: bigint, payload: TransactionPayload, max_gas_amount: bigint, gas_unit_price: bigint, expiration_timestamp_secs: bigint, chain_id: ChainId);
    /**
     * Serializes the transaction data, including the fee payer transaction type, raw transaction, secondary signer addresses,
     * and fee payer address.
     * This function is essential for preparing the transaction for transmission or storage in a serialized format.
     *
     * @param serializer - The serializer instance used to serialize the transaction data.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserialize a Raw Transaction With Data.
     * This function retrieves the appropriate raw transaction based on the variant index provided by the deserializer.
     *
     * @param deserializer - An instance of the Deserializer used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): RawTransaction;
}
/**
 * Represents a raw transaction with associated data that can be serialized and deserialized.
 *
 * @extends Serializable
 * @group Implementation
 * @category Transactions
 */
declare abstract class RawTransactionWithData extends Serializable {
    /**
     * Serialize a Raw Transaction With Data
     * @group Implementation
     * @category Transactions
     */
    abstract serialize(serializer: Serializer): void;
    /**
     * Deserialize a Raw Transaction With Data
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): RawTransactionWithData;
}
/**
 * Represents a multi-agent transaction that can be serialized and deserialized.
 *
 * @extends RawTransactionWithData
 * @group Implementation
 * @category Transactions
 */
declare class MultiAgentRawTransaction extends RawTransactionWithData {
    /**
     * The raw transaction
     * @group Implementation
     * @category Transactions
     */
    readonly raw_txn: RawTransaction;
    /**
     * The secondary signers on this transaction
     * @group Implementation
     * @category Transactions
     */
    readonly secondary_signer_addresses: Array<AccountAddress>;
    constructor(raw_txn: RawTransaction, secondary_signer_addresses: Array<AccountAddress>);
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a Fee Payer Raw Transaction from the provided deserializer.
     * This function allows you to reconstruct a Fee Payer Raw Transaction object, which includes the raw transaction data,
     * secondary signer addresses, and the fee payer address.
     *
     * @param deserializer - The deserializer used to read the raw transaction data.
     * @returns A FeePayerRawTransaction object constructed from the deserialized data.
     * @group Implementation
     * @category Transactions
     */
    static load(deserializer: Deserializer): MultiAgentRawTransaction;
}
/**
 * Represents a Fee Payer Transaction that can be serialized and deserialized.
 * @group Implementation
 * @category Transactions
 */
declare class FeePayerRawTransaction extends RawTransactionWithData {
    /**
     * The raw transaction
     * @group Implementation
     * @category Transactions
     */
    readonly raw_txn: RawTransaction;
    /**
     * The secondary signers on this transaction - optional and can be empty
     * @group Implementation
     * @category Transactions
     */
    readonly secondary_signer_addresses: Array<AccountAddress>;
    /**
     * The fee payer account address
     * @group Implementation
     * @category Transactions
     */
    readonly fee_payer_address: AccountAddress;
    constructor(raw_txn: RawTransaction, secondary_signer_addresses: Array<AccountAddress>, fee_payer_address: AccountAddress);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): FeePayerRawTransaction;
}

/**
 * Represents a simple transaction type that can be submitted to the Aptos chain for execution.
 *
 * This transaction type is designed for a single signer and includes metadata such as the Raw Transaction
 * and an optional sponsor Account Address to cover gas fees.
 *
 * @param rawTransaction - The Raw Transaction.
 * @param feePayerAddress - The optional sponsor Account Address.
 * @group Implementation
 * @category Transactions
 */
declare class SimpleTransaction extends Serializable {
    rawTransaction: RawTransaction;
    feePayerAddress?: AccountAddress | undefined;
    readonly secondarySignerAddresses: undefined;
    /**
     * SimpleTransaction represents a transaction signed by a single account that
     * can be submitted to the Aptos chain for execution.
     *
     * @param rawTransaction The Raw Transaction.
     * @param feePayerAddress The optional sponsor Account Address to pay the gas fees.
     * @group Implementation
     * @category Transactions
     */
    constructor(rawTransaction: RawTransaction, feePayerAddress?: AccountAddress);
    /**
     * Serializes the transaction data using the provided serializer.
     * This function ensures that the raw transaction and fee payer address are properly serialized for further processing.
     *
     * @param serializer - The serializer instance used to serialize the transaction data.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a SimpleTransaction from the given deserializer.
     * This function helps in reconstructing a SimpleTransaction object from its serialized form.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): SimpleTransaction;
}

/**
 * Represents a multi-agent transaction that can be serialized and deserialized.
 * This transaction includes a raw transaction, optional fee payer address, and multiple secondary signer addresses.
 *
 * @param rawTransaction The raw transaction to be executed.
 * @param secondarySignerAddresses An array of secondary signer addresses involved in the transaction.
 * @param feePayerAddress An optional account address that sponsors the transaction's gas fees.
 * @group Implementation
 * @category Transactions
 */
declare class MultiAgentTransaction extends Serializable {
    rawTransaction: RawTransaction;
    feePayerAddress?: AccountAddress | undefined;
    secondarySignerAddresses: AccountAddress[];
    /**
     * Represents a MultiAgentTransaction that can be submitted to the Aptos chain for execution.
     * This class encapsulates the raw transaction data, the secondary signer addresses, and an optional fee payer address.
     *
     * @param rawTransaction The raw transaction data.
     * @param secondarySignerAddresses An array of secondary signer addresses.
     * @param feePayerAddress An optional account address that sponsors the gas fees.
     * @group Implementation
     * @category Transactions
     */
    constructor(rawTransaction: RawTransaction, secondarySignerAddresses: AccountAddress[], feePayerAddress?: AccountAddress);
    /**
     * Serializes the transaction data, including the raw transaction, secondary signer addresses, and fee payer address.
     * This function is essential for preparing the transaction for transmission or storage in a serialized format.
     *
     * @param serializer - The serializer instance used to serialize the transaction data.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserializes a MultiAgentTransaction from the provided deserializer.
     * This function allows you to reconstruct a MultiAgentTransaction object from its serialized form, including any secondary
     * signer addresses and the fee payer address if present.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): MultiAgentTransaction;
}

/**
 * Represents a boolean value that can be serialized and deserialized.
 * This class extends the Serializable class and provides methods to serialize
 * the boolean value for different contexts, such as entry functions and script functions.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class Bool extends Serializable implements TransactionArgument {
    readonly value: boolean;
    /**
     * Constructs a new instance with a specified value.
     * This ensures that the value is validated to be within the acceptable range.
     *
     * @param value - The number to be validated and assigned, which must be between 0 and MAX_U256_BIG_INT.
     * @group Implementation
     * @category BCS
     */
    constructor(value: boolean);
    /**
     * Serializes the value using the provided serializer.
     * This function is essential for converting the value into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category BCS
     */
    serialize(serializer: Serializer): void;
    /**
     * Serializes the current instance for use in an entry function by converting it to a byte sequence.
     * This allows the instance to be properly formatted for serialization in transactions.
     *
     * @param serializer - The serializer instance used to serialize the byte sequence.
     * @group Implementation
     * @category BCS
     */
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * Serializes the current instance for use in a script function.
     * This allows for the conversion of the instance into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer used to perform the serialization.
     * @group Implementation
     * @category BCS
     */
    serializeForScriptFunction(serializer: Serializer): void;
    /**
     * Deserializes a U256 value from the provided deserializer.
     *
     * @param deserializer - The deserializer instance used to read the U256 data.
     * @group Implementation
     * @category BCS
     */
    deserialize(deserializer: Deserializer): U256;
    static deserialize(deserializer: Deserializer): Bool;
}
/**
 * Represents an unsigned 8-bit integer (U8) value.
 * This class extends the Serializable class and provides methods for serialization and deserialization of U8 values.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U8 extends Serializable implements TransactionArgument {
    readonly value: Uint8;
    constructor(value: Uint8);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U8;
}
/**
 * Represents a 16-bit unsigned integer (U16) value.
 * This class extends the Serializable class and provides methods for serialization
 * and deserialization of the U16 value.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U16 extends Serializable implements TransactionArgument {
    readonly value: Uint16;
    constructor(value: Uint16);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U16;
}
/**
 * Represents a 32-bit unsigned integer (U32) that can be serialized and deserialized.
 * This class ensures that the value is within the valid range for a U32.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U32 extends Serializable implements TransactionArgument {
    readonly value: Uint32;
    constructor(value: Uint32);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U32;
}
/**
 * Represents a 64-bit unsigned integer (U64) and provides methods for serialization.
 *
 * This class ensures that the value is within the valid range for a U64 and provides
 * functionality to serialize the value for various use cases, including entry functions
 * and script functions.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U64 extends Serializable implements TransactionArgument {
    readonly value: bigint;
    constructor(value: AnyNumber);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U64;
}
/**
 * Represents a 128-bit unsigned integer value.
 * This class provides methods for serialization and deserialization
 * of U128 values, ensuring that the values are within the valid range.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U128 extends Serializable implements TransactionArgument {
    readonly value: bigint;
    constructor(value: AnyNumber);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U128;
}
/**
 * Represents a 256-bit unsigned integer (U256) that extends the Serializable class.
 * This class provides methods for serialization and deserialization of U256 values,
 * ensuring that the values are within the valid range.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class U256 extends Serializable implements TransactionArgument {
    readonly value: bigint;
    constructor(value: AnyNumber);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): U256;
}

/**
 * This class is the Aptos Typescript SDK representation of a Move `vector<T>`,
 * where `T` represents either a primitive type (`bool`, `u8`, `u64`, ...)
 * or a BCS-serializable struct itself.
 *
 * It is a BCS-serializable, array-like type that contains an array of values of type `T`,
 * where `T` is a class that implements `Serializable`.
 *
 * The purpose of this class is to facilitate easy construction of BCS-serializable
 * Move `vector<T>` types.
 *
 * @example
 * // in Move: `vector<u8> [1, 2, 3, 4];`
 * const vecOfU8s = new MoveVector<U8>([new U8(1), new U8(2), new U8(3), new U8(4)]);
 * // in Move: `std::bcs::to_bytes(vector<u8> [1, 2, 3, 4]);`
 * const bcsBytes = vecOfU8s.toUint8Array();
 *
 * // vector<vector<u8>> [ vector<u8> [1], vector<u8> [1, 2, 3, 4], vector<u8> [5, 6, 7, 8] ];
 * const vecOfVecs = new MoveVector<MoveVector<U8>>([
 *   new MoveVector<U8>([new U8(1)]),
 *   MoveVector.U8([1, 2, 3, 4]),
 *   MoveVector.U8([5, 6, 7, 8]),
 * ]);
 *
 * // vector<Option<u8>> [ std::option::some<u8>(1), std::option::some<u8>(2) ];
 * const vecOfOptionU8s = new MoveVector<MoveOption<U8>>([
 *    MoveOption.U8(1),
 *    MoveOption.U8(2),
 * ]);
 *
 * // vector<MoveString> [ std::string::utf8(b"hello"), std::string::utf8(b"world") ];
 * const vecOfStrings = new MoveVector([new MoveString("hello"), new MoveString("world")]);
 * const vecOfStrings2 = MoveVector.MoveString(["hello", "world"]);
 *
 * @param values an Array<T> of values where T is a class that implements Serializable
 * @returns a `MoveVector<T>` with the values `values`
 * @group Implementation
 * @category BCS
 */
declare class MoveVector<T extends Serializable & EntryFunctionArgument> extends Serializable implements TransactionArgument {
    values: Array<T>;
    /**
     * Initializes a new instance of the class with an optional value.
     * This constructor sets up the internal vector based on the provided value.
     *
     * @param values - The initial value to be stored in the vector, or null to initialize an empty vector.
     * @group Implementation
     * @category BCS
     */
    constructor(values: Array<T>);
    /**
     * Serializes the current instance into a byte sequence suitable for entry functions.
     * This allows the data to be properly formatted for transmission or storage.
     *
     * @param serializer - The serializer instance used to serialize the byte sequence.
     * @group Implementation
     * @category BCS
     */
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * NOTE: This function will only work when the inner values in the `MoveVector` are `U8`s.
     * @param serializer
     * @group Implementation
     * @category BCS
     */
    /**
     * Serialize the string as a fixed byte string without the length prefix for use in a script function.
     * @param serializer - The serializer used to convert the byte vector into a format suitable for a script function.
     * @group Implementation
     * @category BCS
     */
    serializeForScriptFunction(serializer: Serializer): void;
    /**
     * Factory method to generate a MoveVector<U8> from a `number` or `undefined`.
     *
     * This method allows you to create a MoveVector that encapsulates a U8 value, enabling you to handle optional U8 values
     * effectively.
     *
     * @param values - The values used to fill the MoveVector. If `values` is undefined or null, the resulting MoveVector's
     * `.isSome()` method will return false.
     * @returns A MoveVector<U8> with an inner value `value`.
     *
     * @example
     * ```typescript
     * const v = MoveVector.U8([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
     */
    static U8(values: Array<number> | HexInput): MoveVector<U8>;
    /**
     * Factory method to generate a MoveOption<U16> from a `number` or `null`.
     *
     * This method allows you to create a MoveVector that can either hold a U16 value or be empty.
     *
     * @param values - The value used to fill the MoveVector. If `value` is null or undefined, the resulting MoveVector's
     * `.isSome()` method will return false.
     * @returns A MoveVector<U16> with an inner value `value`.
     * @example
     * ```typescript
     * const v = MoveVector.U16([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
  
     */
    static U16(values: Array<number>): MoveVector<U16>;
    /**
     * Factory method to generate a MoveVector<U32> from a `number` or `null`.
     *
     * This method allows you to create a MoveVector that can either hold a U32 value or be empty.
     *
     * @param values - The value used to fill the MoveVector. If `value` is null or undefined,
     * the resulting MoveVector's .isSome() method will return false.
     * @returns A MoveVector<U32> with an inner value `value`.
     *
     * @example
     * ```
     * const v = MoveVector.U32([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
  
     */
    static U32(values: Array<number>): MoveVector<U32>;
    /**
     * Factory method to generate a MoveVector<U64> from a number, bigint, or null/undefined.
     * This allows for the creation of an optional U64 value that can be checked for presence.
     *
     * @param values - The value used to fill the MoveVector. If `value` is undefined or null, the resulting MoveVector's
     * `.isSome()` method will return false.
     * @returns A MoveVector<U64> with an inner value `value`.
     *
     * @example
     * ```typescript
     * const v = MoveVector.U64([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
     */
    static U64(values: Array<AnyNumber>): MoveVector<U64>;
    /**
     * Factory method to generate a MoveVector<U128> from a number, bigint, or undefined.
     *
     * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's `.isSome()`
     * method will return false.
     * @returns A MoveVector<U128> with an inner value `value`.
     *
     * @example
     * ```typescript
     * const v = MoveVector.U128([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
     */
    static U128(values: Array<AnyNumber>): MoveVector<U128>;
    /**
     * Factory method to generate a MoveVector<U256> from a number, bigint, or null/undefined.
     * This allows for the creation of an optional U256 value, enabling checks for presence or absence of a value.
     *
     * @param values - The value used to fill the MoveVector. If `value` is undefined or null,
     *                the resulting MoveVector's .isSome() method will return false.
     * @returns A MoveVector<U256> with an inner value `value`.
     *
     * @example
     * ```typescript
     * const v = MoveVector.U256([1, 2, 3, 4]);
     * ```
     * @group Implementation
     * @category BCS
     */
    static U256(values: Array<AnyNumber>): MoveVector<U256>;
    /**
     * Factory method to generate a MoveVector<Bool> from a `boolean` or `undefined`.
     * This method allows you to create an optional boolean value that can be used in various contexts where a boolean may or may
     * not be present.
     *
     * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's .isSome() method
     * will return false.
     * @returns A MoveVector<Bool> with an inner value `value`.
     *
     * @example
     *    * const v = MoveVector.Bool([true, false, true, false]);
     * @group Implementation
     * @category BCS
     */
    static Bool(values: Array<boolean>): MoveVector<Bool>;
    /**
     * Factory method to generate a MoveVector<MoveString> from a `string` or `undefined`.
     * This function creates a MoveVector that encapsulates a MoveString if the provided value is not null or undefined.
     *
     * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's .isSome() method
     * will return false.
     * @returns A MoveVector<MoveString> with an inner value `value`.
     *
     * @example
     * const v = MoveVector.MoveString(["hello", "world"]);
     * @group Implementation
     * @category BCS
     */
    static MoveString(values: Array<string>): MoveVector<MoveString>;
    /**
     * Serializes the current object using the provided serializer.
     * This function will serialize the value if it is present.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category BCS
     */
    serialize(serializer: Serializer): void;
    /**
     * Deserialize a MoveVector of type T, specifically where T is a Serializable and Deserializable type.
     *
     * NOTE: This only works with a depth of one. Generics will not work.
     *
     * NOTE: This will not work with types that aren't of the Serializable class.
     *
     * If you're looking for a more flexible deserialization function, you can use the deserializeVector function
     * in the Deserializer class.
     *
     * @example
     * const vec = MoveVector.deserialize(deserializer, U64);
     * @param deserializer the Deserializer instance to use, with bytes loaded into it already.
     * @param cls the class to typecast the input values to, must be a Serializable and Deserializable type.
     * @returns a MoveVector of the corresponding class T
     *
     * @group Implementation
     * @category BCS
     */
    static deserialize<T extends Serializable & EntryFunctionArgument>(deserializer: Deserializer, cls: Deserializable<T>): MoveVector<T>;
}
/**
 * Represents a serialized data structure that encapsulates a byte array.
 * This class extends the Serializable class and provides methods for serialization
 * and deserialization of byte data, as well as converting to a MoveVector.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class Serialized extends Serializable implements TransactionArgument {
    readonly value: Uint8Array;
    constructor(value: HexInput);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Serialized;
    /**
     * Deserialize the bytecode into a MoveVector of the specified type.
     * This function allows you to convert serialized data into a usable MoveVector format.
     *
     * @param cls - The class type of the elements in the MoveVector.
     * @group Implementation
     * @category BCS
     */
    toMoveVector<T extends Serializable & EntryFunctionArgument>(cls: Deserializable<T>): MoveVector<T>;
}
/**
 * Represents a string value that can be serialized and deserialized.
 * This class extends the Serializable base class and provides methods
 * for serializing the string in different contexts, such as for entry
 * functions and script functions.
 *
 * @extends Serializable
 * @group Implementation
 * @category BCS
 */
declare class MoveString extends Serializable implements TransactionArgument {
    value: string;
    constructor(value: string);
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MoveString;
}
declare class MoveOption<T extends Serializable & EntryFunctionArgument> extends Serializable implements EntryFunctionArgument {
    private vec;
    readonly value?: T;
    constructor(value?: T | null);
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * Retrieves the inner value of the MoveOption.
     *
     * This method is inspired by Rust's `Option<T>.unwrap()`, where attempting to unwrap a `None` value results in a panic.
     * This method will throw an error if the value is not present.
     *
     * @example
     * const option = new MoveOption<Bool>(new Bool(true));
     * const value = option.unwrap();  // Returns the Bool instance
     *
     * @throws {Error} Throws an error if the MoveOption does not contain a value.
     *
     * @returns {T} The contained value if present.
     * @group Implementation
     * @category BCS
     */
    unwrap(): T;
    /**
     * Check if the MoveOption has a value.
     *
     * @returns {boolean} Returns true if there is exactly one value in the MoveOption.
     * @group Implementation
     * @category BCS
     */
    isSome(): boolean;
    serialize(serializer: Serializer): void;
    /**
     * Factory method to generate a MoveOption<U8> from a `number` or `undefined`.
     *
     * @example
     * MoveOption.U8(1).isSome() === true;
     * MoveOption.U8().isSome() === false;
     * MoveOption.U8(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U8> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U8(value?: number | null): MoveOption<U8>;
    /**
     * Factory method to generate a MoveOption<U16> from a `number` or `undefined`.
     *
     * @example
     * MoveOption.U16(1).isSome() === true;
     * MoveOption.U16().isSome() === false;
     * MoveOption.U16(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U16> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U16(value?: number | null): MoveOption<U16>;
    /**
     * Factory method to generate a MoveOption<U32> from a `number` or `undefined`.
     *
     * @example
     * MoveOption.U32(1).isSome() === true;
     * MoveOption.U32().isSome() === false;
     * MoveOption.U32(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U32> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U32(value?: number | null): MoveOption<U32>;
    /**
     * Factory method to generate a MoveOption<U64> from a `number` or a `bigint` or `undefined`.
     *
     * @example
     * MoveOption.U64(1).isSome() === true;
     * MoveOption.U64().isSome() === false;
     * MoveOption.U64(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U64> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U64(value?: AnyNumber | null): MoveOption<U64>;
    /**
     * Factory method to generate a MoveOption<U128> from a `number` or a `bigint` or `undefined`.
     *
     * @example
     * MoveOption.U128(1).isSome() === true;
     * MoveOption.U128().isSome() === false;
     * MoveOption.U128(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U128> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U128(value?: AnyNumber | null): MoveOption<U128>;
    /**
     * Factory method to generate a MoveOption<U256> from a `number` or a `bigint` or `undefined`.
     *
     * @example
     * MoveOption.U256(1).isSome() === true;
     * MoveOption.U256().isSome() === false;
     * MoveOption.U256(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<U256> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static U256(value?: AnyNumber | null): MoveOption<U256>;
    /**
     * Factory method to generate a MoveOption<Bool> from a `boolean` or `undefined`.
     *
     * @example
     * MoveOption.Bool(true).isSome() === true;
     * MoveOption.Bool().isSome() === false;
     * MoveOption.Bool(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<Bool> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static Bool(value?: boolean | null): MoveOption<Bool>;
    /**
     * Factory method to generate a MoveOption<MoveString> from a `string` or `undefined`.
     *
     * @example
     * MoveOption.MoveString("hello").isSome() === true;
     * MoveOption.MoveString("").isSome() === true;
     * MoveOption.MoveString().isSome() === false;
     * MoveOption.MoveString(undefined).isSome() === false;
     * @param value the value used to fill the MoveOption. If `value` is undefined
     * the resulting MoveOption's .isSome() method will return false.
     * @returns a MoveOption<MoveString> with an inner value `value`
     * @group Implementation
     * @category BCS
     */
    static MoveString(value?: string | null): MoveOption<MoveString>;
    static deserialize<U extends Serializable & EntryFunctionArgument>(deserializer: Deserializer, cls: Deserializable<U>): MoveOption<U>;
}

/**
 * Represents a contiguous sequence of already serialized BCS bytes.
 *
 * This class differs from most other Serializable classes in that its internal byte buffer is serialized to BCS
 * bytes exactly as-is, without prepending the length of the bytes. It is ideal for scenarios where custom serialization
 * is required, such as passing serialized bytes as transaction arguments. Additionally, it serves as a representation
 * of type-agnostic BCS bytes, akin to a vector<u8>.
 *
 * An example use case includes handling bytes resulting from entry function arguments that have been serialized
 * for an entry function.
 *
 * @example
 * const yourCustomSerializedBytes = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
 * const fixedBytes = new FixedBytes(yourCustomSerializedBytes);
 * const payload = await generateTransactionPayload({
 *   function: "0xbeefcafe::your_module::your_function_that_requires_custom_serialization",
 *   functionArguments: [yourCustomBytes],
 * });
 *
 * This class is particularly useful when you want to handle a fixed-size byte array without the overhead of
 * length prepending, such as when dealing with 32-byte addresses stored as U8 in a MoveVector<U8>.

 *  For example, if you store each of the 32 bytes for an address as a U8 in a MoveVector<U8>, when you
 *  serialize that MoveVector<U8>, it will be serialized to 33 bytes. If you solely want to pass around
 *  the 32 bytes as a Serializable class that *does not* prepend the length to the BCS-serialized representation,
 *  use this class.*
 * @param value - HexInput representing a sequence of Uint8 bytes.
 * @returns A Serializable FixedBytes instance, which when serialized, does not prepend the length of the bytes.
 * @see EntryFunctionBytes
 * @group Implementation
 * @category BCS
 */
declare class FixedBytes extends Serializable implements TransactionArgument {
    value: Uint8Array;
    /**
     * Creates an instance of the class with a specified hexadecimal input.
     * The value is converted from hexadecimal format to a Uint8Array.
     *
     * @param value - The hexadecimal input to be converted.
     * @group Implementation
     * @category BCS
     */
    constructor(value: HexInput);
    /**
     * Serializes the fixed bytes value using the provided serializer.
     * This function is essential for converting the fixed bytes into a format suitable for storage or transmission.
     *
     * @param serializer - The serializer instance used for serialization.
     * @group Implementation
     * @category BCS
     */
    serialize(serializer: Serializer): void;
    /**
     * Serializes the current instance for an entry function using the provided serializer.
     * This allows the instance to be converted into a format suitable for transmission or storage.
     *
     * @param serializer - The serializer used to perform the serialization.
     * @group Implementation
     * @category BCS
     */
    serializeForEntryFunction(serializer: Serializer): void;
    /**
     * Serializes the current instance using the provided serializer.
     * This function is essential for preparing data to be passed as arguments in script functions.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category BCS
     */
    serializeForScriptFunction(serializer: Serializer): void;
    /**
     * Deserializes a fixed-length byte array from the provided deserializer.
     * This function helps in reconstructing a FixedBytes object from the serialized data.
     *
     * @param deserializer - The deserializer instance used to read the byte data.
     * @param length - The length of the byte array to be deserialized.
     * @group Implementation
     * @category BCS
     */
    static deserialize(deserializer: Deserializer, length: number): FixedBytes;
}

/**
 * Entry function arguments for building a raw transaction using remote ABI, supporting various data types including primitives and arrays.
 * @group Implementation
 * @category Transactions
 */
type SimpleEntryFunctionArgumentTypes = boolean | number | bigint | string | null | undefined | Uint8Array | ArrayBuffer | Array<SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes>;
/**
 * Entry function arguments for building a raw transaction using BCS serialized arguments.
 * @group Implementation
 * @category Transactions
 */
type EntryFunctionArgumentTypes = Bool | U8 | U16 | U32 | U64 | U128 | U256 | AccountAddress | MoveVector<EntryFunctionArgumentTypes> | MoveOption<EntryFunctionArgumentTypes> | MoveString | FixedBytes;
/**
 * Script function arguments for building raw transactions using BCS serialized arguments.
 * @group Implementation
 * @category Transactions
 */
type ScriptFunctionArgumentTypes = Bool | U8 | U16 | U32 | U64 | U128 | U256 | AccountAddress | MoveVector<ScriptFunctionArgumentTypes> | MoveString | FixedBytes | Serialized;
/**
 * Inputs for Entry functions, view functions, and scripts, which can be a string representation of various types including
 * primitive types, vectors, and structured types.
 *
 *  *
 * This can be a string version of the type argument such as:
 * - u8
 * - u16
 * - u32
 * - u64
 * - u128
 * - u256
 * - bool
 * - address
 * - signer
 * - vector<Type>
 * - address::module::struct
 * - address::module::struct<Type1, Type2>
 * @group Implementation
 * @category Transactions
 */
type TypeArgument = TypeTag | string;
/**
 * Holds all return interfaces for generating different transaction types.
 * @group Implementation
 * @category Transactions
 */
type AnyRawTransactionInstance = RawTransaction | MultiAgentRawTransaction | FeePayerRawTransaction;
/**
 * Optional options to set when generating a transaction, including a maximum gas amount.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateTransactionOptions = InputGenerateSequenceNumberTransactionOptions | InputGenerateOrderlessTransactionOptions;
/**
 * Input options for generating a transaction that requires an account sequence number, which is the default method.
 */
type InputGenerateSequenceNumberTransactionOptions = {
    maxGasAmount?: number;
    gasUnitPrice?: number;
    expireTimestamp?: number;
    accountSequenceNumber?: AnyNumber;
    replayProtectionNonce?: undefined;
};
/**
 * Input options for generating a transaction using the orderless method, which does not require an account sequence number.
 */
type InputGenerateOrderlessTransactionOptions = {
    maxGasAmount?: number;
    gasUnitPrice?: number;
    expireTimestamp?: number;
    accountSequenceNumber?: undefined;
    replayProtectionNonce: AnyNumber;
};
/**
 * The transaction payload type generated from the `generateTransactionPayload()` function, which can be an entry function,
 * script, or multi-signature payload.
 * @group Implementation
 * @category Transactions
 */
type AnyTransactionPayloadInstance = TransactionPayloadEntryFunction | TransactionPayloadScript | TransactionPayloadMultiSig | TransactionInnerPayload;
/**
 * The data needed to generate a transaction payload for Entry Function, Script, or Multi Sig types.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateTransactionPayloadData = InputEntryFunctionData | InputScriptData | InputMultiSigData;
/**
 * The payload for generating a transaction, which can be either script data, entry function data with remote ABI, or
 * multi-signature data.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateTransactionPayloadDataWithRemoteABI = InputScriptData | InputEntryFunctionDataWithRemoteABI | InputMultiSigDataWithRemoteABI;
/**
 * The data needed to generate an Entry Function payload.
 * @group Implementation
 * @category Transactions
 */
type InputEntryFunctionData = {
    function: MoveFunctionId;
    typeArguments?: Array<TypeArgument>;
    functionArguments: Array<EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes>;
    abi?: EntryFunctionABI;
};
/**
 * The payload for generating a transaction, which can be either an entry function or a multi-signature transaction.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateTransactionPayloadDataWithABI = InputEntryFunctionDataWithABI | InputMultiSigDataWithABI;
/**
 * The input data for an entry function, including its associated ABI.
 * @group Implementation
 * @category Transactions
 */
type InputEntryFunctionDataWithABI = Omit<InputEntryFunctionData, "abi"> & {
    abi: EntryFunctionABI;
};
/**
 * The data needed to generate a Multi Sig payload, including the multisig address.
 * @group Implementation
 * @category Transactions
 */
type InputMultiSigDataWithABI = {
    multisigAddress: AccountAddressInput;
} & InputEntryFunctionDataWithABI;
/**
 * Combines input function data with Aptos configuration for remote ABI interactions.
 * @group Implementation
 * @category Transactions
 */
type InputEntryFunctionDataWithRemoteABI = InputEntryFunctionData & {
    aptosConfig: AptosConfig;
};
/**
 * The data needed to generate a Multi Sig payload
 * @group Implementation
 * @category Transactions
 */
type InputMultiSigData = {
    multisigAddress: AccountAddressInput;
} & InputEntryFunctionData;
/**
 * The data needed to generate a Multi Sig payload, including the multisig address.
 * @group Implementation
 * @category Transactions
 */
type InputMultiSigDataWithRemoteABI = {
    multisigAddress: AccountAddressInput;
} & InputEntryFunctionDataWithRemoteABI;
/**
 * The data needed to generate a Script payload.
 * @group Implementation
 * @category Transactions
 */
type InputScriptData = {
    bytecode: HexInput;
    typeArguments?: Array<TypeArgument>;
    functionArguments: Array<ScriptFunctionArgumentTypes>;
};
/**
 * The data needed to generate a View Function payload.
 * @group Implementation
 * @category Transactions
 */
type InputViewFunctionData = {
    function: MoveFunctionId;
    typeArguments?: Array<TypeArgument>;
    functionArguments?: Array<EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes>;
    abi?: ViewFunctionABI;
};
/**
 * The data needed to generate a View Function payload in JSON format.
 * @group Implementation
 * @category Transactions
 */
type InputViewFunctionJsonData = {
    function: MoveFunctionId;
    typeArguments?: Array<MoveStructId>;
    functionArguments?: Array<MoveValue>;
};
/**
 * The payload sent to the fullnode for a JSON view request.
 * @group Implementation
 * @category Transactions
 */
type ViewFunctionJsonPayload = {
    function: MoveFunctionId;
    typeArguments: Array<MoveStructId>;
    functionArguments: Array<MoveValue>;
};
/**
 * Data required to create a view function payload and retrieve the remote ABI, including Aptos configuration.
 * @group Implementation
 * @category Transactions
 */
type InputViewFunctionDataWithRemoteABI = InputViewFunctionData & {
    aptosConfig: AptosConfig;
};
/**
 * Data needed to generate a view function, including the fetched ABI.
 * @group Implementation
 * @category Transactions
 */
type InputViewFunctionDataWithABI = InputViewFunctionData & {
    abi: ViewFunctionABI;
};
/**
 * Data needed for a generic function ABI, applicable to both view and entry functions.
 * @group Implementation
 * @category Transactions
 */
type FunctionABI = {
    typeParameters: Array<MoveFunctionGenericTypeParam>;
    parameters: Array<TypeTag>;
};
/**
 * Interface for an Entry function's ABI, enabling type checking and input conversion for ABI-based transaction submissions.
 * @group Implementation
 * @category Transactions
 */
type EntryFunctionABI = FunctionABI & {
    signers?: number;
};
/**
 * Interface for a view function's ABI, providing type checking and input conversion for ABI-based transaction submissions.
 * @group Implementation
 * @category Transactions
 */
type ViewFunctionABI = FunctionABI & {
    returnTypes: Array<TypeTag>;
};
/**
 * Arguments for generating a single signer raw transaction, used in the transaction builder flow.
 *
 * @param aptosConfig - Configuration settings for Aptos.
 * @param sender - The address of the sender.
 * @param payload - The transaction payload.
 * @param options - Optional transaction generation options.
 * @param feePayerAddress - Optional address of the fee payer.
 * @group Implementation
 * @category Transactions
 */
interface InputGenerateSingleSignerRawTransactionArgs {
    aptosConfig: AptosConfig;
    sender: AccountAddressInput;
    payload: AnyTransactionPayloadInstance;
    options?: InputGenerateTransactionOptions;
    feePayerAddress?: AccountAddressInput;
}
/**
 * Arguments for generating a multi-agent transaction, used in the `generateTransaction()` method of the transaction builder flow.
 *
 * @param aptosConfig - Configuration settings for Aptos.
 * @param sender - The address of the transaction sender.
 * @param payload - The transaction payload.
 * @param secondarySignerAddresses - List of secondary signer addresses.
 * @param options - Optional settings for transaction generation.
 * @param feePayerAddress - Optional address of the fee payer.
 * @group Implementation
 * @category Transactions
 */
interface InputGenerateMultiAgentRawTransactionArgs {
    aptosConfig: AptosConfig;
    sender: AccountAddressInput;
    payload: AnyTransactionPayloadInstance;
    secondarySignerAddresses: AccountAddressInput[];
    options?: InputGenerateTransactionOptions;
    feePayerAddress?: AccountAddressInput;
}
/**
 * A unified type for generating various transaction types.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateRawTransactionArgs = InputGenerateSingleSignerRawTransactionArgs | InputGenerateMultiAgentRawTransactionArgs;
/**
 * Unified type that holds all the return interfaces when generating different transaction types
 * @group Implementation
 * @category Transactions
 */
type AnyRawTransaction = SimpleTransaction | MultiAgentTransaction;
/**
 * The data required to simulate a transaction, typically generated by `generateTransaction()`.
 * @group Implementation
 * @category Transactions
 */
type InputSimulateTransactionData = {
    /**
     * The transaction to simulate, probably generated by `generateTransaction()`
     * @group Implementation
     * @category Transactions
     */
    transaction: AnyRawTransaction;
    /**
     * For a single signer transaction
     * @group Implementation
     * @category Transactions
     * This is optional and can be undefined to skip the public/auth key check during the transaction simulation.
     */
    signerPublicKey?: PublicKey;
    /**
     * For a fee payer or multi-agent transaction that requires additional signers in
     * @group Implementation
     * @category Transactions
     */
    secondarySignersPublicKeys?: Array<PublicKey | undefined>;
    /**
     * For a fee payer transaction (aka Sponsored Transaction)
     * @group Implementation
     * @category Transactions
     */
    feePayerPublicKey?: PublicKey;
    options?: InputSimulateTransactionOptions;
};
/**
 * Options for simulating a transaction input, including whether to estimate the gas unit price.
 * @group Implementation
 * @category Transactions
 */
type InputSimulateTransactionOptions = {
    estimateGasUnitPrice?: boolean;
    estimateMaxGasAmount?: boolean;
    estimatePrioritizedGasUnitPrice?: boolean;
};
/**
 * Holds user input data for generating a single signer transaction.
 *
 * @param sender - The address of the account sending the transaction.
 * @param data - The payload data for the transaction.
 * @param options - Optional transaction options.
 * @param withFeePayer - Indicates if the fee payer is included.
 * @param secondarySignerAddresses - Addresses for any secondary signers (not used in single signer transactions).
 * @group Implementation
 * @category Transactions
 */
interface InputGenerateSingleSignerRawTransactionData {
    sender: AccountAddressInput;
    data: InputGenerateTransactionPayloadData;
    options?: InputGenerateTransactionOptions;
    withFeePayer?: boolean;
    secondarySignerAddresses?: undefined;
}
/**
 * Holds user data input for generating a multi-agent transaction.
 *
 * @param sender - The address of the primary sender.
 * @param data - The payload data for the transaction.
 * @param secondarySignerAddresses - An array of addresses for secondary signers.
 * @param options - Optional transaction options.
 * @param withFeePayer - Indicates if a fee payer is included.
 * @group Implementation
 * @category Transactions
 */
interface InputGenerateMultiAgentRawTransactionData {
    sender: AccountAddressInput;
    data: InputGenerateTransactionPayloadData;
    secondarySignerAddresses: AccountAddressInput[];
    options?: InputGenerateTransactionOptions;
    withFeePayer?: boolean;
}
/**
 * Unified type holding user data input interfaces for generating various transaction types.
 * @group Implementation
 * @category Transactions
 */
type InputGenerateTransactionData = InputGenerateSingleSignerRawTransactionData | InputGenerateMultiAgentRawTransactionData;
interface InputSubmitTransactionDataInner {
    transaction: AnyRawTransaction;
    senderAuthenticator: AccountAuthenticator;
    feePayerAuthenticator?: AccountAuthenticator;
    additionalSignersAuthenticators?: Array<AccountAuthenticator>;
}
interface InputTransactionPluginData {
    /**
     * Additional parameters that will be passed to the transaction submitter plugin if
     * configured.
     */
    pluginParams?: Record<string, any>;
    /**
     * You can set this to override the configured transaction submitter (if any).
     * Conversely you can set this to null to ignore any configured transaction submitter.
     */
    transactionSubmitter?: TransactionSubmitter | null;
}
/**
 * Holds user data input for submitting a transaction.
 *
 * @param transaction - The raw transaction data.
 * @param senderAuthenticator - The authenticator for the sender's account.
 * @param feePayerAuthenticator - Optional authenticator for the fee payer's account.
 * @param additionalSignersAuthenticators - Optional array of authenticators for
 * additional signers.
 * @param pluginParams - Additional parameters that will be passed to the transaction
 * submitter plugin if configured.
 * @param transactionSubmitter - You can set this to override the configured transaction
 * submitter (if any). Conversely you can set this to null to ignore any configured
 * transaction submitter.
 * @group Implementation
 * @category Transactions
 */
type InputSubmitTransactionData = InputSubmitTransactionDataInner & InputTransactionPluginData;

/**
 * Different MIME types used for data interchange in transactions and responses.
 */
declare enum MimeType {
    /**
     * JSON representation, used for transaction submission and accept type JSON output
     */
    JSON = "application/json",
    /**
     * BCS representation, used for accept type BCS output
     */
    BCS = "application/x-bcs",
    /**
     * BCS representation, used for transaction submission in BCS input
     */
    BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs",
    BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs"
}
/**
 * Hexadecimal data input for functions, supporting both string and Uint8Array formats.
 */
type HexInput = string | Uint8Array;
/**
 * Variants of type tags used in the system, encompassing various data types and structures.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/language_storage.rs#L27}
 */
declare enum TypeTagVariants {
    Bool = 0,
    U8 = 1,
    U64 = 2,
    U128 = 3,
    Address = 4,
    Signer = 5,
    Vector = 6,
    Struct = 7,
    U16 = 8,
    U32 = 9,
    U256 = 10,
    Reference = 254,// This is specifically a placeholder and does not represent a real type
    Generic = 255
}
/**
 * Variants of script transaction arguments used in Rust, encompassing various data types for transaction processing.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/transaction_argument.rs#L11}
 */
declare enum ScriptTransactionArgumentVariants {
    U8 = 0,
    U64 = 1,
    U128 = 2,
    Address = 3,
    U8Vector = 4,
    Bool = 5,
    U16 = 6,
    U32 = 7,
    U256 = 8,
    Serialized = 9
}
/**
 * The payload for various transaction types in the system.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}
 */
declare enum TransactionPayloadVariants {
    Script = 0,
    EntryFunction = 2,
    Multisig = 3,
    Payload = 4
}
/**
 * The inner payload type to support orderless transactions and all future transaction types.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}
 */
declare enum TransactionInnerPayloadVariants {
    V1 = 0
}
/**
 * Executable types for transactions, which can be either a script or an entry function.
 *
 * Empty is reserved for Multisig voting transactions, which do not have an executable payload.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L685}
 */
declare enum TransactionExecutableVariants {
    Script = 0,
    EntryFunction = 1,
    Empty = 2
}
/**
 * Variants of transaction extra configurations, which can include additional settings or parameters.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L737}
 */
declare enum TransactionExtraConfigVariants {
    V1 = 0
}
/**
 * Variants of transactions used in the system.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L440}
 */
declare enum TransactionVariants {
    MultiAgentTransaction = 0,
    FeePayerTransaction = 1
}
/**
 * Variants of transaction authenticators used in the system.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L44}
 */
declare enum TransactionAuthenticatorVariant {
    Ed25519 = 0,
    MultiEd25519 = 1,
    MultiAgent = 2,
    FeePayer = 3,
    SingleSender = 4
}
/**
 * Variants of account authenticators used in transactions.
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L414}
 */
declare enum AccountAuthenticatorVariant {
    Ed25519 = 0,
    MultiEd25519 = 1,
    SingleKey = 2,
    MultiKey = 3,
    NoAccountAuthenticator = 4,
    Abstraction = 5
}
/**
 * Variants of private keys that can comply with the AIP-80 standard.
 * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md}
 */
declare enum PrivateKeyVariants {
    Ed25519 = "ed25519",
    Secp256k1 = "secp256k1"
}
/**
 * Variants of public keys used in cryptographic operations.
 */
declare enum AnyPublicKeyVariant {
    Ed25519 = 0,
    Secp256k1 = 1,
    Keyless = 3,
    FederatedKeyless = 4
}
declare function anyPublicKeyVariantToString(variant: AnyPublicKeyVariant): string;
/**
 * Variants of signature types used for cryptographic operations.
 */
declare enum AnySignatureVariant {
    Ed25519 = 0,
    Secp256k1 = 1,
    Keyless = 3
}
/**
 * Variants of ephemeral public keys used in cryptographic operations.
 */
declare enum EphemeralPublicKeyVariant {
    Ed25519 = 0
}
/**
 * Variants of ephemeral signatures used for secure communication.
 */
declare enum EphemeralSignatureVariant {
    Ed25519 = 0
}
/**
 * Variants of ephemeral certificates used in secure transactions.
 */
declare enum EphemeralCertificateVariant {
    ZkProof = 0
}
/**
 * Variants of zero-knowledge proofs used in cryptographic operations.
 */
declare enum ZkpVariant {
    Groth16 = 0
}
/**
 * BCS types
 */
type Uint8 = number;
/**
 * A 16-bit unsigned integer.
 */
type Uint16 = number;
/**
 * A 32-bit unsigned integer.
 */
type Uint32 = number;
/**
 * A 64-bit unsigned integer value.
 */
type Uint64 = bigint;
/**
 * A 128-bit unsigned integer used for precise arithmetic operations.
 */
type Uint128 = bigint;
/**
 * A 256-bit unsigned integer used for precise numerical calculations.
 */
type Uint256 = bigint;
/**
 * A number or a bigint value.
 */
type AnyNumber = number | bigint;
/**
 * Configuration options for initializing the SDK, allowing customization of its behavior and interaction with the Aptos network.
 */
type AptosSettings = {
    readonly network?: Network;
    readonly fullnode?: string;
    readonly faucet?: string;
    readonly indexer?: string;
    readonly pepper?: string;
    readonly prover?: string;
    readonly clientConfig?: ClientConfig;
    readonly client?: Client;
    readonly fullnodeConfig?: FullNodeConfig;
    readonly indexerConfig?: IndexerConfig;
    readonly faucetConfig?: FaucetConfig;
    readonly transactionGenerationConfig?: TransactionGenerationConfig;
    readonly pluginSettings?: PluginSettings;
};
/**
 * Defines the parameters for paginating query results, including the starting position and maximum number of items to return.
 * @param offset Specifies the starting position of the query result. Default is 0.
 * @param limit Specifies the maximum number of items to return. Default is 25.
 */
interface PaginationArgs {
    offset?: AnyNumber;
    limit?: number;
}
/**
 * Defines the parameters for paginating query results, including the starting position and maximum number of items to return.
 * @param cursor Specifies the starting position of the query result. Default is at the beginning if undefined.  This is not a number and must come from the API.
 * @param limit Specifies the maximum number of items to return. Default is 25.
 */
interface CursorPaginationArgs {
    cursor?: string;
    limit?: number;
}
/**
 * Represents the arguments for specifying a token standard.
 *
 * @param tokenStandard - Optional standard of the token.
 */
interface TokenStandardArg {
    tokenStandard?: TokenStandard;
}
interface OrderByArg<T extends {}> {
    orderBy?: OrderBy<T>;
}
interface WhereArg<T extends {}> {
    where?: T;
}
/**
 * QUERY TYPES
 */
/**
 * A configuration object for requests to the server, including API key, extra headers, and cookie handling options.
 */
type ClientConfig = ClientHeadersType & {
    WITH_CREDENTIALS?: boolean;
    API_KEY?: string;
};
/**
 * A configuration object for a Fullnode, allowing for the inclusion of extra headers in requests.
 */
type FullNodeConfig = ClientHeadersType;
/**
 * An Indexer configuration object for sending requests with additional headers.
 */
type IndexerConfig = ClientHeadersType;
/**
 * A configuration object for a faucet, including optional authentication and headers for requests.
 */
type FaucetConfig = ClientHeadersType & {
    AUTH_TOKEN?: string;
};
/**
 * A configuration object for default parameters for transaction generation.
 */
type TransactionGenerationConfig = {
    defaultMaxGasAmount?: number;
    defaultTxnExpirySecFromNow?: number;
};
/**
 * General type definition for client headers.
 */
type ClientHeadersType = {
    HEADERS?: Record<string, string | number | boolean>;
};
/**
 * Config for plugins. This can be used to override certain client behavior.
 */
type PluginConfig = {
    /**
     * If given, this will be used for submitting transactions instead of the default
     * implementation (which submits transactions directly via a node).
     */
    TRANSACTION_SUBMITTER?: TransactionSubmitter;
    /**
     * If true, we won't use the TRANSACTION_SUBMITTER if set.
     */
    IGNORE_TRANSACTION_SUBMITTER?: boolean;
};
type PluginSettings = Omit<PluginConfig, "IGNORE_TRANSACTION_SUBMITTER">;
/**
 * You can implement this interface and set it in {@link PluginSettings} when building a
 * client to override the default transaction submission behavior. This is useful if
 * you'd like to submit transactions via a gas station for example.
 *
 * @example
 * ```typescript
 * class MyGasStationClient implements TransactionSubmitter {
 *   async submitTransaction(
 *     args: { aptosConfig: AptosConfig } & InputSubmitTransactionData,
 *   ): Promise<PendingTransactionResponse> {
 *     // TODO: Implement the logic to submit the transaction to the gas station
 *   }
 * }
 *
 * const network = Network.MAINNET;
 * const myGasStationClient = new MyGasStationClient(network);
 * const config = new AptosConfig({
 *   network,
 *   pluginConfig: {
 *     transactionSubmitter: myGasStationClient,
 *   },
 * });
 * const aptos = new Aptos(config);
 * ```
 */
interface TransactionSubmitter {
    /**
     * Submit a transaction to the Aptos blockchain or something that will do it on your
     * behalf, for example a gas station. See the comments of {@link TransactionSubmitter} for more.
     *
     * @param args - The arguments for submitting the transaction.
     * @param args.aptosConfig - The configuration for connecting to the Aptos network.
     * @param args.transaction - The Aptos transaction data to be submitted.
     * @param args.senderAuthenticator - The account authenticator of the transaction sender.
     * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.
     * @param args.pluginParams - Optional. Additional parameters for the plugin.
     * @param args.transactionSubmitter - Optional. An override for the transaction submitter.
     *
     * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.
     * @group Implementation
     */
    submitTransaction(args: {
        aptosConfig: AptosConfig;
    } & Omit<InputSubmitTransactionData, "transactionSubmitter">): Promise<PendingTransactionResponse>;
}
/**
 * Represents a client for making requests to a service provider.
 *
 * @param Req - The type of the request payload.
 * @param Res - The type of the response payload.
 */
interface ClientRequest<Req> {
    url: string;
    method: "GET" | "POST";
    originMethod?: string;
    body?: Req;
    contentType?: string;
    params?: any;
    overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;
    headers?: Record<string, any>;
}
interface ClientResponse<Res> {
    status: number;
    statusText: string;
    data: Res;
    config?: any;
    request?: any;
    response?: any;
    headers?: any;
}
interface Client {
    /**
     * Sends a request to the specified URL with the given options.
     *
     * @param requestOptions - The options for the request.
     * @param requestOptions.url - The URL to send the request to.
     * @param requestOptions.method - The HTTP method to use, either "GET" or "POST".
     * @param requestOptions.path - An optional path to append to the URL.
     * @param requestOptions.body - The body of the request, applicable for POST requests.
     * @param requestOptions.contentType - The content type of the request body.
     * @param requestOptions.acceptType - The expected content type of the response.
     * @param requestOptions.params - Optional parameters to include in the request.
     * @param requestOptions.originMethod - An optional method to specify the origin of the request.
     * @param requestOptions.overrides - Optional configuration overrides for the request.
     */
    provider<Req, Res>(requestOptions: ClientRequest<Req>): Promise<ClientResponse<Res>>;
}
/**
 * The API request type
 *
 * @param url - the url to make the request to, i.e. https://fullnode.devnet.aptoslabs.com/v1
 * @param method - the request method "GET" | "POST"
 * @param endpoint (optional) - the endpoint to make the request to, i.e. transactions
 * @param body (optional) - the body of the request
 * @param contentType (optional) - the content type to set the `content-type` header to,
 * by default is set to `application/json`
 * @param params (optional) - query params to add to the request
 * @param originMethod (optional) - the local method the request came from
 * @param overrides (optional) - a `ClientConfig` object type to override request data
 */
type AptosRequest = {
    url: string;
    method: "GET" | "POST";
    path?: string;
    body?: any;
    contentType?: string;
    acceptType?: string;
    params?: Record<string, string | AnyNumber | boolean | undefined>;
    originMethod?: string;
    overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;
};
/**
 * The API response type
 *
 * @param status - the response status. i.e. 200
 * @param statusText - the response message
 * @param data the response data
 * @param url the url the request was made to
 * @param headers the response headers
 * @param config (optional) - the request object
 * @param request (optional) - the request object
 */
interface AptosResponse<Req, Res> {
    status: number;
    statusText: string;
    data: Res;
    url: string;
    headers: any;
    config?: any;
    request?: Req;
}
/**
 * The ledger version of transactions, defaulting to the latest version if not specified.
 */
type LedgerVersionArg = {
    ledgerVersion?: AnyNumber;
};
/**
 * RESPONSE TYPES
 */
/**
 * The output of the estimate gas API, including the deprioritized estimate for the gas unit price.
 */
type GasEstimation = {
    /**
     * The deprioritized estimate for the gas unit price
     */
    deprioritized_gas_estimate?: number;
    /**
     * The current estimate for the gas unit price
     */
    gas_estimate: number;
    /**
     * The prioritized estimate for the gas unit price
     */
    prioritized_gas_estimate?: number;
};
type MoveResource<T = {}> = {
    type: MoveStructId;
    data: T;
};
/**
 * The data associated with an account, including its sequence number.
 */
type AccountData = {
    sequence_number: string;
    authentication_key: string;
};
/**
 * A Move module containing an address.
 */
type MoveModuleBytecode = {
    bytecode: string;
    abi?: MoveModule;
};
/**
 * TRANSACTION TYPES
 */
/**
 * Different types of transaction responses that can occur in the system.
 */
declare enum TransactionResponseType {
    Pending = "pending_transaction",
    User = "user_transaction",
    Genesis = "genesis_transaction",
    BlockMetadata = "block_metadata_transaction",
    StateCheckpoint = "state_checkpoint_transaction",
    Validator = "validator_transaction",
    BlockEpilogue = "block_epilogue_transaction"
}
/**
 * The response for a transaction, which can be either pending or committed.
 */
type TransactionResponse = PendingTransactionResponse | CommittedTransactionResponse;
/**
 * The response for a committed transaction, which can be one of several transaction types.
 */
type CommittedTransactionResponse = UserTransactionResponse | GenesisTransactionResponse | BlockMetadataTransactionResponse | StateCheckpointTransactionResponse | ValidatorTransactionResponse | BlockEpilogueTransactionResponse;
/**
 * Determine if the given transaction response is currently pending.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the transaction is pending.
 */
declare function isPendingTransactionResponse(response: TransactionResponse): response is PendingTransactionResponse;
/**
 * Determines if the given transaction response is a user transaction.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the transaction is of type User.
 */
declare function isUserTransactionResponse(response: TransactionResponse): response is UserTransactionResponse;
/**
 * Determines if the given transaction response is a Genesis transaction.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the transaction is a Genesis transaction.
 */
declare function isGenesisTransactionResponse(response: TransactionResponse): response is GenesisTransactionResponse;
/**
 * Determine if the given transaction response is of type BlockMetadata.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the response is a BlockMetadata transaction.
 */
declare function isBlockMetadataTransactionResponse(response: TransactionResponse): response is BlockMetadataTransactionResponse;
/**
 * Determines if the provided transaction response is a state checkpoint transaction.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the transaction response is of type StateCheckpoint.
 */
declare function isStateCheckpointTransactionResponse(response: TransactionResponse): response is StateCheckpointTransactionResponse;
/**
 * Determine if the given transaction response is of type Validator.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the transaction response is a Validator type.
 */
declare function isValidatorTransactionResponse(response: TransactionResponse): response is ValidatorTransactionResponse;
/**
 * Determines if the given transaction response is of the type Block Epilogue.
 *
 * @param response - The transaction response to evaluate.
 * @returns A boolean indicating whether the response is a Block Epilogue transaction.
 */
declare function isBlockEpilogueTransactionResponse(response: TransactionResponse): response is BlockEpilogueTransactionResponse;
/**
 * The response for a pending transaction, indicating that the transaction is still being processed.
 */
type PendingTransactionResponse = {
    type: TransactionResponseType.Pending;
    hash: string;
    sender: string;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: TransactionPayloadResponse;
    signature?: TransactionSignature;
};
/**
 * The response structure for a user transaction.
 */
type UserTransactionResponse = {
    type: TransactionResponseType.User;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    sender: string;
    sequence_number: string;
    replay_protection_nonce: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: TransactionPayloadResponse;
    signature?: TransactionSignature;
    /**
     * Events generated by the transaction
     */
    events: Array<Event>;
    timestamp: string;
};
/**
 * The response for a genesis transaction, indicating the type of transaction.
 */
type GenesisTransactionResponse = {
    type: TransactionResponseType.Genesis;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash?: string;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    payload: GenesisPayload;
    /**
     * Events emitted during genesis
     */
    events: Array<Event>;
};
/**
 * The structure representing a blockchain block with its height.
 */
type BlockMetadataTransactionResponse = {
    type: TransactionResponseType.BlockMetadata;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    id: string;
    epoch: string;
    round: string;
    /**
     * The events emitted at the block creation
     */
    events: Array<Event>;
    /**
     * Previous block votes
     */
    previous_block_votes_bitvec: Array<number>;
    proposer: string;
    /**
     * The indices of the proposers who failed to propose
     */
    failed_proposer_indices: Array<number>;
    timestamp: string;
};
/**
 * The response for a state checkpoint transaction, indicating the type of transaction.
 */
type StateCheckpointTransactionResponse = {
    type: TransactionResponseType.StateCheckpoint;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    timestamp: string;
};
/**
 * The response for a validator transaction, indicating the type of transaction.
 */
type ValidatorTransactionResponse = {
    type: TransactionResponseType.Validator;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    /**
     * The events emitted by the validator transaction
     */
    events: Array<Event>;
    timestamp: string;
};
/**
 * Describes the gas state of the block, indicating whether the block gas limit has been reached.
 */
type BlockEndInfo = {
    block_gas_limit_reached: boolean;
    block_output_limit_reached: boolean;
    block_effective_block_gas_units: number;
    block_approx_output_size: number;
};
/**
 * A transaction executed at the end of a block that tracks data from the entire block.
 */
type BlockEpilogueTransactionResponse = {
    type: TransactionResponseType.BlockEpilogue;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    timestamp: string;
    block_end_info: BlockEndInfo | null;
};
/**
 * WRITESET CHANGE TYPES
 */
/**
 * A union type that encompasses both script and direct write sets for data operations.
 */
type WriteSetChange = WriteSetChangeDeleteModule | WriteSetChangeDeleteResource | WriteSetChangeDeleteTableItem | WriteSetChangeWriteModule | WriteSetChangeWriteResource | WriteSetChangeWriteTableItem;
/**
 * The structure for a module deletion change in a write set.
 */
type WriteSetChangeDeleteModule = {
    type: string;
    address: string;
    /**
     * State key hash
     */
    state_key_hash: string;
    module: MoveModuleId;
};
/**
 * The payload for a resource deletion in a write set change.
 */
type WriteSetChangeDeleteResource = {
    type: string;
    address: string;
    state_key_hash: string;
    resource: string;
};
/**
 * The payload for a write set change that deletes a table item.
 */
type WriteSetChangeDeleteTableItem = {
    type: string;
    state_key_hash: string;
    handle: string;
    key: string;
    data?: DeletedTableData;
};
/**
 * The structure for a write module change in a write set.
 */
type WriteSetChangeWriteModule = {
    type: string;
    address: string;
    state_key_hash: string;
    data: MoveModuleBytecode;
};
/**
 * The resource associated with a write set change, identified by its type.
 */
type WriteSetChangeWriteResource = {
    type: string;
    address: string;
    state_key_hash: string;
    data: MoveResource;
};
/**
 * The structure for a write operation on a table in a write set change.
 */
type WriteSetChangeWriteTableItem = {
    type: string;
    state_key_hash: string;
    handle: string;
    key: string;
    value: string;
    data?: DecodedTableData;
};
/**
 * The decoded data for a table, including its key in JSON format.
 */
type DecodedTableData = {
    /**
     * Key of table in JSON
     */
    key: any;
    /**
     * Type of key
     */
    key_type: string;
    /**
     * Value of table in JSON
     */
    value: any;
    /**
     * Type of value
     */
    value_type: string;
};
/**
 * Data for a deleted table entry.
 */
type DeletedTableData = {
    /**
     * Deleted key
     */
    key: any;
    /**
     * Deleted key type
     */
    key_type: string;
};
/**
 * The payload for a transaction response, which can be an entry function, script, or multisig payload.
 */
type TransactionPayloadResponse = EntryFunctionPayloadResponse | ScriptPayloadResponse | MultisigPayloadResponse;
/**
 * The response payload for an entry function, containing the type of the entry.
 */
type EntryFunctionPayloadResponse = {
    type: string;
    function: MoveFunctionId;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<string>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};
/**
 * The payload for a script response, containing the type of the script.
 */
type ScriptPayloadResponse = {
    type: string;
    code: MoveScriptBytecode;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<string>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};
/**
 * The response payload for a multisig transaction, containing the type of the transaction.
 */
type MultisigPayloadResponse = {
    type: string;
    multisig_address: string;
    transaction_payload?: EntryFunctionPayloadResponse;
};
/**
 * The payload for the genesis block containing the type of the payload.
 */
type GenesisPayload = {
    type: string;
    write_set: WriteSet;
};
/**
 * The bytecode for a Move script.
 */
type MoveScriptBytecode = {
    bytecode: string;
    abi?: MoveFunction;
};
/**
 * JSON representations of transaction signatures returned from the node API.
 */
type TransactionSignature = TransactionEd25519Signature | TransactionSecp256k1Signature | TransactionMultiEd25519Signature | TransactionMultiAgentSignature | TransactionFeePayerSignature | TransactionSingleSenderSignature;
/**
 * Determine if the provided signature is an Ed25519 signature.
 * This function checks for the presence of the "signature" property
 * and verifies that its value is "ed25519_signature".
 *
 * @param signature - The transaction signature to be checked.
 * @returns A boolean indicating whether the signature is an Ed25519 signature.
 */
declare function isEd25519Signature(signature: TransactionSignature): signature is TransactionEd25519Signature;
/**
 * Determine if the provided signature is a valid secp256k1 ECDSA signature.
 *
 * @param signature - The transaction signature to validate.
 * @returns A boolean indicating whether the signature is a secp256k1 ECDSA signature.
 */
declare function isSecp256k1Signature(signature: TransactionSignature): signature is TransactionFeePayerSignature;
/**
 * Determine if the provided transaction signature is a multi-agent signature.
 *
 * @param signature - The transaction signature to evaluate.
 * @returns A boolean indicating whether the signature is a multi-agent signature.
 */
declare function isMultiAgentSignature(signature: TransactionSignature): signature is TransactionMultiAgentSignature;
/**
 * Determine if the provided signature is a fee payer signature.
 *
 * @param signature - The transaction signature to evaluate.
 * @returns A boolean indicating whether the signature is a fee payer signature.
 */
declare function isFeePayerSignature(signature: TransactionSignature): signature is TransactionFeePayerSignature;
/**
 * Determine if the provided signature is of type "multi_ed25519_signature".
 *
 * @param signature - The transaction signature to check.
 * @returns A boolean indicating whether the signature is a multi-ed25519 signature.
 */
declare function isMultiEd25519Signature(signature: TransactionSignature): signature is TransactionMultiEd25519Signature;
/**
 * Determine if the provided signature is of type "single_sender".
 *
 * @param signature - The transaction signature to check.
 * @returns A boolean indicating whether the signature is a single-sender signature.
 */
declare function isSingleSenderSignature(signature: TransactionSignature): signature is TransactionSingleSenderSignature;
/**
 * The signature for a transaction using the Ed25519 algorithm.
 */
type TransactionEd25519Signature = {
    type: string;
    public_key: string;
    signature: "ed25519_signature";
};
/**
 * The structure for a Secp256k1 signature in a transaction.
 */
type TransactionSecp256k1Signature = {
    type: string;
    public_key: string;
    signature: "secp256k1_ecdsa_signature";
};
/**
 * The structure for a multi-signature transaction using Ed25519.
 */
type TransactionSingleSenderSignature = {
    type: "single_sender";
    public_key: {
        value: string;
        type: string;
    };
    signature: {
        value: string;
        type: string;
    };
};
/**
 * The structure for a multi-signature transaction using Ed25519.
 */
type TransactionMultiEd25519Signature = {
    type: "multi_ed25519_signature";
    /**
     * The public keys for the Ed25519 signature
     */
    public_keys: Array<string>;
    /**
     * Signature associated with the public keys in the same order
     */
    signatures: Array<string>;
    /**
     * The number of signatures required for a successful transaction
     */
    threshold: number;
    bitmap: string;
};
/**
 * The structure for a multi-agent signature in a transaction.
 */
type TransactionMultiAgentSignature = {
    type: "multi_agent_signature";
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<string>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
};
/**
 * The signature of the fee payer in a transaction.
 */
type TransactionFeePayerSignature = {
    type: "fee_payer_signature";
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<string>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
    fee_payer_address: string;
    fee_payer_signer: AccountSignature;
};
/**
 * The union of all single account signatures, including Ed25519, Secp256k1, and MultiEd25519 signatures.
 */
type AccountSignature = TransactionEd25519Signature | TransactionSecp256k1Signature | TransactionMultiEd25519Signature;
type WriteSet = ScriptWriteSet | DirectWriteSet;
/**
 * The set of properties for writing scripts, including the type of script.
 */
type ScriptWriteSet = {
    type: string;
    execute_as: string;
    script: ScriptPayloadResponse;
};
/**
 * The set of direct write operations, identified by a type string.
 */
type DirectWriteSet = {
    type: string;
    changes: Array<WriteSetChange>;
    events: Array<Event>;
};
/**
 * The structure for an event's unique identifier, including its creation number.
 */
/**
 * The structure for an event, identified by a unique GUID.
 */
type EventGuid = {
    creation_number: string;
    account_address: string;
};
type Event = {
    guid: EventGuid;
    sequence_number: string;
    type: string;
    /**
     * The JSON representation of the event
     */
    data: any;
};
/**
 * A number representing a Move uint8 type.
 */
type MoveUint8Type = number;
/**
 * A 16-bit unsigned integer used in the Move programming language.
 */
type MoveUint16Type = number;
/**
 * A 32-bit unsigned integer type used in Move programming.
 */
type MoveUint32Type = number;
/**
 * A string representation of a 64-bit unsigned integer used in Move programming.
 */
type MoveUint64Type = string;
/**
 * A string representing a 128-bit unsigned integer in the Move programming language.
 */
type MoveUint128Type = string;
/**
 * A string representation of a 256-bit unsigned integer used in Move programming.
 */
type MoveUint256Type = string;
/**
 * A string representing a Move address.
 */
type MoveAddressType = string;
/**
 * The type for identifying objects to be moved within the system.
 */
type MoveObjectType = string;
/**
 * The type for move options, which can be a MoveType, null, or undefined.
 */
type MoveOptionType = MoveType | null | undefined;
/**
 * A structure representing a move with a name.
 */
type MoveStructId = `${string}::${string}::${string}`;
/**
 * The move function containing its name. Same as MoveStructId since it reads weird to take a StructId for a Function.
 */
type MoveFunctionId = MoveStructId;
type MoveStructType = {};
/**
 * A union type that encompasses various data types used in Move, including primitive types, address types, object types, and
 * arrays of MoveType.
 */
type MoveType = boolean | string | MoveUint8Type | MoveUint16Type | MoveUint32Type | MoveUint64Type | MoveUint128Type | MoveUint256Type | MoveAddressType | MoveObjectType | MoveStructType | Array<MoveType>;
/**
 * Possible Move values acceptable by move functions (entry, view)
 *
 * Map of a Move value to the corresponding TypeScript value
 *
 * `Bool -> boolean`
 *
 * `u8, u16, u32 -> number`
 *
 * `u64, u128, u256 -> string`
 *
 * `String -> string`
 *
 * `Address -> 0x${string}`
 *
 * `Struct - 0x${string}::${string}::${string}`
 *
 * `Object -> 0x${string}`
 *
 * `Vector -> Array<MoveValue>`
 *
 * `Option -> MoveValue | null | undefined`
 */
type MoveValue = boolean | string | MoveUint8Type | MoveUint16Type | MoveUint32Type | MoveUint64Type | MoveUint128Type | MoveUint256Type | MoveAddressType | MoveObjectType | MoveStructId | MoveOptionType | Array<MoveValue>;
/**
 * A string representation of a Move module, formatted as `module_name::function_name`.
 * Module names are case-sensitive.
 */
type MoveModuleId = `${string}::${string}`;
/**
 * Specifies the visibility levels for move functions, controlling access permissions.
 */
declare enum MoveFunctionVisibility {
    PRIVATE = "private",
    PUBLIC = "public",
    FRIEND = "friend"
}
/**
 * Abilities related to moving items within the system.
 */
declare enum MoveAbility {
    STORE = "store",
    DROP = "drop",
    KEY = "key",
    COPY = "copy"
}
/**
 * Move abilities associated with the generic type parameter of a function.
 */
type MoveFunctionGenericTypeParam = {
    constraints: Array<MoveAbility>;
};
/**
 * A field in a Move struct, identified by its name.
 */
type MoveStructField = {
    name: string;
    type: string;
};
/**
 * A Move module
 */
type MoveModule = {
    address: string;
    name: string;
    /**
     * Friends of the module
     */
    friends: Array<MoveModuleId>;
    /**
     * Public functions of the module
     */
    exposed_functions: Array<MoveFunction>;
    /**
     * Structs of the module
     */
    structs: Array<MoveStruct>;
};
/**
 * A move struct
 */
type MoveStruct = {
    name: string;
    /**
     * Whether the struct is a native struct of Move
     */
    is_native: boolean;
    /**
     * Whether the struct is a module event (aka v2 event). This will be false for v1
     * events because the value is derived from the #[event] attribute on the struct in
     * the Move source code. This attribute is only relevant for v2 events.
     */
    is_event: boolean;
    /**
     * Abilities associated with the struct
     */
    abilities: Array<MoveAbility>;
    /**
     * Generic types associated with the struct
     */
    generic_type_params: Array<MoveFunctionGenericTypeParam>;
    /**
     * Fields associated with the struct
     */
    fields: Array<MoveStructField>;
};
/**
 * Move function
 */
type MoveFunction = {
    name: string;
    visibility: MoveFunctionVisibility;
    /**
     * Whether the function can be called as an entry function directly in a transaction
     */
    is_entry: boolean;
    /**
     * Whether the function is a view function or not
     */
    is_view: boolean;
    /**
     * Generic type params associated with the Move function
     */
    generic_type_params: Array<MoveFunctionGenericTypeParam>;
    /**
     * Parameters associated with the move function
     */
    params: Array<string>;
    /**
     * Return type of the function
     */
    return: Array<string>;
};
/**
 * Roles that can be assigned within the system, indicating different levels of access and functionality.
 */
declare enum RoleType {
    VALIDATOR = "validator",
    FULL_NODE = "full_node"
}
/**
 * Information about the current blockchain ledger, including its chain ID.
 */
type LedgerInfo = {
    /**
     * Chain ID of the current chain
     */
    chain_id: number;
    epoch: string;
    ledger_version: string;
    oldest_ledger_version: string;
    ledger_timestamp: string;
    node_role: RoleType;
    oldest_block_height: string;
    block_height: string;
    /**
     * Git hash of the build of the API endpoint.  Can be used to determine the exact
     * software version used by the API endpoint.
     */
    git_hash?: string;
};
/**
 * A Block type
 */
type Block = {
    block_height: string;
    block_hash: string;
    block_timestamp: string;
    first_version: string;
    last_version: string;
    /**
     * The transactions in the block in sequential order
     */
    transactions?: Array<TransactionResponse>;
};
/**
 * The request payload for the GetTableItem API.
 */
type TableItemRequest = {
    key_type: MoveValue;
    value_type: MoveValue;
    /**
     * The value of the table item's key
     */
    key: any;
};
/**
 * A list of supported Authentication Key schemes in Aptos, consisting of combinations of signing schemes and derive schemes.
 */
type AuthenticationKeyScheme = SigningScheme | DeriveScheme;
/**
 * Different schemes for signing keys used in cryptographic operations.
 */
declare enum SigningScheme {
    /**
     * For Ed25519PublicKey
     */
    Ed25519 = 0,
    /**
     * For MultiEd25519PublicKey
     */
    MultiEd25519 = 1,
    /**
     * For SingleKey ecdsa
     */
    SingleKey = 2,
    MultiKey = 3
}
/**
 * Specifies the signing schemes available for cryptographic operations.
 */
declare enum SigningSchemeInput {
    /**
     * For Ed25519PublicKey
     */
    Ed25519 = 0,
    /**
     * For Secp256k1Ecdsa
     */
    Secp256k1Ecdsa = 2
}
/**
 * Specifies the schemes for deriving account addresses from various data sources.
 */
declare enum DeriveScheme {
    /**
     * Derives an address using an AUID, used for objects
     */
    DeriveAuid = 251,
    /**
     * Derives an address from another object address
     */
    DeriveObjectAddressFromObject = 252,
    /**
     * Derives an address from a GUID, used for objects
     */
    DeriveObjectAddressFromGuid = 253,
    /**
     * Derives an address from seed bytes, used for named objects
     */
    DeriveObjectAddressFromSeed = 254,
    /**
     * Derives an address from seed bytes, used for resource accounts
     */
    DeriveResourceAccountAddress = 255
}
/**
 * Options for configuring the behavior of the waitForTransaction() function.
 */
type WaitForTransactionOptions = {
    timeoutSecs?: number;
    checkSuccess?: boolean;
    waitForIndexer?: boolean;
};
/**
 * Input type to generate an account using the Ed25519 signing scheme.
 */
type GenerateAccountWithEd25519 = {
    scheme: SigningSchemeInput.Ed25519;
    legacy: boolean;
};
/**
 * Input type to generate an account with a Single Signer using Secp256k1.
 */
type GenerateAccountWithSingleSignerSecp256k1Key = {
    scheme: SigningSchemeInput.Secp256k1Ecdsa;
    legacy?: false;
};
type GenerateAccount = GenerateAccountWithEd25519 | GenerateAccountWithSingleSignerSecp256k1Key;

/**
 * This interface exists to define Deserializable<T> inputs for functions that
 * deserialize a byte buffer into a type T.
 * It is not intended to be implemented or extended, because Typescript has no support
 * for static methods in interfaces.
 *
 * @template T - The type that this will deserialize into.
 * @group Implementation
 * @category BCS
 */
interface Deserializable<T> {
    /**
     * Deserializes the buffered bytes into an instance of the specified class type.
     * This function provides an alternative syntax for deserialization, allowing users to call
     * `deserializer.deserialize(MyClass)` instead of `MyClass.deserialize(deserializer)`.
     *
     * @param deserializer - The deserializer instance with the buffered bytes.
     * @returns The deserialized value of class type T.
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));
     * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function
     * // value is now an instance of MyClass
     * // equivalent to `const value = MyClass.deserialize(deserializer)`
     * ```
     * @group Implementation
     * @category BCS
     */
    deserialize(deserializer: Deserializer): T;
}
/**
 * A class that provides methods for deserializing various data types from a byte buffer.
 * It supports deserialization of primitive types, strings, and complex objects using a BCS (Binary Common Serialization) layout.
 * @group Implementation
 * @category BCS
 */
declare class Deserializer {
    private buffer;
    private offset;
    /**
     * Creates a new instance of the class with a copy of the provided data buffer.
     * This prevents outside mutation of the buffer.
     *
     * @param data - The data to be copied into the internal buffer as a Uint8Array.
     * @group Implementation
     * @category BCS
     */
    constructor(data: Uint8Array);
    static fromHex(hex: HexInput): Deserializer;
    /**
     * Reads a specified number of bytes from the buffer and advances the offset.
     *
     * @param length - The number of bytes to read from the buffer.
     * @throws Throws an error if the read operation exceeds the buffer's length.
     * @group Implementation
     * @category BCS
     */
    private read;
    /**
     * Returns the number of bytes remaining in the buffer.
     *
     * This information is useful to determine if there's more data to be read.
     *
     * @returns The number of bytes remaining in the buffer.
     * @group Implementation
     * @category BCS
     */
    remaining(): number;
    /**
     * Asserts that the buffer has no remaining bytes.
     *
     * @throws {Error} Throws an error if there are remaining bytes in the buffer.
     * @group Implementation
     * @category BCS
     */
    assertFinished(): void;
    /**
     * Deserializes a UTF-8 encoded string from a byte array. It first reads the length of the string in bytes,
     * followed by the actual byte content, and decodes it into a string.
     *
     * BCS layout for "string": string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     *
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * assert(deserializer.deserializeStr() === "1234abcd");
     * ```
     * @group Implementation
     * @category BCS
     */
    deserializeStr(): string;
    /**
     * @deprecated use `deserializeOption("string")` instead.
     *
     * The BCS layout for Optional<String> is 0 if none, else 1 followed by the string length and string content.
     * @returns The deserialized string if it exists, otherwise undefined.
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([0x00]));
     * assert(deserializer.deserializeOptionStr() === undefined);
     * const deserializer = new Deserializer(new Uint8Array([1, 8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * assert(deserializer.deserializeOptionStr() === "1234abcd");
     * ```
     */
    deserializeOptionStr(): string | undefined;
    /**
     * Deserializes an optional value from the buffer.
     *
     * The BCS layout for Optional<T> starts with a boolean byte (0 if none, 1 if some),
     * followed by the value if present.
     *
     * @template T - The type of the value to deserialize
     * @param type - Either a Deserializable class or one of the string literals: "string", "bytes", or "fixedBytes"
     * @param len - Required length when type is "fixedBytes", ignored otherwise
     * @returns The deserialized value if present, undefined otherwise
     *
     * @throws {Error} When "fixedBytes" is specified without a length
     *
     * @example
     * ```typescript
     * // Deserialize an optional string
     * const deserializer = new Deserializer(new Uint8Array([1, 3, 97, 98, 99]));
     * const optStr = deserializer.deserializeOption("string");
     * // optStr === "abc"
     *
     * // Deserialize an optional custom type
     * const deserializer = new Deserializer(new Uint8Array([0]));
     * const optValue = deserializer.deserializeOption(MyClass);
     * // optValue === undefined
     *
     * // Deserialize optional bytes
     * const deserializer = new Deserializer(new Uint8Array([1, 3, 1, 2, 3]));
     * const optBytes = deserializer.deserializeOption("bytes");
     * // optBytes === Uint8Array[1, 2, 3]
     *
     * // Deserialize optional fixed bytes
     * const deserializer = new Deserializer(new Uint8Array([1, 1, 2, 3, 4]));
     * const optBytes = deserializer.deserializeOption("fixedBytes", 4);
     * // optBytes === Uint8Array[1, 2, 3, 4]
     * ```
     * @group Implementation
     * @category BCS
     */
    deserializeOption(type: "string"): string | undefined;
    deserializeOption(type: "bytes"): Uint8Array | undefined;
    deserializeOption(type: "fixedBytes", len: number): Uint8Array | undefined;
    deserializeOption<T>(type: Deserializable<T>): T | undefined;
    /**
     * Deserializes an array of bytes.
     *
     * The BCS layout for "bytes" consists of a bytes_length followed by the bytes themselves, where bytes_length is a u32 integer
     * encoded as a uleb128 integer, indicating the length of the bytes array.
     *
     * @returns {Uint8Array} The deserialized array of bytes.
     * @group Implementation
     * @category BCS
     */
    deserializeBytes(): Uint8Array;
    /**
     * Deserializes an array of bytes of a specified length.
     *
     * @param len - The number of bytes to read from the source.
     * @group Implementation
     * @category BCS
     */
    deserializeFixedBytes(len: number): Uint8Array;
    /**
     * Deserializes a boolean value from a byte stream.
     *
     * The BCS layout for a boolean uses one byte, where "0x01" represents true and "0x00" represents false.
     * An error is thrown if the byte value is not valid.
     *
     * @returns The deserialized boolean value.
     * @throws Throws an error if the boolean value is invalid.
     * @group Implementation
     * @category BCS
     */
    deserializeBool(): boolean;
    /**
     * Deserializes a uint8 number from the binary data.
     *
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     *
     * @returns {number} The deserialized uint8 number.
     * @group Implementation
     * @category BCS
     */
    deserializeU8(): Uint8;
    /**
     * Deserializes a uint16 number from a binary format in little-endian representation.
     *
     * BCS layout for "uint16": Two bytes.
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
     * assert(deserializer.deserializeU16() === 4660);
     * ```
     * @group Implementation
     * @category BCS
     */
    deserializeU16(): Uint16;
    /**
     * Deserializes a uint32 number from a binary format in little-endian representation.
     *
     * BCS layout for "uint32": Four bytes.
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU32() === 305419896);
     * ```
     * @group Implementation
     * @category BCS
     */
    deserializeU32(): Uint32;
    /**
     * Deserializes a uint64 number.
     *
     * This function combines two 32-bit values to return a 64-bit unsigned integer in little-endian representation.
     * @example
     * ```typescript
     * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU64() === 1311768467750121216);
     * ```
     * @group Implementation
     * @category BCS
     */
    deserializeU64(): Uint64;
    /**
     * Deserializes a uint128 number from its binary representation.
     * This function combines two 64-bit values to return a single uint128 value in little-endian format.
     *
     * @returns {BigInt} The deserialized uint128 number.
     * @group Implementation
     * @category BCS
     */
    deserializeU128(): Uint128;
    /**
     * Deserializes a uint256 number from its binary representation.
     *
     * The BCS layout for "uint256" consists of thirty-two bytes in little-endian format.
     *
     * @returns {BigInt} The deserialized uint256 number.
     * @group Implementation
     * @category BCS
     */
    deserializeU256(): Uint256;
    /**
     * Deserializes a uleb128 encoded uint32 number.
     *
     * This function is used for interpreting lengths of variable-length sequences and tags of enum values in BCS encoding.
     *
     * @throws {Error} Throws an error if the parsed value exceeds the maximum uint32 number.
     * @returns {number} The deserialized uint32 value.
     * @group Implementation
     * @category BCS
     */
    deserializeUleb128AsU32(): Uint32;
    /**
     * Helper function that primarily exists to support alternative syntax for deserialization.
     * That is, if we have a `const deserializer: new Deserializer(...)`, instead of having to use
     * `MyClass.deserialize(deserializer)`, we can call `deserializer.deserialize(MyClass)`.
     *
     * @example const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));
     * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function
     * // value is now an instance of MyClass
     * // equivalent to `const value = MyClass.deserialize(deserializer)`
     * @param cls The BCS-deserializable class to deserialize the buffered bytes into.
     *
     * @returns the deserialized value of class type T
     * @group Implementation
     * @category BCS
     */
    deserialize<T>(cls: Deserializable<T>): T;
    /**
     * Deserializes an array of BCS Deserializable values given an existing Deserializer instance with a loaded byte buffer.
     *
     * @param cls The BCS-deserializable class to deserialize the buffered bytes into.
     * @returns An array of deserialized values of type T.
     * @example
     * // serialize a vector of addresses
     * const addresses = new Array<AccountAddress>(
     *   AccountAddress.from("0x1"),
     *   AccountAddress.from("0x2"),
     *   AccountAddress.from("0xa"),
     *   AccountAddress.from("0xb"),
     * );
     * const serializer = new Serializer();
     * serializer.serializeVector(addresses);
     * const serializedBytes = serializer.toUint8Array();
     *
     * // deserialize the bytes into an array of addresses
     * const deserializer = new Deserializer(serializedBytes);
     * const deserializedAddresses = deserializer.deserializeVector(AccountAddress);
     * // deserializedAddresses is now an array of AccountAddress instances
     * @group Implementation
     * @category BCS
     */
    deserializeVector<T>(cls: Deserializable<T>): Array<T>;
}

/**
 * Represents an account authenticator that can handle multiple authentication variants.
 * This class serves as a base for different types of account authenticators, allowing for serialization
 * and deserialization of various authenticator types.
 *
 * @extends Serializable
 * @group Implementation
 * @category Transactions
 */
declare abstract class AccountAuthenticator extends Serializable {
    abstract serialize(serializer: Serializer): void;
    /**
     * Deserializes an AccountAuthenticator from the provided deserializer.
     * This function helps in reconstructing the AccountAuthenticator object based on the variant index.
     *
     * @param deserializer - The deserializer instance used to read the serialized data.
     * @group Implementation
     * @category Transactions
     */
    static deserialize(deserializer: Deserializer): AccountAuthenticator;
    /**
     * Determines if the current instance is an Ed25519 account authenticator.
     *
     * @returns {boolean} True if the instance is of type AccountAuthenticatorEd25519, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isEd25519(): this is AccountAuthenticatorEd25519;
    /**
     * Determines if the current instance is of type AccountAuthenticatorMultiEd25519.
     *
     * @returns {boolean} True if the instance is a multi-signature Ed25519 account authenticator, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isMultiEd25519(): this is AccountAuthenticatorMultiEd25519;
    /**
     * Determines if the current instance is of the type AccountAuthenticatorSingleKey.
     *
     * @returns {boolean} True if the instance is an AccountAuthenticatorSingleKey, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isSingleKey(): this is AccountAuthenticatorSingleKey;
    /**
     * Determine if the current instance is of type AccountAuthenticatorMultiKey.
     *
     * @returns {boolean} Returns true if the instance is an AccountAuthenticatorMultiKey, otherwise false.
     * @group Implementation
     * @category Transactions
     */
    isMultiKey(): this is AccountAuthenticatorMultiKey;
}
/**
 * Represents an Ed25519 transaction authenticator for multi-signer transactions.
 * This class encapsulates the account's Ed25519 public key and signature.
 *
 * @param public_key - The Ed25519 public key associated with the account.
 * @param signature - The Ed25519 signature for the account.
 * @group Implementation
 * @category Transactions
 */
declare class AccountAuthenticatorEd25519 extends AccountAuthenticator {
    readonly public_key: Ed25519PublicKey;
    readonly signature: Ed25519Signature;
    /**
     * Creates an instance of the class with the specified public keys and signatures.
     *
     * @param public_key The public key used for verification.
     * @param signature The signatures corresponding to the public keys.
     * @group Implementation
     * @category Transactions
     */
    constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature);
    /**
     * Serializes the account authenticator data into the provided serializer.
     * This function captures the multi-key variant, public keys, and signatures for serialization.
     *
     * @param serializer - The serializer instance used to perform the serialization.
     * @group Implementation
     * @category Transactions
     */
    serialize(serializer: Serializer): void;
    /**
     * Loads an instance of AccountAuthenticatorMultiKey from the provided deserializer.
     * This function helps in reconstructing the authenticator object using the deserialized public keys and signatures.
     *
     * @param deserializer - The deserializer used to extract the necessary data for loading the authenticator.
     * @group Implementation
     * @category Transactions
     */
    static load(deserializer: Deserializer): AccountAuthenticatorEd25519;
}
/**
 * Represents a transaction authenticator for Multi Ed25519, designed for multi-signer transactions.
 *
 * @param public_key - The MultiEd25519 public key of the account.
 * @param signature - The MultiEd25519 signature of the account.
 * @group Implementation
 * @category Transactions
 */
declare class AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {
    readonly public_key: MultiEd25519PublicKey;
    readonly signature: MultiEd25519Signature;
    constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorMultiEd25519;
}
/**
 * Represents an account authenticator that utilizes a single key for signing.
 * This class is designed to handle authentication using a public key and its corresponding signature.
 *
 * @param public_key - The public key used for authentication.
 * @param signature - The signature associated with the public key.
 * @group Implementation
 * @category Transactions
 */
declare class AccountAuthenticatorSingleKey extends AccountAuthenticator {
    readonly public_key: AnyPublicKey;
    readonly signature: AnySignature;
    constructor(public_key: AnyPublicKey, signature: AnySignature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorSingleKey;
}
/**
 * Represents an account authenticator that supports multiple keys and signatures for multi-signature scenarios.
 *
 * @param public_keys - The public keys used for authentication.
 * @param signatures - The signatures corresponding to the public keys.
 * @group Implementation
 * @category Transactions
 */
declare class AccountAuthenticatorMultiKey extends AccountAuthenticator {
    readonly public_keys: MultiKey;
    readonly signatures: MultiKeySignature;
    constructor(public_keys: MultiKey, signatures: MultiKeySignature);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorMultiKey;
}
/**
 * AccountAuthenticatorNoAccountAuthenticator for no account authenticator
 * It represents the absence of a public key for transaction simulation.
 * It allows skipping the public/auth key check during the simulation.
 */
declare class AccountAuthenticatorNoAccountAuthenticator extends AccountAuthenticator {
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorNoAccountAuthenticator;
}
declare class AccountAuthenticatorAbstraction extends AccountAuthenticator {
    readonly functionInfo: string;
    readonly signingMessageDigest: Hex;
    readonly authenticator: Uint8Array;
    /**
     * DAA, which is extended of the AA module, requires an account identity
     */
    readonly accountIdentity?: Uint8Array;
    constructor(functionInfo: string, signingMessageDigest: HexInput, authenticator: Uint8Array, accountIdentity?: Uint8Array);
    serialize(serializer: Serializer): void;
    static load(deserializer: Deserializer): AccountAuthenticatorAbstraction;
}

export { AccountAuthenticatorNoAccountAuthenticator as $, AptosConfig as A, Bool as B, PublicKey as C, type Deserializable as D, Ed25519PublicKey as E, FixedBytes as F, AccountPublicKey as G, Secp256k1PublicKey as H, Secp256k1PrivateKey as I, Secp256k1Signature as J, Signature as K, type PrivateKeyInput as L, MoveVector as M, AnyPublicKey as N, AnySignature as O, PrivateKey as P, HexInvalidReason as Q, Hex as R, Serializable as S, hexToAsciiString as T, U8 as U, type VerifySignatureArgs as V, AccountAuthenticator as W, AccountAuthenticatorEd25519 as X, AccountAuthenticatorMultiEd25519 as Y, AccountAuthenticatorSingleKey as Z, AccountAuthenticatorMultiKey as _, Deserializer as a, type InputMultiSigDataWithABI as a$, AccountAuthenticatorAbstraction as a0, ChainId as a1, Identifier as a2, ModuleId as a3, RawTransaction as a4, RawTransactionWithData as a5, MultiAgentRawTransaction as a6, FeePayerRawTransaction as a7, type TransactionArgument as a8, type EntryFunctionArgument as a9, TypeTagU128 as aA, TypeTagU256 as aB, TypeTagAddress as aC, TypeTagSigner as aD, TypeTagReference as aE, TypeTagGeneric as aF, TypeTagVector as aG, TypeTagStruct as aH, StructTag as aI, aptosCoinStructTag as aJ, stringStructTag as aK, optionStructTag as aL, objectStructTag as aM, type SimpleEntryFunctionArgumentTypes as aN, type EntryFunctionArgumentTypes as aO, type ScriptFunctionArgumentTypes as aP, type TypeArgument as aQ, type AnyRawTransactionInstance as aR, type InputGenerateTransactionOptions as aS, type InputGenerateSequenceNumberTransactionOptions as aT, type InputGenerateOrderlessTransactionOptions as aU, type AnyTransactionPayloadInstance as aV, type InputGenerateTransactionPayloadData as aW, type InputGenerateTransactionPayloadDataWithRemoteABI as aX, type InputEntryFunctionData as aY, type InputGenerateTransactionPayloadDataWithABI as aZ, type InputEntryFunctionDataWithABI as a_, type ScriptFunctionArgument as aa, deserializeFromScriptArgument as ab, TransactionPayload as ac, TransactionPayloadScript as ad, TransactionPayloadEntryFunction as ae, TransactionPayloadMultiSig as af, EntryFunction as ag, Script as ah, MultiSig as ai, MultiSigTransactionPayload as aj, TransactionInnerPayload as ak, TransactionInnerPayloadV1 as al, TransactionExecutable as am, TransactionExecutableScript as an, TransactionExecutableEntryFunction as ao, TransactionExecutableEmpty as ap, TransactionExtraConfig as aq, TransactionExtraConfigV1 as ar, SimpleTransaction as as, MultiAgentTransaction as at, TypeTag as au, TypeTagBool as av, TypeTagU8 as aw, TypeTagU16 as ax, TypeTagU32 as ay, TypeTagU64 as az, Serializer as b, type TransactionSubmitter as b$, type InputEntryFunctionDataWithRemoteABI as b0, type InputMultiSigData as b1, type InputMultiSigDataWithRemoteABI as b2, type InputScriptData as b3, type InputViewFunctionData as b4, type InputViewFunctionJsonData as b5, type ViewFunctionJsonPayload as b6, type InputViewFunctionDataWithRemoteABI as b7, type InputViewFunctionDataWithABI as b8, type FunctionABI as b9, anyPublicKeyVariantToString as bA, AnySignatureVariant as bB, EphemeralPublicKeyVariant as bC, EphemeralSignatureVariant as bD, EphemeralCertificateVariant as bE, ZkpVariant as bF, type Uint8 as bG, type Uint16 as bH, type Uint32 as bI, type Uint64 as bJ, type Uint128 as bK, type Uint256 as bL, type AnyNumber as bM, type AptosSettings as bN, type PaginationArgs as bO, type CursorPaginationArgs as bP, type TokenStandardArg as bQ, type OrderByArg as bR, type WhereArg as bS, type ClientConfig as bT, type FullNodeConfig as bU, type IndexerConfig as bV, type FaucetConfig as bW, type TransactionGenerationConfig as bX, type ClientHeadersType as bY, type PluginConfig as bZ, type PluginSettings as b_, type EntryFunctionABI as ba, type ViewFunctionABI as bb, type InputGenerateSingleSignerRawTransactionArgs as bc, type InputGenerateMultiAgentRawTransactionArgs as bd, type InputGenerateRawTransactionArgs as be, type AnyRawTransaction as bf, type InputSimulateTransactionData as bg, type InputSimulateTransactionOptions as bh, type InputGenerateSingleSignerRawTransactionData as bi, type InputGenerateMultiAgentRawTransactionData as bj, type InputGenerateTransactionData as bk, type InputTransactionPluginData as bl, type InputSubmitTransactionData as bm, MimeType as bn, type HexInput as bo, TypeTagVariants as bp, ScriptTransactionArgumentVariants as bq, TransactionPayloadVariants as br, TransactionInnerPayloadVariants as bs, TransactionExecutableVariants as bt, TransactionExtraConfigVariants as bu, TransactionVariants as bv, TransactionAuthenticatorVariant as bw, AccountAuthenticatorVariant as bx, PrivateKeyVariants as by, AnyPublicKeyVariant as bz, U16 as c, type MoveUint16Type as c$, type ClientRequest as c0, type ClientResponse as c1, type Client as c2, type AptosRequest as c3, type AptosResponse as c4, type LedgerVersionArg as c5, type GasEstimation as c6, type MoveResource as c7, type AccountData as c8, type MoveModuleBytecode as c9, type DeletedTableData as cA, type TransactionPayloadResponse as cB, type EntryFunctionPayloadResponse as cC, type ScriptPayloadResponse as cD, type MultisigPayloadResponse as cE, type GenesisPayload as cF, type MoveScriptBytecode as cG, type TransactionSignature as cH, isEd25519Signature as cI, isSecp256k1Signature as cJ, isMultiAgentSignature as cK, isFeePayerSignature as cL, isMultiEd25519Signature as cM, isSingleSenderSignature as cN, type TransactionEd25519Signature as cO, type TransactionSecp256k1Signature as cP, type TransactionSingleSenderSignature as cQ, type TransactionMultiEd25519Signature as cR, type TransactionMultiAgentSignature as cS, type TransactionFeePayerSignature as cT, type AccountSignature as cU, type WriteSet as cV, type ScriptWriteSet as cW, type DirectWriteSet as cX, type EventGuid as cY, type Event as cZ, type MoveUint8Type as c_, TransactionResponseType as ca, type TransactionResponse as cb, type CommittedTransactionResponse as cc, isPendingTransactionResponse as cd, isUserTransactionResponse as ce, isGenesisTransactionResponse as cf, isBlockMetadataTransactionResponse as cg, isStateCheckpointTransactionResponse as ch, isValidatorTransactionResponse as ci, isBlockEpilogueTransactionResponse as cj, type PendingTransactionResponse as ck, type UserTransactionResponse as cl, type GenesisTransactionResponse as cm, type BlockMetadataTransactionResponse as cn, type StateCheckpointTransactionResponse as co, type ValidatorTransactionResponse as cp, type BlockEndInfo as cq, type BlockEpilogueTransactionResponse as cr, type WriteSetChange as cs, type WriteSetChangeDeleteModule as ct, type WriteSetChangeDeleteResource as cu, type WriteSetChangeDeleteTableItem as cv, type WriteSetChangeWriteModule as cw, type WriteSetChangeWriteResource as cx, type WriteSetChangeWriteTableItem as cy, type DecodedTableData as cz, U32 as d, type MoveUint32Type as d0, type MoveUint64Type as d1, type MoveUint128Type as d2, type MoveUint256Type as d3, type MoveAddressType as d4, type MoveObjectType as d5, type MoveOptionType as d6, type MoveStructId as d7, type MoveFunctionId as d8, type MoveStructType as d9, type MoveType as da, type MoveValue as db, type MoveModuleId as dc, MoveFunctionVisibility as dd, MoveAbility as de, type MoveFunctionGenericTypeParam as df, type MoveStructField as dg, type MoveModule as dh, type MoveStruct as di, type MoveFunction as dj, RoleType as dk, type LedgerInfo as dl, type Block as dm, type TableItemRequest as dn, type AuthenticationKeyScheme as dp, SigningScheme as dq, SigningSchemeInput as dr, DeriveScheme as ds, type WaitForTransactionOptions as dt, type GenerateAccountWithEd25519 as du, type GenerateAccountWithSingleSignerSecp256k1Key as dv, type GenerateAccount as dw, ensureBoolean as e, U64 as f, U128 as g, U256 as h, Serialized as i, MoveString as j, MoveOption as k, AddressInvalidReason as l, type AccountAddressInput as m, AccountAddress as n, outOfRangeErrorMessage as o, AuthenticationKey as p, isCanonicalEd25519Signature as q, Ed25519PrivateKey as r, Ed25519Signature as s, MultiEd25519PublicKey as t, MultiEd25519Signature as u, validateNumberInRange as v, AbstractMultiKey as w, MultiKey as x, MultiKeySignature as y, type VerifySignatureAsyncArgs as z };
